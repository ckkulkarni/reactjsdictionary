94619d7c2998b440e9eb43320429030a
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var _ref;

// Should be no imports here!
// Some things that should be evaluated before all else...
// We only want to know if non-polyfilled symbols are available
var hasSymbol = typeof Symbol !== "undefined" && typeof /*#__PURE__*/
Symbol("x") === "symbol";
var hasMap = typeof Map !== "undefined";
var hasSet = typeof Set !== "undefined";
var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
/**
 * The sentinel value returned by producers to replace the draft with undefined.
 */

var NOTHING = hasSymbol ? /*#__PURE__*/
Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
/**
 * To let Immer treat your class instances as plain immutable objects
 * (albeit with a custom prototype), you must define either an instance property
 * or a static property on each of your custom classes.
 *
 * Otherwise, your class instance will never be drafted, which means it won't be
 * safe to mutate in a produce callback.
 */

var DRAFTABLE = hasSymbol ? /*#__PURE__*/
Symbol.for("immer-draftable") : "__$immer_draftable";
var DRAFT_STATE = hasSymbol ? /*#__PURE__*/
Symbol.for("immer-state") : "__$immer_state"; // Even a polyfilled Symbol might provide Symbol.iterator

var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
var errors = {
  0: "Illegal state",
  1: "Immer drafts cannot have computed properties",
  2: "This object has been frozen and should not be mutated",
  3: function _(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  5: "Immer forbids circular references",
  6: "The first or second argument to `produce` must be a function",
  7: "The third argument to `produce` must be a function or undefined",
  8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
  10: "The given draft is already finalized",
  11: "Object.defineProperty() cannot be used on an Immer draft",
  12: "Object.setPrototypeOf() cannot be used on an Immer draft",
  13: "Immer only supports deleting array indices",
  14: "Immer only supports setting array indices and the 'length' property",
  15: function _(path) {
    return "Cannot apply patch, path doesn't resolve: " + path;
  },
  16: 'Sets cannot have "replace" patches.',
  17: function _(op) {
    return "Unsupported patch operation: " + op;
  },
  18: function _(plugin) {
    return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
  },
  20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
  21: function _(thing) {
    return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
  },
  22: function _(thing) {
    return "'current' expects a draft, got: " + thing;
  },
  23: function _(thing) {
    return "'original' expects a draft, got: " + thing;
  },
  24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
};
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  {
    var e = errors[error];
    var msg = !e ? "unknown error nr: " + error : typeof e === "function" ? e.apply(null, args) : e;
    throw new Error("[Immer] " + msg);
  }
}

/** Returns true if the given value is an Immer draft */

/*#__PURE__*/

function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
/** Returns true if the given value can be drafted by Immer */

/*#__PURE__*/

function isDraftable(value) {
  var _value$constructor;
  if (!value) return false;
  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = /*#__PURE__*/
Object.prototype.constructor.toString();
/*#__PURE__*/

function isPlainObject(value) {
  if (!value || typeof value !== "object") return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object) return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function original(value) {
  if (!isDraft(value)) die(23, value);
  return value[DRAFT_STATE].base_;
}
/*#__PURE__*/

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : /* istanbul ignore next */
Object.getOwnPropertyNames;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {};
  ownKeys(target).forEach(function (key) {
    res[key] = Object.getOwnPropertyDescriptor(target, key);
  });
  return res;
};
function each(obj, iter, enumerableOnly) {
  if (enumerableOnly === void 0) {
    enumerableOnly = false;
  }
  if (getArchtype(obj) === 0
  /* Object */) {
    (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {
      if (!enumerableOnly || typeof key !== "symbol") iter(key, obj[key], obj);
    });
  } else {
    obj.forEach(function (entry, index) {
      return iter(index, entry, obj);
    });
  }
}
/*#__PURE__*/

function getArchtype(thing) {
  /* istanbul ignore next */
  var state = thing[DRAFT_STATE];
  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5
  : state.type_ // others are the same
  : Array.isArray(thing) ? 1
  /* Array */ : isMap(thing) ? 2
  /* Map */ : isSet(thing) ? 3
  /* Set */ : 0
  /* Object */;
}
/*#__PURE__*/

function has(thing, prop) {
  return getArchtype(thing) === 2
  /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
/*#__PURE__*/

function get(thing, prop) {
  // @ts-ignore
  return getArchtype(thing) === 2
  /* Map */ ? thing.get(prop) : thing[prop];
}
/*#__PURE__*/

function set(thing, propOrOldValue, value) {
  var t = getArchtype(thing);
  if (t === 2
  /* Map */) thing.set(propOrOldValue, value);else if (t === 3
  /* Set */) {
    thing.add(value);
  } else thing[propOrOldValue] = value;
}
/*#__PURE__*/

function is(x, y) {
  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
/*#__PURE__*/

function isMap(target) {
  return hasMap && target instanceof Map;
}
/*#__PURE__*/

function isSet(target) {
  return hasSet && target instanceof Set;
}
/*#__PURE__*/

function latest(state) {
  return state.copy_ || state.base_;
}
/*#__PURE__*/

function shallowCopy(base) {
  if (Array.isArray(base)) return Array.prototype.slice.call(base);
  var descriptors = getOwnPropertyDescriptors(base);
  delete descriptors[DRAFT_STATE];
  var keys = ownKeys(descriptors);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var desc = descriptors[key];
    if (desc.writable === false) {
      desc.writable = true;
      desc.configurable = true;
    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing
    // with libraries that trap values, like mobx or vue
    // unlike object.assign, non-enumerables will be copied as well

    if (desc.get || desc.set) descriptors[key] = {
      configurable: true,
      writable: true,
      enumerable: desc.enumerable,
      value: base[key]
    };
  }
  return Object.create(Object.getPrototypeOf(base), descriptors);
}
function freeze(obj, deep) {
  if (deep === void 0) {
    deep = false;
  }
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
  if (getArchtype(obj) > 1
  /* Map or Set */) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep) each(obj, function (key, value) {
    return freeze(value, true);
  }, true);
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  if (obj == null || typeof obj !== "object") return true; // See #600, IE dies on non-objects in Object.isFrozen

  return Object.isFrozen(obj);
}

/** Plugin utilities */

var plugins = {};
function getPlugin(pluginKey) {
  var plugin = plugins[pluginKey];
  if (!plugin) {
    die(18, pluginKey);
  } // @ts-ignore

  return plugin;
}
function loadPlugin(pluginKey, implementation) {
  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
var currentScope;
function getCurrentScope() {
  if (!currentScope) die(0);
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_: parent_,
    immer_: immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches"); // assert we have the plugin

    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft); // @ts-ignore

  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer) {
  return currentScope = createScope(currentScope, immer);
}
function revokeDraft(draft) {
  var state = draft[DRAFT_STATE];
  if (state.type_ === 0
  /* ProxyObject */ || state.type_ === 1
  /* ProxyArray */) state.revoke_();else state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  var baseDraft = scope.drafts_[0];
  var isReplaced = result !== undefined && result !== baseDraft;
  if (!scope.immer_.useProxies_) getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      // Finalize the result in case it contains (or is) a subset of the draft.
      result = finalize(scope, result);
      if (!scope.parent_) maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
    }
  } else {
    // Finalize the base draft.
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : undefined;
}
function finalize(rootScope, value, path) {
  // Don't recurse in tho recursive data structures
  if (isFrozen(value)) return value;
  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts

  if (!state) {
    each(value, function (key, childValue) {
      return finalizeProperty(rootScope, state, value, key, childValue, path);
    }, true // See #590, don't recurse into non-enumerable of non drafted objects
    );

    return value;
  } // Never finalize drafts owned by another scope.

  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original

  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  } // Not finalized yet, let's do that now

  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    var result =
    // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
    state.type_ === 4
    /* ES5Object */ || state.type_ === 5
    /* ES5Array */ ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy
    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628
    // To preserve insertion order in all cases we then clear the set
    // And we let finalizeProperty know it needs to re-add non-draft children back to the target

    var resultEach = result;
    var isSet = false;
    if (state.type_ === 3
    /* Set */) {
      resultEach = new Set(result);
      result.clear();
      isSet = true;
    }
    each(resultEach, function (key, childValue) {
      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);
    }); // everything inside is frozen, we can freeze here

    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches

    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue === targetObject) die(5);
  if (isDraft(childValue)) {
    var path = rootPath && parentState && parentState.type_ !== 3
    /* Set */ &&
    // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.
    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.

    var res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen
    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze

    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.

  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      // optimization: if an object is not a draft, and we don't have to
      // deepfreeze everything, and we are sure that no drafts are left in the remaining object
      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.
      // This benefits especially adding large data tree's without further processing.
      // See add-data.js perf test
      return;
    }
    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well

    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep) {
  if (deep === void 0) {
    deep = false;
  }

  // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}

/**
 * Returns a new draft of the `base` object.
 *
 * The second argument is the parent draft-state (used internally).
 */

function createProxyProxy(base, parent) {
  var isArray = Array.isArray(base);
  var state = {
    type_: isArray ? 1
    /* ProxyArray */ : 0
    /* ProxyObject */,

    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  }; // the traps must target something, a bit like the 'real' base.
  // but also, we need to be able to determine from the target what the relevant state is
  // (to avoid creating traps per instance to capture the state in closure,
  // and to avoid creating weird hidden properties as well)
  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb

  var target = state;
  var traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  var _Proxy$revocable = Proxy.revocable(target, traps),
    revoke = _Proxy$revocable.revoke,
    proxy = _Proxy$revocable.proxy;
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
/**
 * Object drafts
 */

var objectTraps = {
  get: function get(state, prop) {
    if (prop === DRAFT_STATE) return state;
    var source = latest(state);
    if (!has(source, prop)) {
      // non-existing or non-own property...
      return readPropFromProto(state, source, prop);
    }
    var value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    } // Check for existing draft in modified state.
    // Assigned values are never drafted. This catches any drafts we created, too.

    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
    }
    return value;
  },
  has: function has(state, prop) {
    return prop in latest(state);
  },
  ownKeys: function ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set: function set(state, prop
  /* strictly not, but helps TS */, value) {
    var desc = getDescriptorFromProto(latest(state), prop);
    if (desc === null || desc === void 0 ? void 0 : desc.set) {
      // special case: if this write is captured by a setter, we have
      // to trigger it with the correct context
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)
      // from setting an existing property with value undefined to undefined (which is not a change)
      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment

      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && (
    // special case: handle new props with value 'undefined'
    value !== undefined || prop in state.copy_) ||
    // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore

    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty: function deleteProperty(state, prop) {
    // The `undefined` check is a fast path for pre-existing keys.
    if (peek(state.base_, prop) !== undefined || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      // if an originally not assigned property was deleted
      delete state.assigned_[prop];
    } // @ts-ignore

    if (state.copy_) delete state.copy_[prop];
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
    var owner = latest(state);
    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc) return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1
      /* ProxyArray */ || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty: function defineProperty() {
    die(11);
  },
  getPrototypeOf: function getPrototypeOf(state) {
    return Object.getPrototypeOf(state.base_);
  },
  setPrototypeOf: function setPrototypeOf() {
    die(12);
  }
};
/**
 * Array drafts
 */

var arrayTraps = {};
each(objectTraps, function (key, fn) {
  // @ts-ignore
  arrayTraps[key] = function () {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function (state, prop) {
  if (isNaN(parseInt(prop))) die(13); // @ts-ignore

  return arrayTraps.set.call(this, state, prop, undefined);
};
arrayTraps.set = function (state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop))) die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
}; // Access a property without creating an Immer draft.

function peek(draft, prop) {
  var state = draft[DRAFT_STATE];
  var source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _desc$get;
  var desc = getDescriptorFromProto(source, prop);
  return desc ? "value" in desc ? desc.value :
  // This is a very special case, if the prop is a getter defined by the
  // prototype, we should invoke it with the draft as context!
  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;
}
function getDescriptorFromProto(source, prop) {
  // 'in' checks proto!
  if (!(prop in source)) return undefined;
  var proto = Object.getPrototypeOf(source);
  while (proto) {
    var desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc) return desc;
    proto = Object.getPrototypeOf(proto);
  }
  return undefined;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(state.base_);
  }
}
var Immer = /*#__PURE__*/
function () {
  function Immer(config) {
    var _this = this;
    this.useProxies_ = hasProxies;
    this.autoFreeze_ = true;
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */

    this.produce = function (base, recipe, patchListener) {
      // curried invocation
      if (typeof base === "function" && typeof recipe !== "function") {
        var defaultBase = recipe;
        recipe = base;
        var self = _this;
        return function curriedProduce(base) {
          var _this2 = this;
          if (base === void 0) {
            base = defaultBase;
          }
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return self.produce(base, function (draft) {
            var _recipe;
            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
          }); // prettier-ignore
        };
      }

      if (typeof recipe !== "function") die(6);
      if (patchListener !== undefined && typeof patchListener !== "function") die(7);
      var result; // Only plain objects, arrays, and "immerable classes" are drafted.

      if (isDraftable(base)) {
        var scope = enterScope(_this);
        var proxy = createProxy(_this, base, undefined);
        var hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          // finally instead of catch + rethrow better preserves original stack
          if (hasError) revokeScope(scope);else leaveScope(scope);
        }
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then(function (result) {
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          }, function (error) {
            revokeScope(scope);
            throw error;
          });
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === undefined) result = base;
        if (result === NOTHING) result = undefined;
        if (_this.autoFreeze_) freeze(result, true);
        if (patchListener) {
          var p = [];
          var ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else die(21, base);
    };
    this.produceWithPatches = function (base, recipe) {
      // curried invocation
      if (typeof base === "function") {
        return function (state) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return _this.produceWithPatches(state, function (draft) {
            return base.apply(void 0, [draft].concat(args));
          });
        };
      }
      var patches, inversePatches;
      var result = _this.produce(base, recipe, function (p, ip) {
        patches = p;
        inversePatches = ip;
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then(function (nextState) {
          return [nextState, patches, inversePatches];
        });
      }
      return [result, patches, inversePatches];
    };
    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean") this.setUseProxies(config.useProxies);
    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
  }
  var _proto = Immer.prototype;
  _proto.createDraft = function createDraft(base) {
    if (!isDraftable(base)) die(8);
    if (isDraft(base)) base = current(base);
    var scope = enterScope(this);
    var proxy = createProxy(this, base, undefined);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  };
  _proto.finishDraft = function finishDraft(draft, patchListener) {
    var state = draft && draft[DRAFT_STATE];
    {
      if (!state || !state.isManual_) die(9);
      if (state.finalized_) die(10);
    }
    var scope = state.scope_;
    usePatchesInScope(scope, patchListener);
    return processResult(undefined, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */;

  _proto.setAutoFreeze = function setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */;

  _proto.setUseProxies = function setUseProxies(value) {
    if (value && !hasProxies) {
      die(20);
    }
    this.useProxies_ = value;
  };
  _proto.applyPatches = function applyPatches(base, patches) {
    // If a patch replaces the entire state, take that replacement as base
    // before applying patches
    var i;
    for (i = patches.length - 1; i >= 0; i--) {
      var patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    } // If there was a patch that replaced the entire state, start from the
    // patch after that.

    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    var applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      // N.B: never hits if some patch a replacement, patches are never drafts
      return applyPatchesImpl(base, patches);
    } // Otherwise, produce a copy of the base state.

    return this.produce(base, function (draft) {
      return applyPatchesImpl(draft, patches);
    });
  };
  return Immer;
}();
function createProxy(immer, value, parent) {
  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
  var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
  var scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value)) die(22, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value)) return value;
  var state = value[DRAFT_STATE];
  var copy;
  var archType = getArchtype(value);
  if (state) {
    if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying

    state.finalized_ = true;
    copy = copyHelper(value, archType);
    state.finalized_ = false;
  } else {
    copy = copyHelper(value, archType);
  }
  each(copy, function (key, childValue) {
    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change

    set(copy, key, currentImpl(childValue));
  }); // In the future, we might consider freezing here, based on the current settings

  return archType === 3
  /* Set */ ? new Set(copy) : copy;
}
function copyHelper(value, archType) {
  // creates a shallow copy, even if it is a map or set
  switch (archType) {
    case 2
    /* Map */:
      return new Map(value);
    case 3
    /* Set */:
      // Set will be cloned as array temporarily, so that we can replace individual items
      return Array.from(value);
  }
  return shallowCopy(value);
}
function enableES5() {
  function willFinalizeES5_(scope, result, isReplaced) {
    if (!isReplaced) {
      if (scope.patches_) {
        markChangesRecursively(scope.drafts_[0]);
      } // This is faster when we don't care about which attributes changed.

      markChangesSweep(scope.drafts_);
    } // When a child draft is returned, look for changes.
    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
      markChangesSweep(scope.drafts_);
    }
  }
  function createES5Draft(isArray, base) {
    if (isArray) {
      var draft = new Array(base.length);
      for (var i = 0; i < base.length; i++) {
        Object.defineProperty(draft, "" + i, proxyProperty(i, true));
      }
      return draft;
    } else {
      var _descriptors = getOwnPropertyDescriptors(base);
      delete _descriptors[DRAFT_STATE];
      var keys = ownKeys(_descriptors);
      for (var _i = 0; _i < keys.length; _i++) {
        var key = keys[_i];
        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
      }
      return Object.create(Object.getPrototypeOf(base), _descriptors);
    }
  }
  function createES5Proxy_(base, parent) {
    var isArray = Array.isArray(base);
    var draft = createES5Draft(isArray, base);
    var state = {
      type_: isArray ? 5
      /* ES5Array */ : 4
      /* ES5Object */,

      scope_: parent ? parent.scope_ : getCurrentScope(),
      modified_: false,
      finalized_: false,
      assigned_: {},
      parent_: parent,
      // base is the object we are drafting
      base_: base,
      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
      draft_: draft,
      copy_: null,
      revoked_: false,
      isManual_: false
    };
    Object.defineProperty(draft, DRAFT_STATE, {
      value: state,
      // enumerable: false <- the default
      writable: true
    });
    return draft;
  } // property descriptors are recycled to make sure we don't create a get and set closure per property,
  // but share them all instead

  var descriptors = {};
  function proxyProperty(prop, enumerable) {
    var desc = descriptors[prop];
    if (desc) {
      desc.enumerable = enumerable;
    } else {
      descriptors[prop] = desc = {
        configurable: true,
        enumerable: enumerable,
        get: function get() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state); // @ts-ignore

          return objectTraps.get(state, prop);
        },
        set: function set(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state); // @ts-ignore

          objectTraps.set(state, prop, value);
        }
      };
    }
    return desc;
  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.

  function markChangesSweep(drafts) {
    // The natural order of drafts in the `scope` array is based on when they
    // were accessed. By processing drafts in reverse natural order, we have a
    // better chance of processing leaf nodes first. When a leaf node is known to
    // have changed, we can avoid any traversal of its ancestor nodes.
    for (var i = drafts.length - 1; i >= 0; i--) {
      var state = drafts[i][DRAFT_STATE];
      if (!state.modified_) {
        switch (state.type_) {
          case 5
          /* ES5Array */:
            if (hasArrayChanges(state)) markChanged(state);
            break;
          case 4
          /* ES5Object */:
            if (hasObjectChanges(state)) markChanged(state);
            break;
        }
      }
    }
  }
  function markChangesRecursively(object) {
    if (!object || typeof object !== "object") return;
    var state = object[DRAFT_STATE];
    if (!state) return;
    var base_ = state.base_,
      draft_ = state.draft_,
      assigned_ = state.assigned_,
      type_ = state.type_;
    if (type_ === 4
    /* ES5Object */) {
      // Look for added keys.
      // probably there is a faster way to detect changes, as sweep + recurse seems to do some
      // unnecessary work.
      // also: probably we can store the information we detect here, to speed up tree finalization!
      each(draft_, function (key) {
        if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.

        if (base_[key] === undefined && !has(base_, key)) {
          assigned_[key] = true;
          markChanged(state);
        } else if (!assigned_[key]) {
          // Only untouched properties trigger recursion.
          markChangesRecursively(draft_[key]);
        }
      }); // Look for removed keys.

      each(base_, function (key) {
        // The `undefined` check is a fast path for pre-existing keys.
        if (draft_[key] === undefined && !has(draft_, key)) {
          assigned_[key] = false;
          markChanged(state);
        }
      });
    } else if (type_ === 5
    /* ES5Array */) {
      if (hasArrayChanges(state)) {
        markChanged(state);
        assigned_.length = true;
      }
      if (draft_.length < base_.length) {
        for (var i = draft_.length; i < base_.length; i++) {
          assigned_[i] = false;
        }
      } else {
        for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
          assigned_[_i2] = true;
        }
      } // Minimum count is enough, the other parts has been processed.

      var min = Math.min(draft_.length, base_.length);
      for (var _i3 = 0; _i3 < min; _i3++) {
        // Only untouched indices trigger recursion.
        if (!draft_.hasOwnProperty(_i3)) {
          assigned_[_i3] = true;
        }
        if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);
      }
    }
  }
  function hasObjectChanges(state) {
    var base_ = state.base_,
      draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because
    // non-numeric keys are ordered by time of definition on the object.

    var keys = ownKeys(draft_);
    for (var i = keys.length - 1; i >= 0; i--) {
      var key = keys[i];
      if (key === DRAFT_STATE) continue;
      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.

      if (baseValue === undefined && !has(base_, key)) {
        return true;
      } // Once a base key is deleted, future changes go undetected, because its
      // descriptor is erased. This branch detects any missed changes.
      else {
        var value = draft_[key];
        var _state = value && value[DRAFT_STATE];
        if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
          return true;
        }
      }
    } // At this point, no keys were added or changed.
    // Compare key count to determine if keys were deleted.

    var baseIsDraft = !!base_[DRAFT_STATE];
    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE
  }

  function hasArrayChanges(state) {
    var draft_ = state.draft_;
    if (draft_.length !== state.base_.length) return true; // See #116
    // If we first shorten the length, our array interceptors will be removed.
    // If after that new items are added, result in the same original length,
    // those last items will have no intercepting property.
    // So if there is no own descriptor on the last position, we know that items were removed and added
    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
    // the last one
    // last descriptor can be not a trap, if the array was extended

    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed

    for (var i = 0; i < draft_.length; i++) {
      if (!draft_.hasOwnProperty(i)) return true;
    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters

    return false;
  }
  function hasChanges_(state) {
    return state.type_ === 4
    /* ES5Object */ ? hasObjectChanges(state) : hasArrayChanges(state);
  }
  function assertUnrevoked(state
  /*ES5State | MapState | SetState*/) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("ES5", {
    createES5Proxy_: createES5Proxy_,
    willFinalizeES5_: willFinalizeES5_,
    hasChanges_: hasChanges_
  });
}
function enablePatches() {
  var REPLACE = "replace";
  var ADD = "add";
  var REMOVE = "remove";
  function generatePatches_(state, basePath, patches, inversePatches) {
    switch (state.type_) {
      case 0
      /* ProxyObject */:

      case 4
      /* ES5Object */:

      case 2
      /* Map */:
        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
      case 5
      /* ES5Array */:

      case 1
      /* ProxyArray */:
        return generateArrayPatches(state, basePath, patches, inversePatches);
      case 3
      /* Set */:
        return generateSetPatches(state, basePath, patches, inversePatches);
    }
  }
  function generateArrayPatches(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
      assigned_ = state.assigned_;
    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.

    if (copy_.length < base_.length) {
      var _ref = [copy_, base_];
      base_ = _ref[0];
      copy_ = _ref[1];
      var _ref2 = [inversePatches, patches];
      patches = _ref2[0];
      inversePatches = _ref2[1];
    } // Process replaced indices.

    for (var i = 0; i < base_.length; i++) {
      if (assigned_[i] && copy_[i] !== base_[i]) {
        var path = basePath.concat([i]);
        patches.push({
          op: REPLACE,
          path: path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
        inversePatches.push({
          op: REPLACE,
          path: path,
          value: clonePatchValueIfNeeded(base_[i])
        });
      }
    } // Process added indices.

    for (var _i = base_.length; _i < copy_.length; _i++) {
      var _path = basePath.concat([_i]);
      patches.push({
        op: ADD,
        path: _path,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: clonePatchValueIfNeeded(copy_[_i])
      });
    }
    if (base_.length < copy_.length) {
      inversePatches.push({
        op: REPLACE,
        path: basePath.concat(["length"]),
        value: base_.length
      });
    }
  } // This is used for both Map objects and normal objects.

  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
      copy_ = state.copy_;
    each(state.assigned_, function (key, assignedValue) {
      var origValue = get(base_, key);
      var value = get(copy_, key);
      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
      if (origValue === value && op === REPLACE) return;
      var path = basePath.concat(key);
      patches.push(op === REMOVE ? {
        op: op,
        path: path
      } : {
        op: op,
        path: path,
        value: value
      });
      inversePatches.push(op === ADD ? {
        op: REMOVE,
        path: path
      } : op === REMOVE ? {
        op: ADD,
        path: path,
        value: clonePatchValueIfNeeded(origValue)
      } : {
        op: REPLACE,
        path: path,
        value: clonePatchValueIfNeeded(origValue)
      });
    });
  }
  function generateSetPatches(state, basePath, patches, inversePatches) {
    var base_ = state.base_,
      copy_ = state.copy_;
    var i = 0;
    base_.forEach(function (value) {
      if (!copy_.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: REMOVE,
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: ADD,
          path: path,
          value: value
        });
      }
      i++;
    });
    i = 0;
    copy_.forEach(function (value) {
      if (!base_.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: REMOVE,
          path: path,
          value: value
        });
      }
      i++;
    });
  }
  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
    patches.push({
      op: REPLACE,
      path: [],
      value: replacement === NOTHING ? undefined : replacement
    });
    inversePatches.push({
      op: REPLACE,
      path: [],
      value: baseValue
    });
  }
  function applyPatches_(draft, patches) {
    patches.forEach(function (patch) {
      var path = patch.path,
        op = patch.op;
      var base = draft;
      for (var i = 0; i < path.length - 1; i++) {
        var parentType = getArchtype(base);
        var p = path[i];
        if (typeof p !== "string" && typeof p !== "number") {
          p = "" + p;
        } // See #738, avoid prototype pollution

        if ((parentType === 0
        /* Object */ || parentType === 1
        /* Array */) && (p === "__proto__" || p === "constructor")) die(24);
        if (typeof base === "function" && p === "prototype") die(24);
        base = get(base, p);
        if (typeof base !== "object") die(15, path.join("/"));
      }
      var type = getArchtype(base);
      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411

      var key = path[path.length - 1];
      switch (op) {
        case REPLACE:
          switch (type) {
            case 2
            /* Map */:
              return base.set(key, value);

            /* istanbul ignore next */

            case 3
            /* Set */:
              die(16);
            default:
              // if value is an object, then it's assigned by reference
              // in the following add or remove ops, the value field inside the patch will also be modifyed
              // so we use value from the cloned patch
              // @ts-ignore
              return base[key] = value;
          }
        case ADD:
          switch (type) {
            case 1
            /* Array */:
              return key === "-" ? base.push(value) : base.splice(key, 0, value);
            case 2
            /* Map */:
              return base.set(key, value);
            case 3
            /* Set */:
              return base.add(value);
            default:
              return base[key] = value;
          }
        case REMOVE:
          switch (type) {
            case 1
            /* Array */:
              return base.splice(key, 1);
            case 2
            /* Map */:
              return base.delete(key);
            case 3
            /* Set */:
              return base.delete(patch.value);
            default:
              return delete base[key];
          }
        default:
          die(17, op);
      }
    });
    return draft;
  }
  function deepClonePatchValue(obj) {
    if (!isDraftable(obj)) return obj;
    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {
      var k = _ref3[0],
        v = _ref3[1];
      return [k, deepClonePatchValue(v)];
    }));
    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
    var cloned = Object.create(Object.getPrototypeOf(obj));
    for (var key in obj) {
      cloned[key] = deepClonePatchValue(obj[key]);
    }
    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
    return cloned;
  }
  function clonePatchValueIfNeeded(obj) {
    if (isDraft(obj)) {
      return deepClonePatchValue(obj);
    } else return obj;
  }
  loadPlugin("Patches", {
    applyPatches_: applyPatches_,
    generatePatches_: generatePatches_,
    generateReplacementPatches_: generateReplacementPatches_
  });
}

// types only!
function enableMapSet() {
  /* istanbul ignore next */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };
    return _extendStatics(d, b);
  }; // Ugly hack to resolve #502 and inherit built in Map / Set

  function __extends(d, b) {
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = (
    // @ts-ignore
    __.prototype = b.prototype, new __());
  }
  var DraftMap = function (_super) {
    __extends(DraftMap, _super); // Create class manually, cause #502

    function DraftMap(target, parent) {
      this[DRAFT_STATE] = {
        type_: 2
        /* Map */,

        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: undefined,
        assigned_: undefined,
        base_: target,
        draft_: this,
        isManual_: false,
        revoked_: false
      };
      return this;
    }
    var p = DraftMap.prototype;
    Object.defineProperty(p, "size", {
      get: function get() {
        return latest(this[DRAFT_STATE]).size;
      } // enumerable: false,
      // configurable: true
    });

    p.has = function (key) {
      return latest(this[DRAFT_STATE]).has(key);
    };
    p.set = function (key, value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!latest(state).has(key) || latest(state).get(key) !== value) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_.set(key, true);
        state.copy_.set(key, value);
        state.assigned_.set(key, true);
      }
      return this;
    };
    p.delete = function (key) {
      if (!this.has(key)) {
        return false;
      }
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareMapCopy(state);
      markChanged(state);
      if (state.base_.has(key)) {
        state.assigned_.set(key, false);
      } else {
        state.assigned_.delete(key);
      }
      state.copy_.delete(key);
      return true;
    };
    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareMapCopy(state);
        markChanged(state);
        state.assigned_ = new Map();
        each(state.base_, function (key) {
          state.assigned_.set(key, false);
        });
        state.copy_.clear();
      }
    };
    p.forEach = function (cb, thisArg) {
      var _this = this;
      var state = this[DRAFT_STATE];
      latest(state).forEach(function (_value, key, _map) {
        cb.call(thisArg, _this.get(key), key, _this);
      });
    };
    p.get = function (key) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      var value = latest(state).get(key);
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value !== state.base_.get(key)) {
        return value; // either already drafted or reassigned
      } // despite what it looks, this creates a draft only once, see above condition

      var draft = createProxy(state.scope_.immer_, value, state);
      prepareMapCopy(state);
      state.copy_.set(key, draft);
      return draft;
    };
    p.keys = function () {
      return latest(this[DRAFT_STATE]).keys();
    };
    p.values = function () {
      var _this2 = this,
        _ref;
      var iterator = this.keys();
      return _ref = {}, _ref[iteratorSymbol] = function () {
        return _this2.values();
      }, _ref.next = function next() {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) return r;
        var value = _this2.get(r.value);
        return {
          done: false,
          value: value
        };
      }, _ref;
    };
    p.entries = function () {
      var _this3 = this,
        _ref2;
      var iterator = this.keys();
      return _ref2 = {}, _ref2[iteratorSymbol] = function () {
        return _this3.entries();
      }, _ref2.next = function next() {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) return r;
        var value = _this3.get(r.value);
        return {
          done: false,
          value: [r.value, value]
        };
      }, _ref2;
    };
    p[iteratorSymbol] = function () {
      return this.entries();
    };
    return DraftMap;
  }(Map);
  function proxyMap_(target, parent) {
    // @ts-ignore
    return new DraftMap(target, parent);
  }
  function prepareMapCopy(state) {
    if (!state.copy_) {
      state.assigned_ = new Map();
      state.copy_ = new Map(state.base_);
    }
  }
  var DraftSet = function (_super) {
    __extends(DraftSet, _super); // Create class manually, cause #502

    function DraftSet(target, parent) {
      this[DRAFT_STATE] = {
        type_: 3
        /* Set */,

        parent_: parent,
        scope_: parent ? parent.scope_ : getCurrentScope(),
        modified_: false,
        finalized_: false,
        copy_: undefined,
        base_: target,
        draft_: this,
        drafts_: new Map(),
        revoked_: false,
        isManual_: false
      };
      return this;
    }
    var p = DraftSet.prototype;
    Object.defineProperty(p, "size", {
      get: function get() {
        return latest(this[DRAFT_STATE]).size;
      } // enumerable: true,
    });

    p.has = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value

      if (!state.copy_) {
        return state.base_.has(value);
      }
      if (state.copy_.has(value)) return true;
      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
      return false;
    };
    p.add = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (!this.has(value)) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.add(value);
      }
      return this;
    };
    p.delete = function (value) {
      if (!this.has(value)) {
        return false;
      }
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      markChanged(state);
      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */
      false);
    };
    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      if (latest(state).size) {
        prepareSetCopy(state);
        markChanged(state);
        state.copy_.clear();
      }
    };
    p.values = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.values();
    };
    p.entries = function entries() {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareSetCopy(state);
      return state.copy_.entries();
    };
    p.keys = function () {
      return this.values();
    };
    p[iteratorSymbol] = function () {
      return this.values();
    };
    p.forEach = function forEach(cb, thisArg) {
      var iterator = this.values();
      var result = iterator.next();
      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    };
    return DraftSet;
  }(Set);
  function proxySet_(target, parent) {
    // @ts-ignore
    return new DraftSet(target, parent);
  }
  function prepareSetCopy(state) {
    if (!state.copy_) {
      // create drafts for all entries to preserve insertion order
      state.copy_ = new Set();
      state.base_.forEach(function (value) {
        if (isDraftable(value)) {
          var draft = createProxy(state.scope_.immer_, value, state);
          state.drafts_.set(value, draft);
          state.copy_.add(draft);
        } else {
          state.copy_.add(value);
        }
      });
    }
  }
  function assertUnrevoked(state
  /*ES5State | MapState | SetState*/) {
    if (state.revoked_) die(3, JSON.stringify(latest(state)));
  }
  loadPlugin("MapSet", {
    proxyMap_: proxyMap_,
    proxySet_: proxySet_
  });
}
function enableAllPlugins() {
  enableES5();
  enableMapSet();
  enablePatches();
}
var immer = /*#__PURE__*/
new Immer();
/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */

var produce = immer.produce;
/**
 * Like `produce`, but `produceWithPatches` always returns a tuple
 * [nextState, patches, inversePatches] (instead of just the next state)
 */

var produceWithPatches = /*#__PURE__*/
immer.produceWithPatches.bind(immer);
/**
 * Pass true to automatically freeze all copies created by Immer.
 *
 * Always freeze by default, even in production mode
 */

var setAutoFreeze = /*#__PURE__*/
immer.setAutoFreeze.bind(immer);
/**
 * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
 * always faster than using ES5 proxies.
 *
 * By default, feature detection is used, so calling this is rarely necessary.
 */

var setUseProxies = /*#__PURE__*/
immer.setUseProxies.bind(immer);
/**
 * Apply an array of Immer patches to the first argument.
 *
 * This function is a producer, which means copy-on-write is in effect.
 */

var applyPatches = /*#__PURE__*/
immer.applyPatches.bind(immer);
/**
 * Create an Immer draft from the given base state, which may be a draft itself.
 * The draft can be modified until you finalize it with the `finishDraft` function.
 */

var createDraft = /*#__PURE__*/
immer.createDraft.bind(immer);
/**
 * Finalize an Immer draft from a `createDraft` call, returning the base state
 * (if no changes were made) or a modified copy. The draft must *not* be
 * mutated afterwards.
 *
 * Pass a function as the 2nd argument to generate Immer patches based on the
 * changes that were made.
 */

var finishDraft = /*#__PURE__*/
immer.finishDraft.bind(immer);
/**
 * This function is actually a no-op, but can be used to cast an immutable type
 * to an draft type and make TypeScript happy
 *
 * @param value
 */

function castDraft(value) {
  return value;
}
/**
 * This function is actually a no-op, but can be used to cast a mutable type
 * to an immutable type and make TypeScript happy
 * @param value
 */

function castImmutable(value) {
  return value;
}
exports.Immer = Immer;
exports.applyPatches = applyPatches;
exports.castDraft = castDraft;
exports.castImmutable = castImmutable;
exports.createDraft = createDraft;
exports.current = current;
exports.default = produce;
exports.enableAllPlugins = enableAllPlugins;
exports.enableES5 = enableES5;
exports.enableMapSet = enableMapSet;
exports.enablePatches = enablePatches;
exports.finishDraft = finishDraft;
exports.freeze = freeze;
exports.immerable = DRAFTABLE;
exports.isDraft = isDraft;
exports.isDraftable = isDraftable;
exports.nothing = NOTHING;
exports.original = original;
exports.produce = produce;
exports.produceWithPatches = produceWithPatches;
exports.setAutoFreeze = setAutoFreeze;
exports.setUseProxies = setUseProxies;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJoYXNTeW1ib2wiLCJTeW1ib2wiLCJoYXNNYXAiLCJNYXAiLCJoYXNTZXQiLCJTZXQiLCJoYXNQcm94aWVzIiwiUHJveHkiLCJyZXZvY2FibGUiLCJSZWZsZWN0IiwiTk9USElORyIsImZvciIsIl9yZWYiLCJEUkFGVEFCTEUiLCJEUkFGVF9TVEFURSIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJlcnJvcnMiLCJfIiwiZGF0YSIsInBhdGgiLCJvcCIsInBsdWdpbiIsInRoaW5nIiwiZGllIiwiZXJyb3IiLCJhcmdzIiwiQXJyYXkiLCJfbGVuIiwiX2tleSIsImFyZ3VtZW50cyIsImUiLCJtc2ciLCJhcHBseSIsIkVycm9yIiwiaXNEcmFmdCIsInZhbHVlIiwiaXNEcmFmdGFibGUiLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsIl92YWx1ZSRjb25zdHJ1Y3RvciIsImNvbnN0cnVjdG9yIiwiaXNNYXAiLCJpc1NldCIsIm9iamVjdEN0b3JTdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJDdG9yIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiRnVuY3Rpb24iLCJvcmlnaW5hbCIsImJhc2VfIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwidGFyZ2V0IiwicmVzIiwiZm9yRWFjaCIsImtleSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVhY2giLCJpdGVyIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRBcmNodHlwZSIsImtleXMiLCJlbnRyeSIsImluZGV4Iiwic3RhdGUiLCJ0eXBlXyIsImhhcyIsInByb3AiLCJnZXQiLCJzZXQiLCJwcm9wT3JPbGRWYWx1ZSIsInQiLCJhZGQiLCJpcyIsIngiLCJ5IiwibGF0ZXN0IiwiY29weV8iLCJzaGFsbG93Q29weSIsImJhc2UiLCJzbGljZSIsImRlc2NyaXB0b3JzIiwiaSIsImxlbmd0aCIsImRlc2MiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJmcmVlemUiLCJkZWVwIiwiaXNGcm96ZW4iLCJjbGVhciIsImRlbGV0ZSIsImRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucyIsInBsdWdpbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJsb2FkUGx1Z2luIiwiaW1wbGVtZW50YXRpb24iLCJjdXJyZW50U2NvcGUiLCJnZXRDdXJyZW50U2NvcGUiLCJjcmVhdGVTY29wZSIsInBhcmVudF8iLCJpbW1lcl8iLCJkcmFmdHNfIiwiY2FuQXV0b0ZyZWV6ZV8iLCJ1bmZpbmFsaXplZERyYWZ0c18iLCJ1c2VQYXRjaGVzSW5TY29wZSIsInNjb3BlIiwicGF0Y2hMaXN0ZW5lciIsInBhdGNoZXNfIiwiaW52ZXJzZVBhdGNoZXNfIiwicGF0Y2hMaXN0ZW5lcl8iLCJyZXZva2VTY29wZSIsImxlYXZlU2NvcGUiLCJyZXZva2VEcmFmdCIsImVudGVyU2NvcGUiLCJpbW1lciIsImRyYWZ0IiwicmV2b2tlXyIsInJldm9rZWRfIiwicHJvY2Vzc1Jlc3VsdCIsInJlc3VsdCIsImJhc2VEcmFmdCIsImlzUmVwbGFjZWQiLCJ1bmRlZmluZWQiLCJ1c2VQcm94aWVzXyIsIndpbGxGaW5hbGl6ZUVTNV8iLCJtb2RpZmllZF8iLCJmaW5hbGl6ZSIsIm1heWJlRnJlZXplIiwiZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfIiwicm9vdFNjb3BlIiwiY2hpbGRWYWx1ZSIsImZpbmFsaXplUHJvcGVydHkiLCJzY29wZV8iLCJmaW5hbGl6ZWRfIiwiZHJhZnRfIiwicmVzdWx0RWFjaCIsImdlbmVyYXRlUGF0Y2hlc18iLCJwYXJlbnRTdGF0ZSIsInRhcmdldE9iamVjdCIsInJvb3RQYXRoIiwidGFyZ2V0SXNTZXQiLCJhc3NpZ25lZF8iLCJhdXRvRnJlZXplXyIsImNyZWF0ZVByb3h5UHJveHkiLCJwYXJlbnQiLCJpc01hbnVhbF8iLCJ0cmFwcyIsIm9iamVjdFRyYXBzIiwiYXJyYXlUcmFwcyIsInJldm9rZSIsIl9Qcm94eSRyZXZvY2FibGUiLCJwcm94eSIsInNvdXJjZSIsInJlYWRQcm9wRnJvbVByb3RvIiwicGVlayIsInByZXBhcmVDb3B5IiwiY3JlYXRlUHJveHkiLCJnZXREZXNjcmlwdG9yRnJvbVByb3RvIiwiY3VycmVudCIsImN1cnJlbnRTdGF0ZSIsIm1hcmtDaGFuZ2VkIiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxldGVQcm9wZXJ0eSIsIm93bmVyIiwiZGVmaW5lUHJvcGVydHkiLCJzZXRQcm90b3R5cGVPZiIsImZuIiwicGFyc2VJbnQiLCJfZGVzYyRnZXQiLCJJbW1lciIsImNvbmZpZyIsInByb2R1Y2UiLCJyZWNpcGUiLCJkZWZhdWx0QmFzZSIsInNlbGYiLCJfdGhpcyIsImN1cnJpZWRQcm9kdWNlIiwiX3JlY2lwZSIsIl90aGlzMiIsImhhc0Vycm9yIiwiUHJvbWlzZSIsInRoZW4iLCJwIiwiaXAiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJfbGVuMiIsIl9rZXkyIiwicGF0Y2hlcyIsImludmVyc2VQYXRjaGVzIiwibmV4dFN0YXRlIiwidXNlUHJveGllcyIsInNldFVzZVByb3hpZXMiLCJhdXRvRnJlZXplIiwic2V0QXV0b0ZyZWV6ZSIsIl9wcm90byIsImNyZWF0ZURyYWZ0IiwiZmluaXNoRHJhZnQiLCJhcHBseVBhdGNoZXMiLCJwYXRjaCIsImFwcGx5UGF0Y2hlc0ltcGwiLCJhcHBseVBhdGNoZXNfIiwicHJveHlNYXBfIiwicHJveHlTZXRfIiwiY3JlYXRlRVM1UHJveHlfIiwicHVzaCIsImN1cnJlbnRJbXBsIiwiY29weSIsImFyY2hUeXBlIiwiaGFzQ2hhbmdlc18iLCJjb3B5SGVscGVyIiwiZnJvbSIsImVuYWJsZUVTNSIsIm1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkiLCJtYXJrQ2hhbmdlc1N3ZWVwIiwiY3JlYXRlRVM1RHJhZnQiLCJwcm94eVByb3BlcnR5IiwiX2Rlc2NyaXB0b3JzIiwiX2kiLCJhc3NlcnRVbnJldm9rZWQiLCJkcmFmdHMiLCJoYXNBcnJheUNoYW5nZXMiLCJoYXNPYmplY3RDaGFuZ2VzIiwib2JqZWN0IiwiX2kyIiwibWluIiwiTWF0aCIsIl9pMyIsImJhc2VWYWx1ZSIsIl9zdGF0ZSIsImJhc2VJc0RyYWZ0IiwiZGVzY3JpcHRvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbmFibGVQYXRjaGVzIiwiUkVQTEFDRSIsIkFERCIsIlJFTU9WRSIsImJhc2VQYXRoIiwiZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkIiwiZ2VuZXJhdGVBcnJheVBhdGNoZXMiLCJnZW5lcmF0ZVNldFBhdGNoZXMiLCJfcmVmMiIsImNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkIiwiX3BhdGgiLCJhc3NpZ25lZFZhbHVlIiwib3JpZ1ZhbHVlIiwidW5zaGlmdCIsInJlcGxhY2VtZW50IiwicGFyZW50VHlwZSIsImpvaW4iLCJ0eXBlIiwiZGVlcENsb25lUGF0Y2hWYWx1ZSIsInNwbGljZSIsIm1hcCIsImVudHJpZXMiLCJfcmVmMyIsImsiLCJ2IiwiY2xvbmVkIiwiZW5hYmxlTWFwU2V0IiwiX2V4dGVuZFN0YXRpY3MiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJfX3Byb3RvX18iLCJfX2V4dGVuZHMiLCJfXyIsIkRyYWZ0TWFwIiwiX3N1cGVyIiwic2l6ZSIsInByZXBhcmVNYXBDb3B5IiwiY2IiLCJ0aGlzQXJnIiwiX3ZhbHVlIiwiX21hcCIsInZhbHVlcyIsIm5leHQiLCJyIiwiZG9uZSIsIl90aGlzMyIsIkRyYWZ0U2V0IiwicHJlcGFyZVNldENvcHkiLCJlbmFibGVBbGxQbHVnaW5zIiwiYmluZCIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiXSwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvZW52LnRzIiwiLi4vc3JjL3V0aWxzL2Vycm9ycy50cyIsIi4uL3NyYy91dGlscy9jb21tb24udHMiLCIuLi9zcmMvdXRpbHMvcGx1Z2lucy50cyIsIi4uL3NyYy9jb3JlL3Njb3BlLnRzIiwiLi4vc3JjL2NvcmUvZmluYWxpemUudHMiLCIuLi9zcmMvY29yZS9wcm94eS50cyIsIi4uL3NyYy9jb3JlL2ltbWVyQ2xhc3MudHMiLCIuLi9zcmMvY29yZS9jdXJyZW50LnRzIiwiLi4vc3JjL3BsdWdpbnMvZXM1LnRzIiwiLi4vc3JjL3BsdWdpbnMvcGF0Y2hlcy50cyIsIi4uL3NyYy9wbHVnaW5zL21hcHNldC50cyIsIi4uL3NyYy9wbHVnaW5zL2FsbC50cyIsIi4uL3NyYy9pbW1lci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaG91bGQgYmUgbm8gaW1wb3J0cyBoZXJlIVxuXG4vLyBTb21lIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBldmFsdWF0ZWQgYmVmb3JlIGFsbCBlbHNlLi4uXG5cbi8vIFdlIG9ubHkgd2FudCB0byBrbm93IGlmIG5vbi1wb2x5ZmlsbGVkIHN5bWJvbHMgYXJlIGF2YWlsYWJsZVxuY29uc3QgaGFzU3ltYm9sID1cblx0dHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgU3ltYm9sKFwieFwiKSA9PT0gXCJzeW1ib2xcIlxuZXhwb3J0IGNvbnN0IGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCJcbmV4cG9ydCBjb25zdCBoYXNTZXQgPSB0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiXG5leHBvcnQgY29uc3QgaGFzUHJveGllcyA9XG5cdHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHR0eXBlb2YgUHJveHkucmV2b2NhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiXG5cbi8qKlxuICogVGhlIHNlbnRpbmVsIHZhbHVlIHJldHVybmVkIGJ5IHByb2R1Y2VycyB0byByZXBsYWNlIHRoZSBkcmFmdCB3aXRoIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5PVEhJTkc6IE5vdGhpbmcgPSBoYXNTeW1ib2xcblx0PyBTeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKVxuXHQ6ICh7W1wiaW1tZXItbm90aGluZ1wiXTogdHJ1ZX0gYXMgYW55KVxuXG4vKipcbiAqIFRvIGxldCBJbW1lciB0cmVhdCB5b3VyIGNsYXNzIGluc3RhbmNlcyBhcyBwbGFpbiBpbW11dGFibGUgb2JqZWN0c1xuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcbiAqIG9yIGEgc3RhdGljIHByb3BlcnR5IG9uIGVhY2ggb2YgeW91ciBjdXN0b20gY2xhc3Nlcy5cbiAqXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxuICogc2FmZSB0byBtdXRhdGUgaW4gYSBwcm9kdWNlIGNhbGxiYWNrLlxuICovXG5leHBvcnQgY29uc3QgRFJBRlRBQkxFOiB1bmlxdWUgc3ltYm9sID0gaGFzU3ltYm9sXG5cdD8gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKVxuXHQ6IChcIl9fJGltbWVyX2RyYWZ0YWJsZVwiIGFzIGFueSlcblxuZXhwb3J0IGNvbnN0IERSQUZUX1NUQVRFOiB1bmlxdWUgc3ltYm9sID0gaGFzU3ltYm9sXG5cdD8gU3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpXG5cdDogKFwiX18kaW1tZXJfc3RhdGVcIiBhcyBhbnkpXG5cbi8vIEV2ZW4gYSBwb2x5ZmlsbGVkIFN5bWJvbCBtaWdodCBwcm92aWRlIFN5bWJvbC5pdGVyYXRvclxuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yU3ltYm9sOiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHx8IChcIkBAaXRlcmF0b3JcIiBhcyBhbnkpXG5cbi8qKiBVc2UgYSBjbGFzcyB0eXBlIGZvciBgbm90aGluZ2Agc28gaXRzIHR5cGUgaXMgdW5pcXVlICovXG5leHBvcnQgY2xhc3MgTm90aGluZyB7XG5cdC8vIFRoaXMgbGV0cyB1cyBkbyBgRXhjbHVkZTxULCBOb3RoaW5nPmBcblx0Ly8gQHRzLWlnbm9yZVxuXHRwcml2YXRlIF8hOiB1bmlxdWUgc3ltYm9sXG59XG4iLCJjb25zdCBlcnJvcnMgPSB7XG5cdDA6IFwiSWxsZWdhbCBzdGF0ZVwiLFxuXHQxOiBcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIsXG5cdDI6IFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcblx0MyhkYXRhOiBhbnkpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0XCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICtcblx0XHRcdGRhdGFcblx0XHQpXG5cdH0sXG5cdDQ6IFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcblx0NTogXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcblx0NjogXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcblx0NzogXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcblx0ODogXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG5cdDk6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuXHQxMDogXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIixcblx0MTE6IFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0MTI6IFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0MTM6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG5cdDE0OiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcblx0MTUocGF0aDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoXG5cdH0sXG5cdDE2OiAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG5cdDE3KG9wOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3Bcblx0fSxcblx0MTgocGx1Z2luOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3BsdWdpbn0nIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBcXGBlbmFibGUke3BsdWdpbn0oKVxcYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLmBcblx0fSxcblx0MjA6IFwiQ2Fubm90IHVzZSBwcm94aWVzIGlmIFByb3h5LCBQcm94eS5yZXZvY2FibGUgb3IgUmVmbGVjdCBhcmUgbm90IGF2YWlsYWJsZVwiLFxuXHQyMSh0aGluZzogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgXG5cdH0sXG5cdDIyKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYCdjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gXG5cdH0sXG5cdDIzKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YFxuXHR9LFxuXHQyNDogXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbn0gYXMgY29uc3RcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZShlcnJvcjoga2V5b2YgdHlwZW9mIGVycm9ycywgLi4uYXJnczogYW55W10pOiBuZXZlciB7XG5cdGlmIChfX0RFVl9fKSB7XG5cdFx0Y29uc3QgZSA9IGVycm9yc1tlcnJvcl1cblx0XHRjb25zdCBtc2cgPSAhZVxuXHRcdFx0PyBcInVua25vd24gZXJyb3IgbnI6IFwiICsgZXJyb3Jcblx0XHRcdDogdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIlxuXHRcdFx0PyBlLmFwcGx5KG51bGwsIGFyZ3MgYXMgYW55KVxuXHRcdFx0OiBlXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7bXNnfWApXG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdGBbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiAke2Vycm9yfSR7XG5cdFx0XHRhcmdzLmxlbmd0aCA/IFwiIFwiICsgYXJncy5tYXAocyA9PiBgJyR7c30nYCkuam9pbihcIixcIikgOiBcIlwiXG5cdFx0fS4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcblx0KVxufVxuIiwiaW1wb3J0IHtcblx0RFJBRlRfU1RBVEUsXG5cdERSQUZUQUJMRSxcblx0aGFzU2V0LFxuXHRPYmplY3Rpc2gsXG5cdERyYWZ0ZWQsXG5cdEFueU9iamVjdCxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdEltbWVyU3RhdGUsXG5cdGhhc01hcCxcblx0QXJjaHR5cGUsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJbW1lciBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXVxufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgZHJhZnRlZCBieSBJbW1lciAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0aWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiAoXG5cdFx0aXNQbGFpbk9iamVjdCh2YWx1ZSkgfHxcblx0XHRBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuXHRcdCEhdmFsdWVbRFJBRlRBQkxFXSB8fFxuXHRcdCEhdmFsdWUuY29uc3RydWN0b3I/LltEUkFGVEFCTEVdIHx8XG5cdFx0aXNNYXAodmFsdWUpIHx8XG5cdFx0aXNTZXQodmFsdWUpXG5cdClcbn1cblxuY29uc3Qgb2JqZWN0Q3RvclN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlXG5cdGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuXHRpZiAocHJvdG8gPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdHJ1ZVxuXHR9XG5cdGNvbnN0IEN0b3IgPVxuXHRcdE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yXG5cblx0aWYgKEN0b3IgPT09IE9iamVjdCkgcmV0dXJuIHRydWVcblxuXHRyZXR1cm4gKFxuXHRcdHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmdcblx0KVxufVxuXG4vKiogR2V0IHRoZSB1bmRlcmx5aW5nIG9iamVjdCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWdpbmFsPFQ+KHZhbHVlOiBUKTogVCB8IHVuZGVmaW5lZFxuZXhwb3J0IGZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlOiBEcmFmdGVkPGFueT4pOiBhbnkge1xuXHRpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjMsIHZhbHVlKVxuXHRyZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBjb25zdCBvd25LZXlzOiAodGFyZ2V0OiBBbnlPYmplY3QpID0+IFByb3BlcnR5S2V5W10gPVxuXHR0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXNcblx0XHQ/IFJlZmxlY3Qub3duS2V5c1xuXHRcdDogdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCJcblx0XHQ/IG9iaiA9PlxuXHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChcblx0XHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikgYXMgYW55XG5cdFx0XHRcdClcblx0XHQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG5cbmV4cG9ydCBjb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID1cblx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcblx0ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQ6IGFueSkge1xuXHRcdC8vIFBvbHlmaWxsIG5lZWRlZCBmb3IgSGVybWVzIGFuZCBJRSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9oZXJtZXMvaXNzdWVzLzI3NFxuXHRcdGNvbnN0IHJlczogYW55ID0ge31cblx0XHRvd25LZXlzKHRhcmdldCkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0cmVzW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRvYmo6IFQsXG5cdGl0ZXI6IChrZXk6IHN0cmluZyB8IG51bWJlciwgdmFsdWU6IGFueSwgc291cmNlOiBUKSA9PiB2b2lkLFxuXHRlbnVtZXJhYmxlT25seT86IGJvb2xlYW5cbik6IHZvaWRcbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG9iajogYW55LCBpdGVyOiBhbnksIGVudW1lcmFibGVPbmx5ID0gZmFsc2UpIHtcblx0aWYgKGdldEFyY2h0eXBlKG9iaikgPT09IEFyY2h0eXBlLk9iamVjdCkge1xuXHRcdDsoZW51bWVyYWJsZU9ubHkgPyBPYmplY3Qua2V5cyA6IG93bktleXMpKG9iaikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0aWYgKCFlbnVtZXJhYmxlT25seSB8fCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiKSBpdGVyKGtleSwgb2JqW2tleV0sIG9iailcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdG9iai5mb3JFYWNoKChlbnRyeTogYW55LCBpbmRleDogYW55KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSlcblx0fVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmc6IGFueSk6IEFyY2h0eXBlIHtcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0Y29uc3Qgc3RhdGU6IHVuZGVmaW5lZCB8IEltbWVyU3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV1cblx0cmV0dXJuIHN0YXRlXG5cdFx0PyBzdGF0ZS50eXBlXyA+IDNcblx0XHRcdD8gc3RhdGUudHlwZV8gLSA0IC8vIGNhdXNlIE9iamVjdCBhbmQgQXJyYXkgbWFwIGJhY2sgZnJvbSA0IGFuZCA1XG5cdFx0XHQ6IChzdGF0ZS50eXBlXyBhcyBhbnkpIC8vIG90aGVycyBhcmUgdGhlIHNhbWVcblx0XHQ6IEFycmF5LmlzQXJyYXkodGhpbmcpXG5cdFx0PyBBcmNodHlwZS5BcnJheVxuXHRcdDogaXNNYXAodGhpbmcpXG5cdFx0PyBBcmNodHlwZS5NYXBcblx0XHQ6IGlzU2V0KHRoaW5nKVxuXHRcdD8gQXJjaHR5cGUuU2V0XG5cdFx0OiBBcmNodHlwZS5PYmplY3Rcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGhhcyh0aGluZzogYW55LCBwcm9wOiBQcm9wZXJ0eUtleSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZS5NYXBcblx0XHQ/IHRoaW5nLmhhcyhwcm9wKVxuXHRcdDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaW5nLCBwcm9wKVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHRoaW5nOiBBbnlNYXAgfCBBbnlPYmplY3QsIHByb3A6IFByb3BlcnR5S2V5KTogYW55IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZS5NYXAgPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRoaW5nOiBhbnksIHByb3BPck9sZFZhbHVlOiBQcm9wZXJ0eUtleSwgdmFsdWU6IGFueSkge1xuXHRjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpXG5cdGlmICh0ID09PSBBcmNodHlwZS5NYXApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpXG5cdGVsc2UgaWYgKHQgPT09IEFyY2h0eXBlLlNldCkge1xuXHRcdHRoaW5nLmFkZCh2YWx1ZSlcblx0fSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4OiBhbnksIHk6IGFueSk6IGJvb2xlYW4ge1xuXHQvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcblx0aWYgKHggPT09IHkpIHtcblx0XHRyZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHlcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5XG5cdH1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWFwKHRhcmdldDogYW55KTogdGFyZ2V0IGlzIEFueU1hcCB7XG5cdHJldHVybiBoYXNNYXAgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWFwXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NldCh0YXJnZXQ6IGFueSk6IHRhcmdldCBpcyBBbnlTZXQge1xuXHRyZXR1cm4gaGFzU2V0ICYmIHRhcmdldCBpbnN0YW5jZW9mIFNldFxufVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGxhdGVzdChzdGF0ZTogSW1tZXJTdGF0ZSk6IGFueSB7XG5cdHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlX1xufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZTogYW55KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSlcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpXG5cdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdGxldCBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycylcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5OiBhbnkgPSBrZXlzW2ldXG5cdFx0Y29uc3QgZGVzYyA9IGRlc2NyaXB0b3JzW2tleV1cblx0XHRpZiAoZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcblx0XHRcdGRlc2Mud3JpdGFibGUgPSB0cnVlXG5cdFx0XHRkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWVcblx0XHR9XG5cdFx0Ly8gbGlrZSBvYmplY3QuYXNzaWduLCB3ZSB3aWxsIHJlYWQgYW55IF9vd25fLCBnZXQvc2V0IGFjY2Vzc29ycy4gVGhpcyBoZWxwcyBpbiBkZWFsaW5nXG5cdFx0Ly8gd2l0aCBsaWJyYXJpZXMgdGhhdCB0cmFwIHZhbHVlcywgbGlrZSBtb2J4IG9yIHZ1ZVxuXHRcdC8vIHVubGlrZSBvYmplY3QuYXNzaWduLCBub24tZW51bWVyYWJsZXMgd2lsbCBiZSBjb3BpZWQgYXMgd2VsbFxuXHRcdGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0gPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG5cdFx0XHRcdHZhbHVlOiBiYXNlW2tleV1cblx0XHRcdH1cblx0fVxuXHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKVxufVxuXG4vKipcbiAqIEZyZWV6ZXMgZHJhZnRhYmxlIG9iamVjdHMuIFJldHVybnMgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqIEJ5IGRlZmF1bHQgZnJlZXplcyBzaGFsbG93bHksIGJ1dCBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGB0cnVlYCBpdCB3aWxsIGZyZWV6ZSByZWN1cnNpdmVseS5cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gZGVlcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplPFQ+KG9iajogVCwgZGVlcD86IGJvb2xlYW4pOiBUXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplPFQ+KG9iajogYW55LCBkZWVwOiBib29sZWFuID0gZmFsc2UpOiBUIHtcblx0aWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqXG5cdGlmIChnZXRBcmNodHlwZShvYmopID4gMSAvKiBNYXAgb3IgU2V0ICovKSB7XG5cdFx0b2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIGFzIGFueVxuXHR9XG5cdE9iamVjdC5mcmVlemUob2JqKVxuXHRpZiAoZGVlcCkgZWFjaChvYmosIChrZXksIHZhbHVlKSA9PiBmcmVlemUodmFsdWUsIHRydWUpLCB0cnVlKVxuXHRyZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcblx0ZGllKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Zyb3plbihvYmo6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHRydWVcblx0Ly8gU2VlICM2MDAsIElFIGRpZXMgb24gbm9uLW9iamVjdHMgaW4gT2JqZWN0LmlzRnJvemVuXG5cdHJldHVybiBPYmplY3QuaXNGcm96ZW4ob2JqKVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdEltbWVyU2NvcGUsXG5cdERyYWZ0ZWQsXG5cdEFueU9iamVjdCxcblx0SW1tZXJCYXNlU3RhdGUsXG5cdEFueU1hcCxcblx0QW55U2V0LFxuXHRQcm94eVR5cGUsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUGx1Z2luIHV0aWxpdGllcyAqL1xuY29uc3QgcGx1Z2luczoge1xuXHRQYXRjaGVzPzoge1xuXHRcdGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0XHRzdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHQpOiB2b2lkXG5cdFx0Z2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0YmFzZTogYW55LFxuXHRcdFx0cmVwbGFjZW1lbnQ6IGFueSxcblx0XHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdCk6IHZvaWRcblx0XHRhcHBseVBhdGNoZXNfPFQ+KGRyYWZ0OiBULCBwYXRjaGVzOiBQYXRjaFtdKTogVFxuXHR9XG5cdEVTNT86IHtcblx0XHR3aWxsRmluYWxpemVFUzVfKHNjb3BlOiBJbW1lclNjb3BlLCByZXN1bHQ6IGFueSwgaXNSZXBsYWNlZDogYm9vbGVhbik6IHZvaWRcblx0XHRjcmVhdGVFUzVQcm94eV88VD4oXG5cdFx0XHRiYXNlOiBULFxuXHRcdFx0cGFyZW50PzogSW1tZXJTdGF0ZVxuXHRcdCk6IERyYWZ0ZWQ8VCwgRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlPlxuXHRcdGhhc0NoYW5nZXNfKHN0YXRlOiBFUzVBcnJheVN0YXRlIHwgRVM1T2JqZWN0U3RhdGUpOiBib29sZWFuXG5cdH1cblx0TWFwU2V0Pzoge1xuXHRcdHByb3h5TWFwXzxUIGV4dGVuZHMgQW55TWFwPih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUXG5cdFx0cHJveHlTZXRfPFQgZXh0ZW5kcyBBbnlTZXQ+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFRcblx0fVxufSA9IHt9XG5cbnR5cGUgUGx1Z2lucyA9IHR5cGVvZiBwbHVnaW5zXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbHVnaW48SyBleHRlbmRzIGtleW9mIFBsdWdpbnM+KFxuXHRwbHVnaW5LZXk6IEtcbik6IEV4Y2x1ZGU8UGx1Z2luc1tLXSwgdW5kZWZpbmVkPiB7XG5cdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XVxuXHRpZiAoIXBsdWdpbikge1xuXHRcdGRpZSgxOCwgcGx1Z2luS2V5KVxuXHR9XG5cdC8vIEB0cy1pZ25vcmVcblx0cmV0dXJuIHBsdWdpblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFBsdWdpbjxLIGV4dGVuZHMga2V5b2YgUGx1Z2lucz4oXG5cdHBsdWdpbktleTogSyxcblx0aW1wbGVtZW50YXRpb246IFBsdWdpbnNbS11cbik6IHZvaWQge1xuXHRpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSkgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb25cbn1cblxuLyoqIEVTNSBQbHVnaW4gKi9cblxuaW50ZXJmYWNlIEVTNUJhc2VTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0YXNzaWduZWRfOiB7W2tleTogc3RyaW5nXTogYW55fVxuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRyZXZva2VkXzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVTNU9iamVjdFN0YXRlIGV4dGVuZHMgRVM1QmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5FUzVPYmplY3Rcblx0ZHJhZnRfOiBEcmFmdGVkPEFueU9iamVjdCwgRVM1T2JqZWN0U3RhdGU+XG5cdGJhc2VfOiBBbnlPYmplY3Rcblx0Y29weV86IEFueU9iamVjdCB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFUzVBcnJheVN0YXRlIGV4dGVuZHMgRVM1QmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5FUzVBcnJheVxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBFUzVBcnJheVN0YXRlPlxuXHRiYXNlXzogYW55XG5cdGNvcHlfOiBhbnlcbn1cblxuLyoqIE1hcCAvIFNldCBwbHVnaW4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBNYXBTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5NYXBcblx0Y29weV86IEFueU1hcCB8IHVuZGVmaW5lZFxuXHRhc3NpZ25lZF86IE1hcDxhbnksIGJvb2xlYW4+IHwgdW5kZWZpbmVkXG5cdGJhc2VfOiBBbnlNYXBcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueU1hcCwgTWFwU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0U3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdHR5cGVfOiBQcm94eVR5cGUuU2V0XG5cdGNvcHlfOiBBbnlTZXQgfCB1bmRlZmluZWRcblx0YmFzZV86IEFueVNldFxuXHRkcmFmdHNfOiBNYXA8YW55LCBEcmFmdGVkPiAvLyBtYXBzIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byB0aGUgZHJhZnQgdmFsdWUgaW4gdGhlIG5ldyBzZXRcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueVNldCwgU2V0U3RhdGU+XG59XG5cbi8qKiBQYXRjaGVzIHBsdWdpbiAqL1xuXG5leHBvcnQgdHlwZSBQYXRjaFBhdGggPSAoc3RyaW5nIHwgbnVtYmVyKVtdXG4iLCJpbXBvcnQge1xuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0RHJhZnRlZCxcblx0SW1tZXIsXG5cdERSQUZUX1NUQVRFLFxuXHRJbW1lclN0YXRlLFxuXHRQcm94eVR5cGUsXG5cdGdldFBsdWdpblxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuaW1wb3J0IHtkaWV9IGZyb20gXCIuLi91dGlscy9lcnJvcnNcIlxuXG4vKiogRWFjaCBzY29wZSByZXByZXNlbnRzIGEgYHByb2R1Y2VgIGNhbGwuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1tZXJTY29wZSB7XG5cdHBhdGNoZXNfPzogUGF0Y2hbXVxuXHRpbnZlcnNlUGF0Y2hlc18/OiBQYXRjaFtdXG5cdGNhbkF1dG9GcmVlemVfOiBib29sZWFuXG5cdGRyYWZ0c186IGFueVtdXG5cdHBhcmVudF8/OiBJbW1lclNjb3BlXG5cdHBhdGNoTGlzdGVuZXJfPzogUGF0Y2hMaXN0ZW5lclxuXHRpbW1lcl86IEltbWVyXG5cdHVuZmluYWxpemVkRHJhZnRzXzogbnVtYmVyXG59XG5cbmxldCBjdXJyZW50U2NvcGU6IEltbWVyU2NvcGUgfCB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcblx0aWYgKF9fREVWX18gJiYgIWN1cnJlbnRTY29wZSkgZGllKDApXG5cdHJldHVybiBjdXJyZW50U2NvcGUhXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKFxuXHRwYXJlbnRfOiBJbW1lclNjb3BlIHwgdW5kZWZpbmVkLFxuXHRpbW1lcl86IEltbWVyXG4pOiBJbW1lclNjb3BlIHtcblx0cmV0dXJuIHtcblx0XHRkcmFmdHNfOiBbXSxcblx0XHRwYXJlbnRfLFxuXHRcdGltbWVyXyxcblx0XHQvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG5cdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cblx0XHRjYW5BdXRvRnJlZXplXzogdHJ1ZSxcblx0XHR1bmZpbmFsaXplZERyYWZ0c186IDBcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGF0Y2hlc0luU2NvcGUoXG5cdHNjb3BlOiBJbW1lclNjb3BlLFxuXHRwYXRjaExpc3RlbmVyPzogUGF0Y2hMaXN0ZW5lclxuKSB7XG5cdGlmIChwYXRjaExpc3RlbmVyKSB7XG5cdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKSAvLyBhc3NlcnQgd2UgaGF2ZSB0aGUgcGx1Z2luXG5cdFx0c2NvcGUucGF0Y2hlc18gPSBbXVxuXHRcdHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdXG5cdFx0c2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlOiBJbW1lclNjb3BlKSB7XG5cdGxlYXZlU2NvcGUoc2NvcGUpXG5cdHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdClcblx0Ly8gQHRzLWlnbm9yZVxuXHRzY29wZS5kcmFmdHNfID0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZTogSW1tZXJTY29wZSkge1xuXHRpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuXHRcdGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF9cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJTY29wZShpbW1lcjogSW1tZXIpIHtcblx0cmV0dXJuIChjdXJyZW50U2NvcGUgPSBjcmVhdGVTY29wZShjdXJyZW50U2NvcGUsIGltbWVyKSlcbn1cblxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQ6IERyYWZ0ZWQpIHtcblx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV1cblx0aWYgKFxuXHRcdHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGUuUHJveHlPYmplY3QgfHxcblx0XHRzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlLlByb3h5QXJyYXlcblx0KVxuXHRcdHN0YXRlLnJldm9rZV8oKVxuXHRlbHNlIHN0YXRlLnJldm9rZWRfID0gdHJ1ZVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTY29wZSxcblx0RFJBRlRfU1RBVEUsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HLFxuXHRQYXRjaFBhdGgsXG5cdGVhY2gsXG5cdGhhcyxcblx0ZnJlZXplLFxuXHRJbW1lclN0YXRlLFxuXHRpc0RyYWZ0LFxuXHRTZXRTdGF0ZSxcblx0c2V0LFxuXHRQcm94eVR5cGUsXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRyZXZva2VTY29wZSxcblx0aXNGcm96ZW4sXG5cdHNoYWxsb3dDb3B5XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdDogYW55LCBzY29wZTogSW1tZXJTY29wZSkge1xuXHRzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aFxuXHRjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfIVswXVxuXHRjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnRcblx0aWYgKCFzY29wZS5pbW1lcl8udXNlUHJveGllc18pXG5cdFx0Z2V0UGx1Z2luKFwiRVM1XCIpLndpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZClcblx0aWYgKGlzUmVwbGFjZWQpIHtcblx0XHRpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcblx0XHRcdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRcdFx0ZGllKDQpXG5cdFx0fVxuXHRcdGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG5cdFx0XHQvLyBGaW5hbGl6ZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgY29udGFpbnMgKG9yIGlzKSBhIHN1YnNldCBvZiB0aGUgZHJhZnQuXG5cdFx0XHRyZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KVxuXHRcdFx0aWYgKCFzY29wZS5wYXJlbnRfKSBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KVxuXHRcdH1cblx0XHRpZiAoc2NvcGUucGF0Y2hlc18pIHtcblx0XHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0XHRiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VfLFxuXHRcdFx0XHRyZXN1bHQsXG5cdFx0XHRcdHNjb3BlLnBhdGNoZXNfLFxuXHRcdFx0XHRzY29wZS5pbnZlcnNlUGF0Y2hlc18hXG5cdFx0XHQpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIEZpbmFsaXplIHRoZSBiYXNlIGRyYWZ0LlxuXHRcdHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCBiYXNlRHJhZnQsIFtdKVxuXHR9XG5cdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRpZiAoc2NvcGUucGF0Y2hlc18pIHtcblx0XHRzY29wZS5wYXRjaExpc3RlbmVyXyEoc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyEpXG5cdH1cblx0cmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGU6IEltbWVyU2NvcGUsIHZhbHVlOiBhbnksIHBhdGg/OiBQYXRjaFBhdGgpIHtcblx0Ly8gRG9uJ3QgcmVjdXJzZSBpbiB0aG8gcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlc1xuXHRpZiAoaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gdmFsdWVcblxuXHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXVxuXHQvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcblx0aWYgKCFzdGF0ZSkge1xuXHRcdGVhY2goXG5cdFx0XHR2YWx1ZSxcblx0XHRcdChrZXksIGNoaWxkVmFsdWUpID0+XG5cdFx0XHRcdGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCksXG5cdFx0XHR0cnVlIC8vIFNlZSAjNTkwLCBkb24ndCByZWN1cnNlIGludG8gbm9uLWVudW1lcmFibGUgb2Ygbm9uIGRyYWZ0ZWQgb2JqZWN0c1xuXHRcdClcblx0XHRyZXR1cm4gdmFsdWVcblx0fVxuXHQvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblx0aWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKSByZXR1cm4gdmFsdWVcblx0Ly8gVW5tb2RpZmllZCBkcmFmdCwgcmV0dXJuIHRoZSAoZnJvemVuKSBvcmlnaW5hbFxuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgc3RhdGUuYmFzZV8sIHRydWUpXG5cdFx0cmV0dXJuIHN0YXRlLmJhc2VfXG5cdH1cblx0Ly8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cdGlmICghc3RhdGUuZmluYWxpemVkXykge1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlXG5cdFx0c3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tXG5cdFx0Y29uc3QgcmVzdWx0ID1cblx0XHRcdC8vIEZvciBFUzUsIGNyZWF0ZSBhIGdvb2QgY29weSBmcm9tIHRoZSBkcmFmdCBmaXJzdCwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cblx0XHRcdHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGUuRVM1T2JqZWN0IHx8IHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGUuRVM1QXJyYXlcblx0XHRcdFx0PyAoc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5kcmFmdF8pKVxuXHRcdFx0XHQ6IHN0YXRlLmNvcHlfXG5cdFx0Ly8gRmluYWxpemUgYWxsIGNoaWxkcmVuIG9mIHRoZSBjb3B5XG5cdFx0Ly8gRm9yIHNldHMgd2UgY2xvbmUgYmVmb3JlIGl0ZXJhdGluZywgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW4gZW5kbGVzcyBsb29wIGR1ZSB0byBtb2RpZnlpbmcgZHVyaW5nIGl0ZXJhdGlvbiwgc2VlICM2Mjhcblx0XHQvLyBUbyBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgaW4gYWxsIGNhc2VzIHdlIHRoZW4gY2xlYXIgdGhlIHNldFxuXHRcdC8vIEFuZCB3ZSBsZXQgZmluYWxpemVQcm9wZXJ0eSBrbm93IGl0IG5lZWRzIHRvIHJlLWFkZCBub24tZHJhZnQgY2hpbGRyZW4gYmFjayB0byB0aGUgdGFyZ2V0XG5cdFx0bGV0IHJlc3VsdEVhY2ggPSByZXN1bHRcblx0XHRsZXQgaXNTZXQgPSBmYWxzZVxuXHRcdGlmIChzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlLlNldCkge1xuXHRcdFx0cmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KVxuXHRcdFx0cmVzdWx0LmNsZWFyKClcblx0XHRcdGlzU2V0ID0gdHJ1ZVxuXHRcdH1cblx0XHRlYWNoKHJlc3VsdEVhY2gsIChrZXksIGNoaWxkVmFsdWUpID0+XG5cdFx0XHRmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldClcblx0XHQpXG5cdFx0Ly8gZXZlcnl0aGluZyBpbnNpZGUgaXMgZnJvemVuLCB3ZSBjYW4gZnJlZXplIGhlcmVcblx0XHRtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpXG5cdFx0Ly8gZmlyc3QgdGltZSBmaW5hbGl6aW5nLCBsZXQncyBjcmVhdGUgdGhvc2UgcGF0Y2hlc1xuXHRcdGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuXHRcdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuXHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0cm9vdFNjb3BlLnBhdGNoZXNfLFxuXHRcdFx0XHRyb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfIVxuXHRcdFx0KVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RhdGUuY29weV9cbn1cblxuZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0eShcblx0cm9vdFNjb3BlOiBJbW1lclNjb3BlLFxuXHRwYXJlbnRTdGF0ZTogdW5kZWZpbmVkIHwgSW1tZXJTdGF0ZSxcblx0dGFyZ2V0T2JqZWN0OiBhbnksXG5cdHByb3A6IHN0cmluZyB8IG51bWJlcixcblx0Y2hpbGRWYWx1ZTogYW55LFxuXHRyb290UGF0aD86IFBhdGNoUGF0aCxcblx0dGFyZ2V0SXNTZXQ/OiBib29sZWFuXG4pIHtcblx0aWYgKF9fREVWX18gJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KSBkaWUoNSlcblx0aWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcblx0XHRjb25zdCBwYXRoID1cblx0XHRcdHJvb3RQYXRoICYmXG5cdFx0XHRwYXJlbnRTdGF0ZSAmJlxuXHRcdFx0cGFyZW50U3RhdGUhLnR5cGVfICE9PSBQcm94eVR5cGUuU2V0ICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG5cdFx0XHQhaGFzKChwYXJlbnRTdGF0ZSBhcyBFeGNsdWRlPEltbWVyU3RhdGUsIFNldFN0YXRlPikuYXNzaWduZWRfISwgcHJvcCkgLy8gU2tpcCBkZWVwIHBhdGNoZXMgZm9yIGFzc2lnbmVkIGtleXMuXG5cdFx0XHRcdD8gcm9vdFBhdGghLmNvbmNhdChwcm9wKVxuXHRcdFx0XHQ6IHVuZGVmaW5lZFxuXHRcdC8vIERyYWZ0cyBvd25lZCBieSBgc2NvcGVgIGFyZSBmaW5hbGl6ZWQgaGVyZS5cblx0XHRjb25zdCByZXMgPSBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUsIHBhdGgpXG5cdFx0c2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKVxuXHRcdC8vIERyYWZ0cyBmcm9tIGFub3RoZXIgc2NvcGUgbXVzdCBwcmV2ZW50ZWQgdG8gYmUgZnJvemVuXG5cdFx0Ly8gaWYgd2UgZ290IGEgZHJhZnQgYmFjayBmcm9tIGZpbmFsaXplLCB3ZSdyZSBpbiBhIG5lc3RlZCBwcm9kdWNlIGFuZCBzaG91bGRuJ3QgZnJlZXplXG5cdFx0aWYgKGlzRHJhZnQocmVzKSkge1xuXHRcdFx0cm9vdFNjb3BlLmNhbkF1dG9GcmVlemVfID0gZmFsc2Vcblx0XHR9IGVsc2UgcmV0dXJuXG5cdH0gZWxzZSBpZiAodGFyZ2V0SXNTZXQpIHtcblx0XHR0YXJnZXRPYmplY3QuYWRkKGNoaWxkVmFsdWUpXG5cdH1cblx0Ly8gU2VhcmNoIG5ldyBvYmplY3RzIGZvciB1bmZpbmFsaXplZCBkcmFmdHMuIEZyb3plbiBvYmplY3RzIHNob3VsZCBuZXZlciBjb250YWluIGRyYWZ0cy5cblx0aWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuXHRcdGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuXHRcdFx0Ly8gb3B0aW1pemF0aW9uOiBpZiBhbiBvYmplY3QgaXMgbm90IGEgZHJhZnQsIGFuZCB3ZSBkb24ndCBoYXZlIHRvXG5cdFx0XHQvLyBkZWVwZnJlZXplIGV2ZXJ5dGhpbmcsIGFuZCB3ZSBhcmUgc3VyZSB0aGF0IG5vIGRyYWZ0cyBhcmUgbGVmdCBpbiB0aGUgcmVtYWluaW5nIG9iamVjdFxuXHRcdFx0Ly8gY2F1c2Ugd2Ugc2F3IGFuZCBmaW5hbGl6ZWQgYWxsIGRyYWZ0cyBhbHJlYWR5OyB3ZSBjYW4gc3RvcCB2aXNpdGluZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cblx0XHRcdC8vIFRoaXMgYmVuZWZpdHMgZXNwZWNpYWxseSBhZGRpbmcgbGFyZ2UgZGF0YSB0cmVlJ3Mgd2l0aG91dCBmdXJ0aGVyIHByb2Nlc3NpbmcuXG5cdFx0XHQvLyBTZWUgYWRkLWRhdGEuanMgcGVyZiB0ZXN0XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0ZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKVxuXHRcdC8vIGltbWVyIGRlZXAgZnJlZXplcyBwbGFpbiBvYmplY3RzLCBzbyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgc3RhdGUsIHdlIGZyZWV6ZSBhcyB3ZWxsXG5cdFx0aWYgKCFwYXJlbnRTdGF0ZSB8fCAhcGFyZW50U3RhdGUuc2NvcGVfLnBhcmVudF8pXG5cdFx0XHRtYXliZUZyZWV6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpXG5cdH1cbn1cblxuZnVuY3Rpb24gbWF5YmVGcmVlemUoc2NvcGU6IEltbWVyU2NvcGUsIHZhbHVlOiBhbnksIGRlZXAgPSBmYWxzZSkge1xuXHQvLyB3ZSBuZXZlciBmcmVlemUgZm9yIGEgbm9uLXJvb3Qgc2NvcGU7IGFzIGl0IHdvdWxkIHByZXZlbnQgcHJ1bmluZyBmb3IgZHJhZnRzIGluc2lkZSB3cmFwcGluZyBvYmplY3RzXG5cdGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcblx0XHRmcmVlemUodmFsdWUsIGRlZXApXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdGVhY2gsXG5cdGhhcyxcblx0aXMsXG5cdGlzRHJhZnRhYmxlLFxuXHRzaGFsbG93Q29weSxcblx0bGF0ZXN0LFxuXHRJbW1lckJhc2VTdGF0ZSxcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0QW55T2JqZWN0LFxuXHRBbnlBcnJheSxcblx0T2JqZWN0aXNoLFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdERSQUZUX1NUQVRFLFxuXHRkaWUsXG5cdGNyZWF0ZVByb3h5LFxuXHRQcm94eVR5cGVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuaW50ZXJmYWNlIFByb3h5QmFzZVN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHRhc3NpZ25lZF86IHtcblx0XHRbcHJvcGVydHk6IHN0cmluZ106IGJvb2xlYW5cblx0fVxuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRyZXZva2VfKCk6IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm94eU9iamVjdFN0YXRlIGV4dGVuZHMgUHJveHlCYXNlU3RhdGUge1xuXHR0eXBlXzogUHJveHlUeXBlLlByb3h5T2JqZWN0XG5cdGJhc2VfOiBhbnlcblx0Y29weV86IGFueVxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBQcm94eU9iamVjdFN0YXRlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5QXJyYXlTdGF0ZSBleHRlbmRzIFByb3h5QmFzZVN0YXRlIHtcblx0dHlwZV86IFByb3h5VHlwZS5Qcm94eUFycmF5XG5cdGJhc2VfOiBBbnlBcnJheVxuXHRjb3B5XzogQW55QXJyYXkgfCBudWxsXG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlBcnJheSwgUHJveHlBcnJheVN0YXRlPlxufVxuXG50eXBlIFByb3h5U3RhdGUgPSBQcm94eU9iamVjdFN0YXRlIHwgUHJveHlBcnJheVN0YXRlXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBkcmFmdCBvZiB0aGUgYGJhc2VgIG9iamVjdC5cbiAqXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBwYXJlbnQgZHJhZnQtc3RhdGUgKHVzZWQgaW50ZXJuYWxseSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5PFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRiYXNlOiBULFxuXHRwYXJlbnQ/OiBJbW1lclN0YXRlXG4pOiBEcmFmdGVkPFQsIFByb3h5U3RhdGU+IHtcblx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSlcblx0Y29uc3Qgc3RhdGU6IFByb3h5U3RhdGUgPSB7XG5cdFx0dHlwZV86IGlzQXJyYXkgPyBQcm94eVR5cGUuUHJveHlBcnJheSA6IChQcm94eVR5cGUuUHJveHlPYmplY3QgYXMgYW55KSxcblx0XHQvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG5cdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuXHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0Ly8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuXHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG5cdFx0YXNzaWduZWRfOiB7fSxcblx0XHQvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuXHRcdHBhcmVudF86IHBhcmVudCxcblx0XHQvLyBUaGUgYmFzZSBzdGF0ZS5cblx0XHRiYXNlXzogYmFzZSxcblx0XHQvLyBUaGUgYmFzZSBwcm94eS5cblx0XHRkcmFmdF86IG51bGwgYXMgYW55LCAvLyBzZXQgYmVsb3dcblx0XHQvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuXHRcdGNvcHlfOiBudWxsLFxuXHRcdC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuXHRcdHJldm9rZV86IG51bGwgYXMgYW55LFxuXHRcdGlzTWFudWFsXzogZmFsc2Vcblx0fVxuXG5cdC8vIHRoZSB0cmFwcyBtdXN0IHRhcmdldCBzb21ldGhpbmcsIGEgYml0IGxpa2UgdGhlICdyZWFsJyBiYXNlLlxuXHQvLyBidXQgYWxzbywgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRldGVybWluZSBmcm9tIHRoZSB0YXJnZXQgd2hhdCB0aGUgcmVsZXZhbnQgc3RhdGUgaXNcblx0Ly8gKHRvIGF2b2lkIGNyZWF0aW5nIHRyYXBzIHBlciBpbnN0YW5jZSB0byBjYXB0dXJlIHRoZSBzdGF0ZSBpbiBjbG9zdXJlLFxuXHQvLyBhbmQgdG8gYXZvaWQgY3JlYXRpbmcgd2VpcmQgaGlkZGVuIHByb3BlcnRpZXMgYXMgd2VsbClcblx0Ly8gU28gdGhlIHRyaWNrIGlzIHRvIHVzZSAnc3RhdGUnIGFzIHRoZSBhY3R1YWwgJ3RhcmdldCchIChhbmQgbWFrZSBzdXJlIHdlIGludGVyY2VwdCBldmVyeXRoaW5nKVxuXHQvLyBOb3RlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXksIHdlIHB1dCB0aGUgc3RhdGUgaW4gYW4gYXJyYXkgdG8gaGF2ZSBiZXR0ZXIgUmVmbGVjdCBkZWZhdWx0cyBvb3RiXG5cdGxldCB0YXJnZXQ6IFQgPSBzdGF0ZSBhcyBhbnlcblx0bGV0IHRyYXBzOiBQcm94eUhhbmRsZXI8b2JqZWN0IHwgQXJyYXk8YW55Pj4gPSBvYmplY3RUcmFwc1xuXHRpZiAoaXNBcnJheSkge1xuXHRcdHRhcmdldCA9IFtzdGF0ZV0gYXMgYW55XG5cdFx0dHJhcHMgPSBhcnJheVRyYXBzXG5cdH1cblxuXHRjb25zdCB7cmV2b2tlLCBwcm94eX0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcylcblx0c3RhdGUuZHJhZnRfID0gcHJveHkgYXMgYW55XG5cdHN0YXRlLnJldm9rZV8gPSByZXZva2Vcblx0cmV0dXJuIHByb3h5IGFzIGFueVxufVxuXG4vKipcbiAqIE9iamVjdCBkcmFmdHNcbiAqL1xuZXhwb3J0IGNvbnN0IG9iamVjdFRyYXBzOiBQcm94eUhhbmRsZXI8UHJveHlTdGF0ZT4gPSB7XG5cdGdldChzdGF0ZSwgcHJvcCkge1xuXHRcdGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlXG5cblx0XHRjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpXG5cdFx0aWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuXHRcdFx0Ly8gbm9uLWV4aXN0aW5nIG9yIG5vbi1vd24gcHJvcGVydHkuLi5cblx0XHRcdHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKVxuXHRcdH1cblx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXVxuXHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0XHQvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXG5cdFx0Ly8gQXNzaWduZWQgdmFsdWVzIGFyZSBuZXZlciBkcmFmdGVkLiBUaGlzIGNhdGNoZXMgYW55IGRyYWZ0cyB3ZSBjcmVhdGVkLCB0b28uXG5cdFx0aWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gKHN0YXRlLmNvcHlfIVtwcm9wIGFzIGFueV0gPSBjcmVhdGVQcm94eShcblx0XHRcdFx0c3RhdGUuc2NvcGVfLmltbWVyXyxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdHN0YXRlXG5cdFx0XHQpKVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblx0aGFzKHN0YXRlLCBwcm9wKSB7XG5cdFx0cmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKVxuXHR9LFxuXHRvd25LZXlzKHN0YXRlKSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKVxuXHR9LFxuXHRzZXQoXG5cdFx0c3RhdGU6IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0cHJvcDogc3RyaW5nIC8qIHN0cmljdGx5IG5vdCwgYnV0IGhlbHBzIFRTICovLFxuXHRcdHZhbHVlXG5cdCkge1xuXHRcdGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0aWYgKGRlc2M/LnNldCkge1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIHdyaXRlIGlzIGNhcHR1cmVkIGJ5IGEgc2V0dGVyLCB3ZSBoYXZlXG5cdFx0XHQvLyB0byB0cmlnZ2VyIGl0IHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuXHRcdFx0ZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdC8vIHRoZSBsYXN0IGNoZWNrIGlzIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIHNldHRpbmcgYSBub24tZXhpc3RpbmcgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBhIGNoYW5nZSlcblx0XHRcdC8vIGZyb20gc2V0dGluZyBhbiBleGlzdGluZyBwcm9wZXJ0eSB3aXRoIHZhbHVlIHVuZGVmaW5lZCB0byB1bmRlZmluZWQgKHdoaWNoIGlzIG5vdCBhIGNoYW5nZSlcblx0XHRcdGNvbnN0IGN1cnJlbnQgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UsIGlmIHdlIGFzc2lnbmluZyB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gYSBkcmFmdCwgd2UgY2FuIGlnbm9yZSB0aGUgYXNzaWdubWVudFxuXHRcdFx0Y29uc3QgY3VycmVudFN0YXRlOiBQcm94eU9iamVjdFN0YXRlID0gY3VycmVudD8uW0RSQUZUX1NUQVRFXVxuXHRcdFx0aWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHN0YXRlLmNvcHlfIVtwcm9wXSA9IHZhbHVlXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRpZiAoaXModmFsdWUsIGN1cnJlbnQpICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQoc3RhdGUuY29weV8hW3Byb3BdID09PSB2YWx1ZSAmJlxuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSkgfHxcblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogTmFOXG5cdFx0XHQoTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV8hW3Byb3BdKSlcblx0XHQpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHN0YXRlLmNvcHlfIVtwcm9wXSA9IHZhbHVlXG5cdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZVxuXHRcdHJldHVybiB0cnVlXG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wOiBzdHJpbmcpIHtcblx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdW5kZWZpbmVkIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcblx0XHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlXG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBhbiBvcmlnaW5hbGx5IG5vdCBhc3NpZ25lZCBwcm9wZXJ0eSB3YXMgZGVsZXRlZFxuXHRcdFx0ZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXVxuXHRcdH1cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKHN0YXRlLmNvcHlfKSBkZWxldGUgc3RhdGUuY29weV9bcHJvcF1cblx0XHRyZXR1cm4gdHJ1ZVxuXHR9LFxuXHQvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuXHQvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuXHRcdGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKVxuXHRcdGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcClcblx0XHRpZiAoIWRlc2MpIHJldHVybiBkZXNjXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gUHJveHlUeXBlLlByb3h5QXJyYXkgfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcblx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiBvd25lcltwcm9wXVxuXHRcdH1cblx0fSxcblx0ZGVmaW5lUHJvcGVydHkoKSB7XG5cdFx0ZGllKDExKVxuXHR9LFxuXHRnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuXHRcdHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pXG5cdH0sXG5cdHNldFByb3RvdHlwZU9mKCkge1xuXHRcdGRpZSgxMilcblx0fVxufVxuXG4vKipcbiAqIEFycmF5IGRyYWZ0c1xuICovXG5cbmNvbnN0IGFycmF5VHJhcHM6IFByb3h5SGFuZGxlcjxbUHJveHlBcnJheVN0YXRlXT4gPSB7fVxuZWFjaChvYmplY3RUcmFwcywgKGtleSwgZm4pID0+IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF1cblx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9XG59KVxuYXJyYXlUcmFwcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wKSB7XG5cdGlmIChfX0RFVl9fICYmIGlzTmFOKHBhcnNlSW50KHByb3AgYXMgYW55KSkpIGRpZSgxMylcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gYXJyYXlUcmFwcy5zZXQhLmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHVuZGVmaW5lZClcbn1cbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHByb3AsIHZhbHVlKSB7XG5cdGlmIChfX0RFVl9fICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCBhcyBhbnkpKSkgZGllKDE0KVxuXHRyZXR1cm4gb2JqZWN0VHJhcHMuc2V0IS5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pXG59XG5cbi8vIEFjY2VzcyBhIHByb3BlcnR5IHdpdGhvdXQgY3JlYXRpbmcgYW4gSW1tZXIgZHJhZnQuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0OiBEcmFmdGVkLCBwcm9wOiBQcm9wZXJ0eUtleSkge1xuXHRjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXVxuXHRjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdFxuXHRyZXR1cm4gc291cmNlW3Byb3BdXG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlOiBJbW1lclN0YXRlLCBzb3VyY2U6IGFueSwgcHJvcDogUHJvcGVydHlLZXkpIHtcblx0Y29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKVxuXHRyZXR1cm4gZGVzY1xuXHRcdD8gYHZhbHVlYCBpbiBkZXNjXG5cdFx0XHQ/IGRlc2MudmFsdWVcblx0XHRcdDogLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuXHRcdFx0ICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcblx0XHRcdCAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxuXHRcdDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oXG5cdHNvdXJjZTogYW55LFxuXHRwcm9wOiBQcm9wZXJ0eUtleVxuKTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcblx0Ly8gJ2luJyBjaGVja3MgcHJvdG8hXG5cdGlmICghKHByb3AgaW4gc291cmNlKSkgcmV0dXJuIHVuZGVmaW5lZFxuXHRsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKVxuXHR3aGlsZSAocHJvdG8pIHtcblx0XHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcClcblx0XHRpZiAoZGVzYykgcmV0dXJuIGRlc2Ncblx0XHRwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bylcblx0fVxuXHRyZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZTogSW1tZXJTdGF0ZSkge1xuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdHN0YXRlLm1vZGlmaWVkXyA9IHRydWVcblx0XHRpZiAoc3RhdGUucGFyZW50Xykge1xuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xylcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlOiB7YmFzZV86IGFueTsgY29weV86IGFueX0pIHtcblx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuYmFzZV8pXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdElQcm9kdWNlV2l0aFBhdGNoZXMsXG5cdElQcm9kdWNlLFxuXHRJbW1lclN0YXRlLFxuXHREcmFmdGVkLFxuXHRpc0RyYWZ0YWJsZSxcblx0cHJvY2Vzc1Jlc3VsdCxcblx0UGF0Y2gsXG5cdE9iamVjdGlzaCxcblx0RFJBRlRfU1RBVEUsXG5cdERyYWZ0LFxuXHRQYXRjaExpc3RlbmVyLFxuXHRpc0RyYWZ0LFxuXHRpc01hcCxcblx0aXNTZXQsXG5cdGNyZWF0ZVByb3h5UHJveHksXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRoYXNQcm94aWVzLFxuXHRlbnRlclNjb3BlLFxuXHRyZXZva2VTY29wZSxcblx0bGVhdmVTY29wZSxcblx0dXNlUGF0Y2hlc0luU2NvcGUsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0Tk9USElORyxcblx0ZnJlZXplLFxuXHRjdXJyZW50XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmludGVyZmFjZSBQcm9kdWNlcnNGbnMge1xuXHRwcm9kdWNlOiBJUHJvZHVjZVxuXHRwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXNcbn1cblxuZXhwb3J0IGNsYXNzIEltbWVyIGltcGxlbWVudHMgUHJvZHVjZXJzRm5zIHtcblx0dXNlUHJveGllc186IGJvb2xlYW4gPSBoYXNQcm94aWVzXG5cblx0YXV0b0ZyZWV6ZV86IGJvb2xlYW4gPSB0cnVlXG5cblx0Y29uc3RydWN0b3IoY29uZmlnPzoge3VzZVByb3hpZXM/OiBib29sZWFuOyBhdXRvRnJlZXplPzogYm9vbGVhbn0pIHtcblx0XHRpZiAodHlwZW9mIGNvbmZpZz8udXNlUHJveGllcyA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHR0aGlzLnNldFVzZVByb3hpZXMoY29uZmlnIS51c2VQcm94aWVzKVxuXHRcdGlmICh0eXBlb2YgY29uZmlnPy5hdXRvRnJlZXplID09PSBcImJvb2xlYW5cIilcblx0XHRcdHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWchLmF1dG9GcmVlemUpXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG5cdCAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xuXHQgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcblx0ICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0ICpcblx0ICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG5cdCAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG5cdCAqXG5cdCAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuXHQgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG5cdCAqXG5cdCAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG5cdCAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuXHQgKi9cblx0cHJvZHVjZTogSVByb2R1Y2UgPSAoYmFzZTogYW55LCByZWNpcGU/OiBhbnksIHBhdGNoTGlzdGVuZXI/OiBhbnkpID0+IHtcblx0XHQvLyBjdXJyaWVkIGludm9jYXRpb25cblx0XHRpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlXG5cdFx0XHRyZWNpcGUgPSBiYXNlXG5cblx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoXG5cdFx0XHRcdHRoaXM6IGFueSxcblx0XHRcdFx0YmFzZSA9IGRlZmF1bHRCYXNlLFxuXHRcdFx0XHQuLi5hcmdzOiBhbnlbXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZSwgKGRyYWZ0OiBEcmFmdGVkKSA9PiByZWNpcGUuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncykpIC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg2KVxuXHRcdGlmIChwYXRjaExpc3RlbmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcblx0XHRcdGRpZSg3KVxuXG5cdFx0bGV0IHJlc3VsdFxuXG5cdFx0Ly8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cdFx0aWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRcdGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkodGhpcywgYmFzZSwgdW5kZWZpbmVkKVxuXHRcdFx0bGV0IGhhc0Vycm9yID0gdHJ1ZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzdWx0ID0gcmVjaXBlKHByb3h5KVxuXHRcdFx0XHRoYXNFcnJvciA9IGZhbHNlXG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHQvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcblx0XHRcdFx0aWYgKGhhc0Vycm9yKSByZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0ZWxzZSBsZWF2ZVNjb3BlKHNjb3BlKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC50aGVuKFxuXHRcdFx0XHRcdHJlc3VsdCA9PiB7XG5cdFx0XHRcdFx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRyZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpXG5cdFx0fSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0cmVzdWx0ID0gcmVjaXBlKGJhc2UpXG5cdFx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGJhc2Vcblx0XHRcdGlmIChyZXN1bHQgPT09IE5PVEhJTkcpIHJlc3VsdCA9IHVuZGVmaW5lZFxuXHRcdFx0aWYgKHRoaXMuYXV0b0ZyZWV6ZV8pIGZyZWV6ZShyZXN1bHQsIHRydWUpXG5cdFx0XHRpZiAocGF0Y2hMaXN0ZW5lcikge1xuXHRcdFx0XHRjb25zdCBwOiBQYXRjaFtdID0gW11cblx0XHRcdFx0Y29uc3QgaXA6IFBhdGNoW10gPSBbXVxuXHRcdFx0XHRnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKVxuXHRcdFx0XHRwYXRjaExpc3RlbmVyKHAsIGlwKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH0gZWxzZSBkaWUoMjEsIGJhc2UpXG5cdH1cblxuXHRwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXMgPSAoYmFzZTogYW55LCByZWNpcGU/OiBhbnkpOiBhbnkgPT4ge1xuXHRcdC8vIGN1cnJpZWQgaW52b2NhdGlvblxuXHRcdGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gKHN0YXRlOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PlxuXHRcdFx0XHR0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0OiBhbnkpID0+IGJhc2UoZHJhZnQsIC4uLmFyZ3MpKVxuXHRcdH1cblxuXHRcdGxldCBwYXRjaGVzOiBQYXRjaFtdLCBpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIChwOiBQYXRjaFtdLCBpcDogUGF0Y2hbXSkgPT4ge1xuXHRcdFx0cGF0Y2hlcyA9IHBcblx0XHRcdGludmVyc2VQYXRjaGVzID0gaXBcblx0XHR9KVxuXG5cdFx0aWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdHJldHVybiByZXN1bHQudGhlbihuZXh0U3RhdGUgPT4gW25leHRTdGF0ZSwgcGF0Y2hlcyEsIGludmVyc2VQYXRjaGVzIV0pXG5cdFx0fVxuXHRcdHJldHVybiBbcmVzdWx0LCBwYXRjaGVzISwgaW52ZXJzZVBhdGNoZXMhXVxuXHR9XG5cblx0Y3JlYXRlRHJhZnQ8VCBleHRlbmRzIE9iamVjdGlzaD4oYmFzZTogVCk6IERyYWZ0PFQ+IHtcblx0XHRpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSBkaWUoOClcblx0XHRpZiAoaXNEcmFmdChiYXNlKSkgYmFzZSA9IGN1cnJlbnQoYmFzZSlcblx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KHRoaXMsIGJhc2UsIHVuZGVmaW5lZClcblx0XHRwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZVxuXHRcdGxlYXZlU2NvcGUoc2NvcGUpXG5cdFx0cmV0dXJuIHByb3h5IGFzIGFueVxuXHR9XG5cblx0ZmluaXNoRHJhZnQ8RCBleHRlbmRzIERyYWZ0PGFueT4+KFxuXHRcdGRyYWZ0OiBELFxuXHRcdHBhdGNoTGlzdGVuZXI/OiBQYXRjaExpc3RlbmVyXG5cdCk6IEQgZXh0ZW5kcyBEcmFmdDxpbmZlciBUPiA/IFQgOiBuZXZlciB7XG5cdFx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSBkcmFmdCAmJiAoZHJhZnQgYXMgYW55KVtEUkFGVF9TVEFURV1cblx0XHRpZiAoX19ERVZfXykge1xuXHRcdFx0aWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKSBkaWUoOSlcblx0XHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfKSBkaWUoMTApXG5cdFx0fVxuXHRcdGNvbnN0IHtzY29wZV86IHNjb3BlfSA9IHN0YXRlXG5cdFx0dXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpXG5cdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHQodW5kZWZpbmVkLCBzY29wZSlcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXG5cdCAqL1xuXHRzZXRBdXRvRnJlZXplKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0dGhpcy5hdXRvRnJlZXplXyA9IHZhbHVlXG5cdH1cblxuXHQvKipcblx0ICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXG5cdCAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cblx0ICpcblx0ICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXG5cdCAqL1xuXHRzZXRVc2VQcm94aWVzKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0aWYgKHZhbHVlICYmICFoYXNQcm94aWVzKSB7XG5cdFx0XHRkaWUoMjApXG5cdFx0fVxuXHRcdHRoaXMudXNlUHJveGllc18gPSB2YWx1ZVxuXHR9XG5cblx0YXBwbHlQYXRjaGVzPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KGJhc2U6IFQsIHBhdGNoZXM6IFBhdGNoW10pOiBUIHtcblx0XHQvLyBJZiBhIHBhdGNoIHJlcGxhY2VzIHRoZSBlbnRpcmUgc3RhdGUsIHRha2UgdGhhdCByZXBsYWNlbWVudCBhcyBiYXNlXG5cdFx0Ly8gYmVmb3JlIGFwcGx5aW5nIHBhdGNoZXNcblx0XHRsZXQgaTogbnVtYmVyXG5cdFx0Zm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgcGF0Y2ggPSBwYXRjaGVzW2ldXG5cdFx0XHRpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG5cdFx0XHRcdGJhc2UgPSBwYXRjaC52YWx1ZVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB0aGVyZSB3YXMgYSBwYXRjaCB0aGF0IHJlcGxhY2VkIHRoZSBlbnRpcmUgc3RhdGUsIHN0YXJ0IGZyb20gdGhlXG5cdFx0Ly8gcGF0Y2ggYWZ0ZXIgdGhhdC5cblx0XHRpZiAoaSA+IC0xKSB7XG5cdFx0XHRwYXRjaGVzID0gcGF0Y2hlcy5zbGljZShpICsgMSlcblx0XHR9XG5cblx0XHRjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfXG5cdFx0aWYgKGlzRHJhZnQoYmFzZSkpIHtcblx0XHRcdC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuXHRcdFx0cmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcylcblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCBwcm9kdWNlIGEgY29weSBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0XHRyZXR1cm4gdGhpcy5wcm9kdWNlKGJhc2UsIChkcmFmdDogRHJhZnRlZCkgPT5cblx0XHRcdGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG5cdFx0KVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eTxUIGV4dGVuZHMgT2JqZWN0aXNoPihcblx0aW1tZXI6IEltbWVyLFxuXHR2YWx1ZTogVCxcblx0cGFyZW50PzogSW1tZXJTdGF0ZVxuKTogRHJhZnRlZDxULCBJbW1lclN0YXRlPiB7XG5cdC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxuXHRjb25zdCBkcmFmdDogRHJhZnRlZCA9IGlzTWFwKHZhbHVlKVxuXHRcdD8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KVxuXHRcdDogaXNTZXQodmFsdWUpXG5cdFx0PyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpXG5cdFx0OiBpbW1lci51c2VQcm94aWVzX1xuXHRcdD8gY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KVxuXHRcdDogZ2V0UGx1Z2luKFwiRVM1XCIpLmNyZWF0ZUVTNVByb3h5Xyh2YWx1ZSwgcGFyZW50KVxuXG5cdGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpXG5cdHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdClcblx0cmV0dXJuIGRyYWZ0XG59XG4iLCJpbXBvcnQge1xuXHRkaWUsXG5cdGlzRHJhZnQsXG5cdHNoYWxsb3dDb3B5LFxuXHRlYWNoLFxuXHREUkFGVF9TVEFURSxcblx0Z2V0LFxuXHRzZXQsXG5cdEltbWVyU3RhdGUsXG5cdGlzRHJhZnRhYmxlLFxuXHRBcmNodHlwZSxcblx0Z2V0QXJjaHR5cGUsXG5cdGdldFBsdWdpblxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogVGFrZXMgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIGRyYWZ0IGFuZCBmaW5hbGl6ZXMgaXQgKGJ1dCB3aXRob3V0IGZyZWV6aW5nKS4gVGhpcyBpcyBhIGdyZWF0IHV0aWxpdHkgdG8gcHJpbnQgdGhlIGN1cnJlbnQgc3RhdGUgZHVyaW5nIGRlYnVnZ2luZyAobm8gUHJveGllcyBpbiB0aGUgd2F5KS4gVGhlIG91dHB1dCBvZiBjdXJyZW50IGNhbiBhbHNvIGJlIHNhZmVseSBsZWFrZWQgb3V0c2lkZSB0aGUgcHJvZHVjZXIuICovXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudDxUPih2YWx1ZTogVCk6IFRcbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50KHZhbHVlOiBhbnkpOiBhbnkge1xuXHRpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjIsIHZhbHVlKVxuXHRyZXR1cm4gY3VycmVudEltcGwodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlOiBhbnkpOiBhbnkge1xuXHRpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSkgcmV0dXJuIHZhbHVlXG5cdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlIHwgdW5kZWZpbmVkID0gdmFsdWVbRFJBRlRfU1RBVEVdXG5cdGxldCBjb3B5OiBhbnlcblx0Y29uc3QgYXJjaFR5cGUgPSBnZXRBcmNodHlwZSh2YWx1ZSlcblx0aWYgKHN0YXRlKSB7XG5cdFx0aWYgKFxuXHRcdFx0IXN0YXRlLm1vZGlmaWVkXyAmJlxuXHRcdFx0KHN0YXRlLnR5cGVfIDwgNCB8fCAhZ2V0UGx1Z2luKFwiRVM1XCIpLmhhc0NoYW5nZXNfKHN0YXRlIGFzIGFueSkpXG5cdFx0KVxuXHRcdFx0cmV0dXJuIHN0YXRlLmJhc2VfXG5cdFx0Ly8gT3B0aW1pemF0aW9uOiBhdm9pZCBnZW5lcmF0aW5nIG5ldyBkcmFmdHMgZHVyaW5nIGNvcHlpbmdcblx0XHRzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZVxuXHRcdGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSlcblx0XHRzdGF0ZS5maW5hbGl6ZWRfID0gZmFsc2Vcblx0fSBlbHNlIHtcblx0XHRjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpXG5cdH1cblxuXHRlYWNoKGNvcHksIChrZXksIGNoaWxkVmFsdWUpID0+IHtcblx0XHRpZiAoc3RhdGUgJiYgZ2V0KHN0YXRlLmJhc2VfLCBrZXkpID09PSBjaGlsZFZhbHVlKSByZXR1cm4gLy8gbm8gbmVlZCB0byBjb3B5IG9yIHNlYXJjaCBpbiBzb21ldGhpbmcgdGhhdCBkaWRuJ3QgY2hhbmdlXG5cdFx0c2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpXG5cdH0pXG5cdC8vIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IGNvbnNpZGVyIGZyZWV6aW5nIGhlcmUsIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNldHRpbmdzXG5cdHJldHVybiBhcmNoVHlwZSA9PT0gQXJjaHR5cGUuU2V0ID8gbmV3IFNldChjb3B5KSA6IGNvcHlcbn1cblxuZnVuY3Rpb24gY29weUhlbHBlcih2YWx1ZTogYW55LCBhcmNoVHlwZTogbnVtYmVyKTogYW55IHtcblx0Ly8gY3JlYXRlcyBhIHNoYWxsb3cgY29weSwgZXZlbiBpZiBpdCBpcyBhIG1hcCBvciBzZXRcblx0c3dpdGNoIChhcmNoVHlwZSkge1xuXHRcdGNhc2UgQXJjaHR5cGUuTWFwOlxuXHRcdFx0cmV0dXJuIG5ldyBNYXAodmFsdWUpXG5cdFx0Y2FzZSBBcmNodHlwZS5TZXQ6XG5cdFx0XHQvLyBTZXQgd2lsbCBiZSBjbG9uZWQgYXMgYXJyYXkgdGVtcG9yYXJpbHksIHNvIHRoYXQgd2UgY2FuIHJlcGxhY2UgaW5kaXZpZHVhbCBpdGVtc1xuXHRcdFx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpXG5cdH1cblx0cmV0dXJuIHNoYWxsb3dDb3B5KHZhbHVlKVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0RVM1QXJyYXlTdGF0ZSxcblx0RVM1T2JqZWN0U3RhdGUsXG5cdGVhY2gsXG5cdGhhcyxcblx0aXNEcmFmdCxcblx0bGF0ZXN0LFxuXHREUkFGVF9TVEFURSxcblx0aXMsXG5cdGxvYWRQbHVnaW4sXG5cdEltbWVyU2NvcGUsXG5cdFByb3h5VHlwZSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHRkaWUsXG5cdG1hcmtDaGFuZ2VkLFxuXHRvYmplY3RUcmFwcyxcblx0b3duS2V5cyxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc1xufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG50eXBlIEVTNVN0YXRlID0gRVM1QXJyYXlTdGF0ZSB8IEVTNU9iamVjdFN0YXRlXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVFUzUoKSB7XG5cdGZ1bmN0aW9uIHdpbGxGaW5hbGl6ZUVTNV8oXG5cdFx0c2NvcGU6IEltbWVyU2NvcGUsXG5cdFx0cmVzdWx0OiBhbnksXG5cdFx0aXNSZXBsYWNlZDogYm9vbGVhblxuXHQpIHtcblx0XHRpZiAoIWlzUmVwbGFjZWQpIHtcblx0XHRcdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdFx0XHRtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c18hWzBdKVxuXHRcdFx0fVxuXHRcdFx0Ly8gVGhpcyBpcyBmYXN0ZXIgd2hlbiB3ZSBkb24ndCBjYXJlIGFib3V0IHdoaWNoIGF0dHJpYnV0ZXMgY2hhbmdlZC5cblx0XHRcdG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzXylcblx0XHR9XG5cdFx0Ly8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0aXNEcmFmdChyZXN1bHQpICYmXG5cdFx0XHQocmVzdWx0W0RSQUZUX1NUQVRFXSBhcyBFUzVTdGF0ZSkuc2NvcGVfID09PSBzY29wZVxuXHRcdCkge1xuXHRcdFx0bWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXk6IGJvb2xlYW4sIGJhc2U6IGFueSkge1xuXHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRjb25zdCBkcmFmdCA9IG5ldyBBcnJheShiYXNlLmxlbmd0aClcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKylcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBcIlwiICsgaSwgcHJveHlQcm9wZXJ0eShpLCB0cnVlKSlcblx0XHRcdHJldHVybiBkcmFmdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSlcblx0XHRcdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdFx0XHRjb25zdCBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycylcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBrZXk6IGFueSA9IGtleXNbaV1cblx0XHRcdFx0ZGVzY3JpcHRvcnNba2V5XSA9IHByb3h5UHJvcGVydHkoXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGlzQXJyYXkgfHwgISFkZXNjcmlwdG9yc1trZXldLmVudW1lcmFibGVcblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycylcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFUzVQcm94eV88VD4oXG5cdFx0YmFzZTogVCxcblx0XHRwYXJlbnQ/OiBJbW1lclN0YXRlXG5cdCk6IERyYWZ0ZWQ8VCwgRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlPiB7XG5cdFx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSlcblx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpXG5cblx0XHRjb25zdCBzdGF0ZTogRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlID0ge1xuXHRcdFx0dHlwZV86IGlzQXJyYXkgPyBQcm94eVR5cGUuRVM1QXJyYXkgOiAoUHJveHlUeXBlLkVTNU9iamVjdCBhcyBhbnkpLFxuXHRcdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG5cdFx0XHRtb2RpZmllZF86IGZhbHNlLFxuXHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRhc3NpZ25lZF86IHt9LFxuXHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0Ly8gYmFzZSBpcyB0aGUgb2JqZWN0IHdlIGFyZSBkcmFmdGluZ1xuXHRcdFx0YmFzZV86IGJhc2UsXG5cdFx0XHQvLyBkcmFmdCBpcyB0aGUgZHJhZnQgb2JqZWN0IGl0c2VsZiwgdGhhdCB0cmFwcyBhbGwgcmVhZHMgYW5kIHJlYWRzIGZyb20gZWl0aGVyIHRoZSBiYXNlIChpZiB1bm1vZGlmaWVkKSBvciBjb3B5IChpZiBtb2RpZmllZClcblx0XHRcdGRyYWZ0XzogZHJhZnQsXG5cdFx0XHRjb3B5XzogbnVsbCxcblx0XHRcdHJldm9rZWRfOiBmYWxzZSxcblx0XHRcdGlzTWFudWFsXzogZmFsc2Vcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIERSQUZUX1NUQVRFLCB7XG5cdFx0XHR2YWx1ZTogc3RhdGUsXG5cdFx0XHQvLyBlbnVtZXJhYmxlOiBmYWxzZSA8LSB0aGUgZGVmYXVsdFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KVxuXHRcdHJldHVybiBkcmFmdFxuXHR9XG5cblx0Ly8gcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIHJlY3ljbGVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBjcmVhdGUgYSBnZXQgYW5kIHNldCBjbG9zdXJlIHBlciBwcm9wZXJ0eSxcblx0Ly8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblx0Y29uc3QgZGVzY3JpcHRvcnM6IHtbcHJvcDogc3RyaW5nXTogUHJvcGVydHlEZXNjcmlwdG9yfSA9IHt9XG5cblx0ZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShcblx0XHRwcm9wOiBzdHJpbmcgfCBudW1iZXIsXG5cdFx0ZW51bWVyYWJsZTogYm9vbGVhblxuXHQpOiBQcm9wZXJ0eURlc2NyaXB0b3Ige1xuXHRcdGxldCBkZXNjID0gZGVzY3JpcHRvcnNbcHJvcF1cblx0XHRpZiAoZGVzYykge1xuXHRcdFx0ZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZSxcblx0XHRcdFx0Z2V0KHRoaXM6IGFueSkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdFx0XHRpZiAoX19ERVZfXykgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRyZXR1cm4gb2JqZWN0VHJhcHMuZ2V0KHN0YXRlLCBwcm9wKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQodGhpczogYW55LCB2YWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdFx0XHRpZiAoX19ERVZfXykgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRvYmplY3RUcmFwcy5zZXQoc3RhdGUsIHByb3AsIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXNjXG5cdH1cblxuXHQvLyBUaGlzIGxvb2tzIGV4cGVuc2l2ZSwgYnV0IG9ubHkgcHJveGllcyBhcmUgdmlzaXRlZCwgYW5kIG9ubHkgb2JqZWN0cyB3aXRob3V0IGtub3duIGNoYW5nZXMgYXJlIHNjYW5uZWQuXG5cdGZ1bmN0aW9uIG1hcmtDaGFuZ2VzU3dlZXAoZHJhZnRzOiBEcmFmdGVkPGFueSwgSW1tZXJTdGF0ZT5bXSkge1xuXHRcdC8vIFRoZSBuYXR1cmFsIG9yZGVyIG9mIGRyYWZ0cyBpbiB0aGUgYHNjb3BlYCBhcnJheSBpcyBiYXNlZCBvbiB3aGVuIHRoZXlcblx0XHQvLyB3ZXJlIGFjY2Vzc2VkLiBCeSBwcm9jZXNzaW5nIGRyYWZ0cyBpbiByZXZlcnNlIG5hdHVyYWwgb3JkZXIsIHdlIGhhdmUgYVxuXHRcdC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG5cdFx0Ly8gaGF2ZSBjaGFuZ2VkLCB3ZSBjYW4gYXZvaWQgYW55IHRyYXZlcnNhbCBvZiBpdHMgYW5jZXN0b3Igbm9kZXMuXG5cdFx0Zm9yIChsZXQgaSA9IGRyYWZ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IEVTNVN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXVxuXHRcdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdFx0c3dpdGNoIChzdGF0ZS50eXBlXykge1xuXHRcdFx0XHRcdGNhc2UgUHJveHlUeXBlLkVTNUFycmF5OlxuXHRcdFx0XHRcdFx0aWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRjYXNlIFByb3h5VHlwZS5FUzVPYmplY3Q6XG5cdFx0XHRcdFx0XHRpZiAoaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkob2JqZWN0OiBhbnkpIHtcblx0XHRpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSByZXR1cm5cblx0XHRjb25zdCBzdGF0ZTogRVM1U3RhdGUgfCB1bmRlZmluZWQgPSBvYmplY3RbRFJBRlRfU1RBVEVdXG5cdFx0aWYgKCFzdGF0ZSkgcmV0dXJuXG5cdFx0Y29uc3Qge2Jhc2VfLCBkcmFmdF8sIGFzc2lnbmVkXywgdHlwZV99ID0gc3RhdGVcblx0XHRpZiAodHlwZV8gPT09IFByb3h5VHlwZS5FUzVPYmplY3QpIHtcblx0XHRcdC8vIExvb2sgZm9yIGFkZGVkIGtleXMuXG5cdFx0XHQvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG5cdFx0XHQvLyB1bm5lY2Vzc2FyeSB3b3JrLlxuXHRcdFx0Ly8gYWxzbzogcHJvYmFibHkgd2UgY2FuIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiB3ZSBkZXRlY3QgaGVyZSwgdG8gc3BlZWQgdXAgdHJlZSBmaW5hbGl6YXRpb24hXG5cdFx0XHRlYWNoKGRyYWZ0Xywga2V5ID0+IHtcblx0XHRcdFx0aWYgKChrZXkgYXMgYW55KSA9PT0gRFJBRlRfU1RBVEUpIHJldHVyblxuXHRcdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0XHRpZiAoKGJhc2VfIGFzIGFueSlba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcblx0XHRcdFx0XHRhc3NpZ25lZF9ba2V5XSA9IHRydWVcblx0XHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0fSBlbHNlIGlmICghYXNzaWduZWRfW2tleV0pIHtcblx0XHRcdFx0XHQvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuXHRcdFx0XHRcdG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoZHJhZnRfW2tleV0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQvLyBMb29rIGZvciByZW1vdmVkIGtleXMuXG5cdFx0XHRlYWNoKGJhc2VfLCBrZXkgPT4ge1xuXHRcdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0XHRpZiAoZHJhZnRfW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGRyYWZ0Xywga2V5KSkge1xuXHRcdFx0XHRcdGFzc2lnbmVkX1trZXldID0gZmFsc2Vcblx0XHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9IGVsc2UgaWYgKHR5cGVfID09PSBQcm94eVR5cGUuRVM1QXJyYXkpIHtcblx0XHRcdGlmIChoYXNBcnJheUNoYW5nZXMoc3RhdGUgYXMgRVM1QXJyYXlTdGF0ZSkpIHtcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdGFzc2lnbmVkXy5sZW5ndGggPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcmFmdF8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSBkcmFmdF8ubGVuZ3RoOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIGFzc2lnbmVkX1tpXSA9IGZhbHNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgZHJhZnRfLmxlbmd0aDsgaSsrKSBhc3NpZ25lZF9baV0gPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdC8vIE1pbmltdW0gY291bnQgaXMgZW5vdWdoLCB0aGUgb3RoZXIgcGFydHMgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuXHRcdFx0Y29uc3QgbWluID0gTWF0aC5taW4oZHJhZnRfLmxlbmd0aCwgYmFzZV8ubGVuZ3RoKVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG5cdFx0XHRcdC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG5cdFx0XHRcdGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0YXNzaWduZWRfW2ldID0gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhc3NpZ25lZF9baV0gPT09IHVuZGVmaW5lZCkgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9baV0pXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZTogRVM1T2JqZWN0U3RhdGUpIHtcblx0XHRjb25zdCB7YmFzZV8sIGRyYWZ0X30gPSBzdGF0ZVxuXG5cdFx0Ly8gU2VhcmNoIGZvciBhZGRlZCBrZXlzIGFuZCBjaGFuZ2VkIGtleXMuIFN0YXJ0IGF0IHRoZSBiYWNrLCBiZWNhdXNlXG5cdFx0Ly8gbm9uLW51bWVyaWMga2V5cyBhcmUgb3JkZXJlZCBieSB0aW1lIG9mIGRlZmluaXRpb24gb24gdGhlIG9iamVjdC5cblx0XHRjb25zdCBrZXlzID0gb3duS2V5cyhkcmFmdF8pXG5cdFx0Zm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGtleTogYW55ID0ga2V5c1tpXVxuXHRcdFx0aWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIGNvbnRpbnVlXG5cdFx0XHRjb25zdCBiYXNlVmFsdWUgPSBiYXNlX1trZXldXG5cdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0aWYgKGJhc2VWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdC8vIE9uY2UgYSBiYXNlIGtleSBpcyBkZWxldGVkLCBmdXR1cmUgY2hhbmdlcyBnbyB1bmRldGVjdGVkLCBiZWNhdXNlIGl0c1xuXHRcdFx0Ly8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZHJhZnRfW2tleV1cblx0XHRcdFx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSB2YWx1ZSAmJiB2YWx1ZVtEUkFGVF9TVEFURV1cblx0XHRcdFx0aWYgKHN0YXRlID8gc3RhdGUuYmFzZV8gIT09IGJhc2VWYWx1ZSA6ICFpcyh2YWx1ZSwgYmFzZVZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBubyBrZXlzIHdlcmUgYWRkZWQgb3IgY2hhbmdlZC5cblx0XHQvLyBDb21wYXJlIGtleSBjb3VudCB0byBkZXRlcm1pbmUgaWYga2V5cyB3ZXJlIGRlbGV0ZWQuXG5cdFx0Y29uc3QgYmFzZUlzRHJhZnQgPSAhIWJhc2VfW0RSQUZUX1NUQVRFIGFzIGFueV1cblx0XHRyZXR1cm4ga2V5cy5sZW5ndGggIT09IG93bktleXMoYmFzZV8pLmxlbmd0aCArIChiYXNlSXNEcmFmdCA/IDAgOiAxKSAvLyArIDEgdG8gY29ycmVjdCBmb3IgRFJBRlRfU1RBVEVcblx0fVxuXG5cdGZ1bmN0aW9uIGhhc0FycmF5Q2hhbmdlcyhzdGF0ZTogRVM1QXJyYXlTdGF0ZSkge1xuXHRcdGNvbnN0IHtkcmFmdF99ID0gc3RhdGVcblx0XHRpZiAoZHJhZnRfLmxlbmd0aCAhPT0gc3RhdGUuYmFzZV8ubGVuZ3RoKSByZXR1cm4gdHJ1ZVxuXHRcdC8vIFNlZSAjMTE2XG5cdFx0Ly8gSWYgd2UgZmlyc3Qgc2hvcnRlbiB0aGUgbGVuZ3RoLCBvdXIgYXJyYXkgaW50ZXJjZXB0b3JzIHdpbGwgYmUgcmVtb3ZlZC5cblx0XHQvLyBJZiBhZnRlciB0aGF0IG5ldyBpdGVtcyBhcmUgYWRkZWQsIHJlc3VsdCBpbiB0aGUgc2FtZSBvcmlnaW5hbCBsZW5ndGgsXG5cdFx0Ly8gdGhvc2UgbGFzdCBpdGVtcyB3aWxsIGhhdmUgbm8gaW50ZXJjZXB0aW5nIHByb3BlcnR5LlxuXHRcdC8vIFNvIGlmIHRoZXJlIGlzIG5vIG93biBkZXNjcmlwdG9yIG9uIHRoZSBsYXN0IHBvc2l0aW9uLCB3ZSBrbm93IHRoYXQgaXRlbXMgd2VyZSByZW1vdmVkIGFuZCBhZGRlZFxuXHRcdC8vIE4uQi46IHNwbGljZSwgdW5zaGlmdCwgZXRjIG9ubHkgc2hpZnQgdmFsdWVzIGFyb3VuZCwgYnV0IG5vdCBwcm9wIGRlc2NyaXB0b3JzLCBzbyB3ZSBvbmx5IGhhdmUgdG8gY2hlY2tcblx0XHQvLyB0aGUgbGFzdCBvbmVcblx0XHQvLyBsYXN0IGRlc2NyaXB0b3IgY2FuIGJlIG5vdCBhIHRyYXAsIGlmIHRoZSBhcnJheSB3YXMgZXh0ZW5kZWRcblx0XHRjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcblx0XHRcdGRyYWZ0Xyxcblx0XHRcdGRyYWZ0Xy5sZW5ndGggLSAxXG5cdFx0KVxuXHRcdC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cdFx0aWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gdHJ1ZVxuXHRcdC8vIGlmIHdlIG1pc3MgYSBwcm9wZXJ0eSwgaXQgaGFzIGJlZW4gZGVsZXRlZCwgc28gYXJyYXkgcHJvYm9iYWx5IGNoYW5nZWRcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRyYWZ0Xy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNDaGFuZ2VzXyhzdGF0ZTogRVM1U3RhdGUpIHtcblx0XHRyZXR1cm4gc3RhdGUudHlwZV8gPT09IFByb3h5VHlwZS5FUzVPYmplY3Rcblx0XHRcdD8gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSlcblx0XHRcdDogaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKVxuXHR9XG5cblx0ZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlOiBhbnkgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqLykge1xuXHRcdGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKVxuXHR9XG5cblx0bG9hZFBsdWdpbihcIkVTNVwiLCB7XG5cdFx0Y3JlYXRlRVM1UHJveHlfLFxuXHRcdHdpbGxGaW5hbGl6ZUVTNV8sXG5cdFx0aGFzQ2hhbmdlc19cblx0fSlcbn1cbiIsImltcG9ydCB7aW1tZXJhYmxlfSBmcm9tIFwiLi4vaW1tZXJcIlxuaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdFNldFN0YXRlLFxuXHRFUzVBcnJheVN0YXRlLFxuXHRQcm94eUFycmF5U3RhdGUsXG5cdE1hcFN0YXRlLFxuXHRFUzVPYmplY3RTdGF0ZSxcblx0UHJveHlPYmplY3RTdGF0ZSxcblx0UGF0Y2hQYXRoLFxuXHRnZXQsXG5cdGVhY2gsXG5cdGhhcyxcblx0Z2V0QXJjaHR5cGUsXG5cdGlzU2V0LFxuXHRpc01hcCxcblx0bG9hZFBsdWdpbixcblx0UHJveHlUeXBlLFxuXHRBcmNodHlwZSxcblx0ZGllLFxuXHRpc0RyYWZ0LFxuXHRpc0RyYWZ0YWJsZSxcblx0Tk9USElOR1xufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcblx0Y29uc3QgUkVQTEFDRSA9IFwicmVwbGFjZVwiXG5cdGNvbnN0IEFERCA9IFwiYWRkXCJcblx0Y29uc3QgUkVNT1ZFID0gXCJyZW1vdmVcIlxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0c3RhdGU6IEltbWVyU3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCk6IHZvaWQge1xuXHRcdHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcblx0XHRcdGNhc2UgUHJveHlUeXBlLlByb3h5T2JqZWN0OlxuXHRcdFx0Y2FzZSBQcm94eVR5cGUuRVM1T2JqZWN0OlxuXHRcdFx0Y2FzZSBQcm94eVR5cGUuTWFwOlxuXHRcdFx0XHRyZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdGJhc2VQYXRoLFxuXHRcdFx0XHRcdHBhdGNoZXMsXG5cdFx0XHRcdFx0aW52ZXJzZVBhdGNoZXNcblx0XHRcdFx0KVxuXHRcdFx0Y2FzZSBQcm94eVR5cGUuRVM1QXJyYXk6XG5cdFx0XHRjYXNlIFByb3h5VHlwZS5Qcm94eUFycmF5OlxuXHRcdFx0XHRyZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcylcblx0XHRcdGNhc2UgUHJveHlUeXBlLlNldDpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRcdFx0XHQoc3RhdGUgYXMgYW55KSBhcyBTZXRTdGF0ZSxcblx0XHRcdFx0XHRiYXNlUGF0aCxcblx0XHRcdFx0XHRwYXRjaGVzLFxuXHRcdFx0XHRcdGludmVyc2VQYXRjaGVzXG5cdFx0XHRcdClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhcblx0XHRzdGF0ZTogRVM1QXJyYXlTdGF0ZSB8IFByb3h5QXJyYXlTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KSB7XG5cdFx0bGV0IHtiYXNlXywgYXNzaWduZWRffSA9IHN0YXRlXG5cdFx0bGV0IGNvcHlfID0gc3RhdGUuY29weV8hXG5cblx0XHQvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxuXHRcdGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdDtbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dXG5cdFx0XHQ7W3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc11cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHJlcGxhY2VkIGluZGljZXMuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcblx0XHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHQvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcblx0XHRcdFx0XHQvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByb2Nlc3MgYWRkZWQgaW5kaWNlcy5cblx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgY29weV8ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0Ly8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuXHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRpZiAoYmFzZV8ubGVuZ3RoIDwgY29weV8ubGVuZ3RoKSB7XG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdHBhdGg6IGJhc2VQYXRoLmNvbmNhdChbXCJsZW5ndGhcIl0pLFxuXHRcdFx0XHR2YWx1ZTogYmFzZV8ubGVuZ3RoXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoaXMgaXMgdXNlZCBmb3IgYm90aCBNYXAgb2JqZWN0cyBhbmQgbm9ybWFsIG9iamVjdHMuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcblx0XHRzdGF0ZTogTWFwU3RhdGUgfCBFUzVPYmplY3RTdGF0ZSB8IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGNvbnN0IHtiYXNlXywgY29weV99ID0gc3RhdGVcblx0XHRlYWNoKHN0YXRlLmFzc2lnbmVkXyEsIChrZXksIGFzc2lnbmVkVmFsdWUpID0+IHtcblx0XHRcdGNvbnN0IG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBnZXQoY29weV8hLCBrZXkpXG5cdFx0XHRjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERFxuXHRcdFx0aWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpIHJldHVyblxuXHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkgYXMgYW55KVxuXHRcdFx0cGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7b3AsIHBhdGh9IDoge29wLCBwYXRoLCB2YWx1ZX0pXG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKFxuXHRcdFx0XHRvcCA9PT0gQUREXG5cdFx0XHRcdFx0PyB7b3A6IFJFTU9WRSwgcGF0aH1cblx0XHRcdFx0XHQ6IG9wID09PSBSRU1PVkVcblx0XHRcdFx0XHQ/IHtvcDogQURELCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKX1cblx0XHRcdFx0XHQ6IHtvcDogUkVQTEFDRSwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSl9XG5cdFx0XHQpXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRzdGF0ZTogU2V0U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGxldCB7YmFzZV8sIGNvcHlffSA9IHN0YXRlXG5cblx0XHRsZXQgaSA9IDBcblx0XHRiYXNlXy5mb3JFYWNoKCh2YWx1ZTogYW55KSA9PiB7XG5cdFx0XHRpZiAoIWNvcHlfIS5oYXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRU1PVkUsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcblx0XHRcdFx0XHRvcDogQURELFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGkrK1xuXHRcdH0pXG5cdFx0aSA9IDBcblx0XHRjb3B5XyEuZm9yRWFjaCgodmFsdWU6IGFueSkgPT4ge1xuXHRcdFx0aWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBBREQsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcblx0XHRcdFx0XHRvcDogUkVNT1ZFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGkrK1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG5cdFx0YmFzZVZhbHVlOiBhbnksXG5cdFx0cmVwbGFjZW1lbnQ6IGFueSxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCk6IHZvaWQge1xuXHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRvcDogUkVQTEFDRSxcblx0XHRcdHBhdGg6IFtdLFxuXHRcdFx0dmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdW5kZWZpbmVkIDogcmVwbGFjZW1lbnRcblx0XHR9KVxuXHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRwYXRoOiBbXSxcblx0XHRcdHZhbHVlOiBiYXNlVmFsdWVcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlQYXRjaGVzXzxUPihkcmFmdDogVCwgcGF0Y2hlczogUGF0Y2hbXSk6IFQge1xuXHRcdHBhdGNoZXMuZm9yRWFjaChwYXRjaCA9PiB7XG5cdFx0XHRjb25zdCB7cGF0aCwgb3B9ID0gcGF0Y2hcblxuXHRcdFx0bGV0IGJhc2U6IGFueSA9IGRyYWZ0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKVxuXHRcdFx0XHRsZXQgcCA9IHBhdGhbaV1cblx0XHRcdFx0aWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0cCA9IFwiXCIgKyBwXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZWUgIzczOCwgYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KHBhcmVudFR5cGUgPT09IEFyY2h0eXBlLk9iamVjdCB8fCBwYXJlbnRUeXBlID09PSBBcmNodHlwZS5BcnJheSkgJiZcblx0XHRcdFx0XHQocCA9PT0gXCJfX3Byb3RvX19cIiB8fCBwID09PSBcImNvbnN0cnVjdG9yXCIpXG5cdFx0XHRcdClcblx0XHRcdFx0XHRkaWUoMjQpXG5cdFx0XHRcdGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpIGRpZSgyNClcblx0XHRcdFx0YmFzZSA9IGdldChiYXNlLCBwKVxuXHRcdFx0XHRpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIGRpZSgxNSwgcGF0aC5qb2luKFwiL1wiKSlcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpIC8vIHVzZWQgdG8gY2xvbmUgcGF0Y2ggdG8gZW5zdXJlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZCwgc2VlICM0MTFcblx0XHRcdGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuXHRcdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0XHRjYXNlIFJFUExBQ0U6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlLk1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZS5TZXQ6XG5cdFx0XHRcdFx0XHRcdGRpZSgxNilcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCdzIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0XHQvLyBpbiB0aGUgZm9sbG93aW5nIGFkZCBvciByZW1vdmUgb3BzLCB0aGUgdmFsdWUgZmllbGQgaW5zaWRlIHRoZSBwYXRjaCB3aWxsIGFsc28gYmUgbW9kaWZ5ZWRcblx0XHRcdFx0XHRcdFx0Ly8gc28gd2UgdXNlIHZhbHVlIGZyb20gdGhlIGNsb25lZCBwYXRjaFxuXHRcdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoYmFzZVtrZXldID0gdmFsdWUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIEFERDpcblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGUuQXJyYXk6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBrZXkgPT09IFwiLVwiXG5cdFx0XHRcdFx0XHRcdFx0PyBiYXNlLnB1c2godmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0OiBiYXNlLnNwbGljZShrZXkgYXMgYW55LCAwLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGUuTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGUuU2V0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5hZGQodmFsdWUpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBSRU1PVkU6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlLkFycmF5OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zcGxpY2Uoa2V5IGFzIGFueSwgMSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGUuTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5kZWxldGUoa2V5KVxuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZS5TZXQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSlcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBkZWxldGUgYmFzZVtrZXldXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGRpZSgxNywgb3ApXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHJldHVybiBkcmFmdFxuXHR9XG5cblx0Ly8gb3B0aW1pemU6IHRoaXMgaXMgcXVpdGUgYSBwZXJmb3JtYW5jZSBoaXQsIGNhbiB3ZSBkZXRlY3QgaW50ZWxsaWdlbnRseSB3aGVuIGl0IGlzIG5lZWRlZD9cblx0Ly8gRS5nLiBhdXRvLWRyYWZ0IHdoZW4gbmV3IG9iamVjdHMgZnJvbSBvdXRzaWRlIGFyZSBhc3NpZ25lZCBhbmQgbW9kaWZpZWQ/XG5cdC8vIChTZWUgZmFpbGluZyB0ZXN0IHdoZW4gZGVlcENsb25lIGp1c3QgcmV0dXJucyBvYmopXG5cdGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWU8VD4ob2JqOiBUKTogVFxuXHRmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iajogYW55KSB7XG5cdFx0aWYgKCFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSlcblx0XHRpZiAoaXNNYXAob2JqKSlcblx0XHRcdHJldHVybiBuZXcgTWFwKFxuXHRcdFx0XHRBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcCgoW2ssIHZdKSA9PiBbaywgZGVlcENsb25lUGF0Y2hWYWx1ZSh2KV0pXG5cdFx0XHQpXG5cdFx0aWYgKGlzU2V0KG9iaikpIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpXG5cdFx0Y29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSlcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSlcblx0XHRpZiAoaGFzKG9iaiwgaW1tZXJhYmxlKSkgY2xvbmVkW2ltbWVyYWJsZV0gPSBvYmpbaW1tZXJhYmxlXVxuXHRcdHJldHVybiBjbG9uZWRcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkPFQ+KG9iajogVCk6IFQge1xuXHRcdGlmIChpc0RyYWZ0KG9iaikpIHtcblx0XHRcdHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iailcblx0XHR9IGVsc2UgcmV0dXJuIG9ialxuXHR9XG5cblx0bG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xuXHRcdGFwcGx5UGF0Y2hlc18sXG5cdFx0Z2VuZXJhdGVQYXRjaGVzXyxcblx0XHRnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cblx0fSlcbn1cbiIsIi8vIHR5cGVzIG9ubHkhXG5pbXBvcnQge1xuXHRJbW1lclN0YXRlLFxuXHRBbnlNYXAsXG5cdEFueVNldCxcblx0TWFwU3RhdGUsXG5cdFNldFN0YXRlLFxuXHREUkFGVF9TVEFURSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHRsYXRlc3QsXG5cdGl0ZXJhdG9yU3ltYm9sLFxuXHRpc0RyYWZ0YWJsZSxcblx0Y3JlYXRlUHJveHksXG5cdGxvYWRQbHVnaW4sXG5cdG1hcmtDaGFuZ2VkLFxuXHRQcm94eVR5cGUsXG5cdGRpZSxcblx0ZWFjaFxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQ6IGFueSwgYjogYW55KTogYW55IHtcblx0XHRleHRlbmRTdGF0aWNzID1cblx0XHRcdE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHRcdFx0KHtfX3Byb3RvX186IFtdfSBpbnN0YW5jZW9mIEFycmF5ICYmXG5cdFx0XHRcdGZ1bmN0aW9uKGQsIGIpIHtcblx0XHRcdFx0XHRkLl9fcHJvdG9fXyA9IGJcblx0XHRcdFx0fSkgfHxcblx0XHRcdGZ1bmN0aW9uKGQsIGIpIHtcblx0XHRcdFx0Zm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF1cblx0XHRcdH1cblx0XHRyZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKVxuXHR9XG5cblx0Ly8gVWdseSBoYWNrIHRvIHJlc29sdmUgIzUwMiBhbmQgaW5oZXJpdCBidWlsdCBpbiBNYXAgLyBTZXRcblx0ZnVuY3Rpb24gX19leHRlbmRzKGQ6IGFueSwgYjogYW55KTogYW55IHtcblx0XHRleHRlbmRTdGF0aWNzKGQsIGIpXG5cdFx0ZnVuY3Rpb24gX18odGhpczogYW55KTogYW55IHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBkXG5cdFx0fVxuXHRcdGQucHJvdG90eXBlID1cblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdCgoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUpLCBuZXcgX18oKSlcblx0fVxuXG5cdGNvbnN0IERyYWZ0TWFwID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXHRcdF9fZXh0ZW5kcyhEcmFmdE1hcCwgX3N1cGVyKVxuXHRcdC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxuXHRcdGZ1bmN0aW9uIERyYWZ0TWFwKHRoaXM6IGFueSwgdGFyZ2V0OiBBbnlNYXAsIHBhcmVudD86IEltbWVyU3RhdGUpOiBhbnkge1xuXHRcdFx0dGhpc1tEUkFGVF9TVEFURV0gPSB7XG5cdFx0XHRcdHR5cGVfOiBQcm94eVR5cGUuTWFwLFxuXHRcdFx0XHRwYXJlbnRfOiBwYXJlbnQsXG5cdFx0XHRcdHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpISxcblx0XHRcdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRcdGNvcHlfOiB1bmRlZmluZWQsXG5cdFx0XHRcdGFzc2lnbmVkXzogdW5kZWZpbmVkLFxuXHRcdFx0XHRiYXNlXzogdGFyZ2V0LFxuXHRcdFx0XHRkcmFmdF86IHRoaXMgYXMgYW55LFxuXHRcdFx0XHRpc01hbnVhbF86IGZhbHNlLFxuXHRcdFx0XHRyZXZva2VkXzogZmFsc2Vcblx0XHRcdH0gYXMgTWFwU3RhdGVcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXHRcdGNvbnN0IHAgPSBEcmFmdE1hcC5wcm90b3R5cGVcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZVxuXHRcdFx0fVxuXHRcdFx0Ly8gZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHQvLyBjb25maWd1cmFibGU6IHRydWVcblx0XHR9KVxuXG5cdFx0cC5oYXMgPSBmdW5jdGlvbihrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSlcblx0XHR9XG5cblx0XHRwLnNldCA9IGZ1bmN0aW9uKGtleTogYW55LCB2YWx1ZTogYW55KSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG5cdFx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCB0cnVlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgdHJ1ZSlcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0cC5kZWxldGUgPSBmdW5jdGlvbihrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIGZhbHNlKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5kZWxldGUoa2V5KVxuXHRcdFx0fVxuXHRcdFx0c3RhdGUuY29weV8hLmRlbGV0ZShrZXkpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblxuXHRcdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG5cdFx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpXG5cdFx0XHRcdGVhY2goc3RhdGUuYmFzZV8sIGtleSA9PiB7XG5cdFx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCBmYWxzZSlcblx0XHRcdFx0fSlcblx0XHRcdFx0c3RhdGUuY29weV8hLmNsZWFyKClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwLmZvckVhY2ggPSBmdW5jdGlvbihcblx0XHRcdGNiOiAodmFsdWU6IGFueSwga2V5OiBhbnksIHNlbGY6IGFueSkgPT4gdm9pZCxcblx0XHRcdHRoaXNBcmc/OiBhbnlcblx0XHQpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRsYXRlc3Qoc3RhdGUpLmZvckVhY2goKF92YWx1ZTogYW55LCBrZXk6IGFueSwgX21hcDogYW55KSA9PiB7XG5cdFx0XHRcdGNiLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoa2V5KSwga2V5LCB0aGlzKVxuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRwLmdldCA9IGZ1bmN0aW9uKGtleTogYW55KTogYW55IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSlcblx0XHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAvLyBlaXRoZXIgYWxyZWFkeSBkcmFmdGVkIG9yIHJlYXNzaWduZWRcblx0XHRcdH1cblx0XHRcdC8vIGRlc3BpdGUgd2hhdCBpdCBsb29rcywgdGhpcyBjcmVhdGVzIGEgZHJhZnQgb25seSBvbmNlLCBzZWUgYWJvdmUgY29uZGl0aW9uXG5cdFx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSlcblx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0c3RhdGUuY29weV8hLnNldChrZXksIGRyYWZ0KVxuXHRcdFx0cmV0dXJuIGRyYWZ0XG5cdFx0fVxuXG5cdFx0cC5rZXlzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKVxuXHRcdH1cblxuXHRcdHAudmFsdWVzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKClcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFtpdGVyYXRvclN5bWJvbF06ICgpID0+IHRoaXMudmFsdWVzKCksXG5cdFx0XHRcdG5leHQ6ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRpZiAoci5kb25lKSByZXR1cm4gclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogZmFsc2UsXG5cdFx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBhcyBhbnlcblx0XHR9XG5cblx0XHRwLmVudHJpZXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPFthbnksIGFueV0+IHtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKClcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFtpdGVyYXRvclN5bWJvbF06ICgpID0+IHRoaXMuZW50cmllcygpLFxuXHRcdFx0XHRuZXh0OiAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRcdFx0aWYgKHIuZG9uZSkgcmV0dXJuIHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRvbmU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gYXMgYW55XG5cdFx0fVxuXG5cdFx0cFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmVudHJpZXMoKVxuXHRcdH1cblxuXHRcdHJldHVybiBEcmFmdE1hcFxuXHR9KShNYXApXG5cblx0ZnVuY3Rpb24gcHJveHlNYXBfPFQgZXh0ZW5kcyBBbnlNYXA+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFQge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGU6IE1hcFN0YXRlKSB7XG5cdFx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdFx0c3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpXG5cdFx0XHRzdGF0ZS5jb3B5XyA9IG5ldyBNYXAoc3RhdGUuYmFzZV8pXG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgRHJhZnRTZXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKERyYWZ0U2V0LCBfc3VwZXIpXG5cdFx0Ly8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cdFx0ZnVuY3Rpb24gRHJhZnRTZXQodGhpczogYW55LCB0YXJnZXQ6IEFueVNldCwgcGFyZW50PzogSW1tZXJTdGF0ZSkge1xuXHRcdFx0dGhpc1tEUkFGVF9TVEFURV0gPSB7XG5cdFx0XHRcdHR5cGVfOiBQcm94eVR5cGUuU2V0LFxuXHRcdFx0XHRwYXJlbnRfOiBwYXJlbnQsXG5cdFx0XHRcdHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpISxcblx0XHRcdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRcdGNvcHlfOiB1bmRlZmluZWQsXG5cdFx0XHRcdGJhc2VfOiB0YXJnZXQsXG5cdFx0XHRcdGRyYWZ0XzogdGhpcyxcblx0XHRcdFx0ZHJhZnRzXzogbmV3IE1hcCgpLFxuXHRcdFx0XHRyZXZva2VkXzogZmFsc2UsXG5cdFx0XHRcdGlzTWFudWFsXzogZmFsc2Vcblx0XHRcdH0gYXMgU2V0U3RhdGVcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXHRcdGNvbnN0IHAgPSBEcmFmdFNldC5wcm90b3R5cGVcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZVxuXHRcdFx0fVxuXHRcdFx0Ly8gZW51bWVyYWJsZTogdHJ1ZSxcblx0XHR9KVxuXG5cdFx0cC5oYXMgPSBmdW5jdGlvbih2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0Ly8gYml0IG9mIHRyaWNrZXJ5IGhlcmUsIHRvIGJlIGFibGUgdG8gcmVjb2duaXplIGJvdGggdGhlIHZhbHVlLCBhbmQgdGhlIGRyYWZ0IG9mIGl0cyB2YWx1ZVxuXHRcdFx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpIHJldHVybiB0cnVlXG5cdFx0XHRpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fVxuXG5cdFx0cC5hZGQgPSBmdW5jdGlvbih2YWx1ZTogYW55KTogYW55IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5hZGQodmFsdWUpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdHAuZGVsZXRlID0gZnVuY3Rpb24odmFsdWU6IGFueSk6IGFueSB7XG5cdFx0XHRpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuZGVsZXRlKHZhbHVlKSB8fFxuXHRcdFx0XHQoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpXG5cdFx0XHRcdFx0PyBzdGF0ZS5jb3B5XyEuZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSlcblx0XHRcdFx0XHQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZhbHNlKVxuXHRcdFx0KVxuXHRcdH1cblxuXHRcdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG5cdFx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuY29weV8hLmNsZWFyKClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwLnZhbHVlcyA9IGZ1bmN0aW9uKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gc3RhdGUuY29weV8hLnZhbHVlcygpXG5cdFx0fVxuXG5cdFx0cC5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpOiBJdGVyYWJsZUl0ZXJhdG9yPFthbnksIGFueV0+IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdHJldHVybiBzdGF0ZS5jb3B5XyEuZW50cmllcygpXG5cdFx0fVxuXG5cdFx0cC5rZXlzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcygpXG5cdFx0fVxuXG5cdFx0cFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcygpXG5cdFx0fVxuXG5cdFx0cC5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYjogYW55LCB0aGlzQXJnPzogYW55KSB7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKClcblx0XHRcdGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KClcblx0XHRcdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0Y2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcylcblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIERyYWZ0U2V0XG5cdH0pKFNldClcblxuXHRmdW5jdGlvbiBwcm94eVNldF88VCBleHRlbmRzIEFueVNldD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVCB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpXG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZTogU2V0U3RhdGUpIHtcblx0XHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0XHQvLyBjcmVhdGUgZHJhZnRzIGZvciBhbGwgZW50cmllcyB0byBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXJcblx0XHRcdHN0YXRlLmNvcHlfID0gbmV3IFNldCgpXG5cdFx0XHRzdGF0ZS5iYXNlXy5mb3JFYWNoKHZhbHVlID0+IHtcblx0XHRcdFx0aWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuXHRcdFx0XHRcdGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKVxuXHRcdFx0XHRcdHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdClcblx0XHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKGRyYWZ0KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXRlLmNvcHlfIS5hZGQodmFsdWUpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlOiBhbnkgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqLykge1xuXHRcdGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKVxuXHR9XG5cblx0bG9hZFBsdWdpbihcIk1hcFNldFwiLCB7cHJveHlNYXBfLCBwcm94eVNldF99KVxufVxuIiwiaW1wb3J0IHtlbmFibGVFUzV9IGZyb20gXCIuL2VzNVwiXG5pbXBvcnQge2VuYWJsZU1hcFNldH0gZnJvbSBcIi4vbWFwc2V0XCJcbmltcG9ydCB7ZW5hYmxlUGF0Y2hlc30gZnJvbSBcIi4vcGF0Y2hlc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVBbGxQbHVnaW5zKCkge1xuXHRlbmFibGVFUzUoKVxuXHRlbmFibGVNYXBTZXQoKVxuXHRlbmFibGVQYXRjaGVzKClcbn1cbiIsImltcG9ydCB7XG5cdElQcm9kdWNlLFxuXHRJUHJvZHVjZVdpdGhQYXRjaGVzLFxuXHRJbW1lcixcblx0RHJhZnQsXG5cdEltbXV0YWJsZVxufSBmcm9tIFwiLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCB7XG5cdERyYWZ0LFxuXHRJbW11dGFibGUsXG5cdFBhdGNoLFxuXHRQYXRjaExpc3RlbmVyLFxuXHRvcmlnaW5hbCxcblx0Y3VycmVudCxcblx0aXNEcmFmdCxcblx0aXNEcmFmdGFibGUsXG5cdE5PVEhJTkcgYXMgbm90aGluZyxcblx0RFJBRlRBQkxFIGFzIGltbWVyYWJsZSxcblx0ZnJlZXplXG59IGZyb20gXCIuL2ludGVybmFsXCJcblxuY29uc3QgaW1tZXIgPSBuZXcgSW1tZXIoKVxuXG4vKipcbiAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXG4gKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG4gKlxuICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuICpcbiAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y2U6IElQcm9kdWNlID0gaW1tZXIucHJvZHVjZVxuZXhwb3J0IGRlZmF1bHQgcHJvZHVjZVxuXG4vKipcbiAqIExpa2UgYHByb2R1Y2VgLCBidXQgYHByb2R1Y2VXaXRoUGF0Y2hlc2AgYWx3YXlzIHJldHVybnMgYSB0dXBsZVxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXMgPSBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcblx0aW1tZXJcbilcblxuLyoqXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuICpcbiAqIEFsd2F5cyBmcmVlemUgYnkgZGVmYXVsdCwgZXZlbiBpbiBwcm9kdWN0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF1dG9GcmVlemUgPSBpbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpXG5cbi8qKlxuICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXG4gKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXG4gKlxuICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVc2VQcm94aWVzID0gaW1tZXIuc2V0VXNlUHJveGllcy5iaW5kKGltbWVyKVxuXG4vKipcbiAqIEFwcGx5IGFuIGFycmF5IG9mIEltbWVyIHBhdGNoZXMgdG8gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBwcm9kdWNlciwgd2hpY2ggbWVhbnMgY29weS1vbi13cml0ZSBpcyBpbiBlZmZlY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseVBhdGNoZXMgPSBpbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcilcblxuLyoqXG4gKiBDcmVhdGUgYW4gSW1tZXIgZHJhZnQgZnJvbSB0aGUgZ2l2ZW4gYmFzZSBzdGF0ZSwgd2hpY2ggbWF5IGJlIGEgZHJhZnQgaXRzZWxmLlxuICogVGhlIGRyYWZ0IGNhbiBiZSBtb2RpZmllZCB1bnRpbCB5b3UgZmluYWxpemUgaXQgd2l0aCB0aGUgYGZpbmlzaERyYWZ0YCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURyYWZ0ID0gaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcilcblxuLyoqXG4gKiBGaW5hbGl6ZSBhbiBJbW1lciBkcmFmdCBmcm9tIGEgYGNyZWF0ZURyYWZ0YCBjYWxsLCByZXR1cm5pbmcgdGhlIGJhc2Ugc3RhdGVcbiAqIChpZiBubyBjaGFuZ2VzIHdlcmUgbWFkZSkgb3IgYSBtb2RpZmllZCBjb3B5LiBUaGUgZHJhZnQgbXVzdCAqbm90KiBiZVxuICogbXV0YXRlZCBhZnRlcndhcmRzLlxuICpcbiAqIFBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgMm5kIGFyZ3VtZW50IHRvIGdlbmVyYXRlIEltbWVyIHBhdGNoZXMgYmFzZWQgb24gdGhlXG4gKiBjaGFuZ2VzIHRoYXQgd2VyZSBtYWRlLlxuICovXG5leHBvcnQgY29uc3QgZmluaXNoRHJhZnQgPSBpbW1lci5maW5pc2hEcmFmdC5iaW5kKGltbWVyKVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYW4gaW1tdXRhYmxlIHR5cGVcbiAqIHRvIGFuIGRyYWZ0IHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FzdERyYWZ0PFQ+KHZhbHVlOiBUKTogRHJhZnQ8VD4ge1xuXHRyZXR1cm4gdmFsdWUgYXMgYW55XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhIG11dGFibGUgdHlwZVxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXN0SW1tdXRhYmxlPFQ+KHZhbHVlOiBUKTogSW1tdXRhYmxlPFQ+IHtcblx0cmV0dXJuIHZhbHVlIGFzIGFueVxufVxuXG5leHBvcnQge0ltbWVyfVxuXG5leHBvcnQge2VuYWJsZUVTNX0gZnJvbSBcIi4vcGx1Z2lucy9lczVcIlxuZXhwb3J0IHtlbmFibGVQYXRjaGVzfSBmcm9tIFwiLi9wbHVnaW5zL3BhdGNoZXNcIlxuZXhwb3J0IHtlbmFibGVNYXBTZXR9IGZyb20gXCIuL3BsdWdpbnMvbWFwc2V0XCJcbmV4cG9ydCB7ZW5hYmxlQWxsUGx1Z2luc30gZnJvbSBcIi4vcGx1Z2lucy9hbGxcIlxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFFQTtBQUVBO0FBQ0EsSUFBTUEsU0FBUyxHQUNkLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUM7QUFBT0EsTUFBTSxDQUFDLEdBQUQsQ0FBYixLQUF1QixRQUR6RDtBQUVPLElBQU1DLE1BQU0sR0FBRyxPQUFPQyxHQUFQLEtBQWUsV0FBOUI7QUFDQSxJQUFNQyxNQUFNLEdBQUcsT0FBT0MsR0FBUCxLQUFlLFdBQTlCO0FBQ0EsSUFBTUMsVUFBVSxHQUN0QixPQUFPQyxLQUFQLEtBQWlCLFdBQWpCLElBQ0EsT0FBT0EsS0FBSyxDQUFDQyxTQUFiLEtB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