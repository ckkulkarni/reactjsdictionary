5f2f4cec91119695502e1bcb7d769aed
/* istanbul ignore next */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeConnect = exports.default = void 0;
var
/* istanbul ignore next */
_extends2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/extends"));
var
/* istanbul ignore next */
_objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectWithoutPropertiesLoose"));
var
/* istanbul ignore next */
_hoistNonReactStatics = _interopRequireDefault(require("hoist-non-react-statics"));
var
/* istanbul ignore next */
_react = _interopRequireWildcard(require("react"));
var
/* istanbul ignore next */
_reactIs = require("react-is");
var
/* istanbul ignore next */
_selectorFactory = _interopRequireDefault(require("../connect/selectorFactory"));
var
/* istanbul ignore next */
_mapDispatchToProps = require("../connect/mapDispatchToProps");
var
/* istanbul ignore next */
_mapStateToProps = require("../connect/mapStateToProps");
var
/* istanbul ignore next */
_mergeProps = require("../connect/mergeProps");
var
/* istanbul ignore next */
_Subscription = require("../utils/Subscription");
var
/* istanbul ignore next */
_useIsomorphicLayoutEffect = require("../utils/useIsomorphicLayoutEffect");
var
/* istanbul ignore next */
_shallowEqual = _interopRequireDefault(require("../utils/shallowEqual"));
var
/* istanbul ignore next */
_warning = _interopRequireDefault(require("../utils/warning"));
var
/* istanbul ignore next */
_Context = require("./Context");
var
/* istanbul ignore next */
_useSyncExternalStore = require("../utils/useSyncExternalStore");
/* istanbul ignore next */ function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const _excluded = ["reactReduxForwardedRef"];

/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */

let useSyncExternalStore =
/* istanbul ignore next */
_useSyncExternalStore.
/* istanbul ignore next */
notInitialized;
const initializeConnect = fn => {
  useSyncExternalStore = fn;
}; // Define some constant arrays just to avoid re-creating these
/* istanbul ignore next */
exports.initializeConnect = initializeConnect;
const EMPTY_ARRAY = [null, 0];
const NO_SUBSCRIPTION_ARRAY = [null, null]; // Attempts to stringify whatever not-really-a-component value we were given
// for logging in an error message

const stringifyComponent = Comp => {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};

// This is "just" a `useLayoutEffect`, but with two modifications:
// - we need to fall back to `useEffect` in SSR to avoid annoying warnings
// - we extract this to a separate function to avoid closing over values
//   and causing memory leaks
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  /* istanbul ignore next */
  (0,
  /* istanbul ignore next */
  _useIsomorphicLayoutEffect.
  /* istanbul ignore next */
  useIsomorphicLayoutEffect)(() => effectFunc(...effectArgs), dependencies);
} // Effect callback, extracted: assign the latest props values to refs for later usage

function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps,
// actualChildProps: unknown,
childPropsFromStoreUpdate, notifyNestedSubs) {
  // We want to capture the wrapper props and child props we used for later comparisons
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
} // Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,
// check for updates after dispatched actions, and trigger re-renders.

function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs,
// forceComponentUpdateDispatch: React.Dispatch<any>,
additionalSubscribeListener) {
  // If we're not subscribed to the store, nothing to do here
  if (!shouldHandleStateChanges) return () => {}; // Capture values for checking if and when this component unmounts

  let didUnsubscribe = false;
  let lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      // Don't run stale listeners.
      // Redux doesn't guarantee unsubscriptions happen until next dispatch.
      return;
    } // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it

    const latestStoreState = store.getState();
    let newChildProps, error;
    try {
      // Actually run the selector with the most recent store state and wrapper props
      // to determine what the child props should be
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }
    if (!error) {
      lastThrownError = null;
    } // If the child props haven't changed, nothing to do here - cascade the subscription update

    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      // Save references to the new child props.  Note that we track the "child props from store update"
      // as a ref instead of a useState/useReducer because we need a way to determine if that value has
      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
      // forcing another re-render, which we don't want.
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true; // TODO This is hacky and not how `uSES` is meant to be used
      // Trigger the React `useSyncExternalStore` subscriber

      additionalSubscribeListener();
    }
  }; // Actually subscribe to the nearest connected ancestor (or store)

  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe(); // Pull data from the store after first render in case the store has
  // changed since we began.

  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      // It's possible that we caught an error due to a bad mapState function, but the
      // parent re-rendered without this component and we're about to unmount.
      // This shouldn't happen as long as we do top-down subscriptions correctly, but
      // if we ever do those wrong, this throw will surface the error in our tests.
      // In that case, throw the error from here so it doesn't get lost.
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
} // Reducer initial state creation for our update reducer

const initStateUpdates = () => EMPTY_ARRAY;
function strictEqual(a, b) {
  return a === b;
}
/**
 * Infers the type of props that a connector will inject into a component.
 */

let hasWarnedAboutDeprecatedPureOption = false;
/**
 * Connects a React component to a Redux store.
 *
 * - Without arguments, just wraps the component, without changing the behavior / props
 *
 * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior
 * is to override ownProps (as stated in the docs), so what remains is everything that's
 * not a state or dispatch prop
 *
 * - When 3rd param is passed, we don't know if ownProps propagate and whether they
 * should be valid component props, because it depends on mergeProps implementation.
 * As such, it is the user's responsibility to extend ownProps interface from state or
 * dispatch props or both when applicable
 *
 * @param mapStateToProps A function that extracts values from state
 * @param mapDispatchToProps Setup for dispatching actions
 * @param mergeProps Optional callback to merge state and dispatch props together
 * @param options Options for configuring the connection
 *
 */

function connect(mapStateToProps, mapDispatchToProps, mergeProps, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual =
  /* istanbul ignore next */
  _shallowEqual.
  /* istanbul ignore next */
  default,
  areStatePropsEqual =
  /* istanbul ignore next */
  _shallowEqual.
  /* istanbul ignore next */
  default,
  areMergedPropsEqual =
  /* istanbul ignore next */
  _shallowEqual.
  /* istanbul ignore next */
  default,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef = false,
  // the context consumer to use
  context =
  /* istanbul ignore next */
  _Context.
  /* istanbul ignore next */
  ReactReduxContext
} = {}) {
  if (process.env.NODE_ENV !== 'production') {
    if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {
      hasWarnedAboutDeprecatedPureOption = true;
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _warning.
      /* istanbul ignore next */
      default)('The `pure` option has been removed. `connect` is now always a "pure/memoized" component');
    }
  }
  const Context = context;
  const initMapStateToProps =
  /* istanbul ignore next */
  (0,
  /* istanbul ignore next */
  _mapStateToProps.
  /* istanbul ignore next */
  mapStateToPropsFactory)(mapStateToProps);
  const initMapDispatchToProps =
  /* istanbul ignore next */
  (0,
  /* istanbul ignore next */
  _mapDispatchToProps.
  /* istanbul ignore next */
  mapDispatchToPropsFactory)(mapDispatchToProps);
  const initMergeProps =
  /* istanbul ignore next */
  (0,
  /* istanbul ignore next */
  _mergeProps.
  /* istanbul ignore next */
  mergePropsFactory)(mergeProps);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = WrappedComponent => {
    if (process.env.NODE_ENV !== 'production' && !
    /* istanbul ignore next */
    (0,
    /* istanbul ignore next */
    _reactIs.
    /* istanbul ignore next */
    isValidElementType)(WrappedComponent)) {
      throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);
    }
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      // @ts-ignore
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        // Distinguish between actual "data" props that were passed to the wrapper component,
        // and values needed to control behavior (forwarded refs, alternate context instances).
        // To maintain the wrapperProps object reference, memoize this destructuring.
        const {
            reactReduxForwardedRef
          } = props,
          wrapperProps =
          /* istanbul ignore next */
          (0,
          /* istanbul ignore next */
          _objectWithoutPropertiesLoose2.
          /* istanbul ignore next */
          default)(props, _excluded);
        return [props.context, reactReduxForwardedRef, wrapperProps];
      }, [props]);
      const ContextToUse =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
        // Memoize the check that determines which context instance we should use.
        return propsContext && propsContext.Consumer &&
        // @ts-ignore
        /* istanbul ignore next */
        (0,
        /* istanbul ignore next */
        _reactIs.
        /* istanbul ignore next */
        isContextConsumer)( /*#__PURE__*/
        /* istanbul ignore next */
        _react.
        /* istanbul ignore next */
        default.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

      const contextValue =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useContext)(ContextToUse); // The store _must_ exist as either a prop or in context.
      // We'll check to see if it _looks_ like a Redux store first.
      // This allows us to pass through a `store` prop that is just a plain value.

      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (process.env.NODE_ENV !== 'production' && !didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error(`Could not find "store" in the context of ` + `"${displayName}". Either wrap the root component in a <Provider>, ` + `or pass a custom React context provider to <Provider> and the corresponding ` + `React context consumer to ${displayName} in connect options.`);
      } // Based on the previous check, one of these must be true

      const store = didStoreComeFromProps ? props.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        // The child props selector needs the store reference as an input.
        // Re-create this selector whenever the store changes.
        return (
          /* istanbul ignore next */
          (0,
          /* istanbul ignore next */
          _selectorFactory.
          /* istanbul ignore next */
          default)(store.dispatch, selectorFactoryOptions)
        );
      }, [store]);
      const [subscription, notifyNestedSubs] =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.

        const subscription =
        /* istanbul ignore next */
        (0,
        /* istanbul ignore next */
        _Subscription.
        /* istanbul ignore next */
        createSubscription)(store, didStoreComeFromProps ? undefined : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
        // the middle of the notification loop, where `subscription` will then be null. This can
        // probably be avoided if Subscription's listeners logic is changed to not call listeners
        // that have been unsubscribed in the  middle of the notification loop.

        const notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
        return [subscription, notifyNestedSubs];
      }, [store, didStoreComeFromProps, contextValue]); // Determine what {store, subscription} value should be put into nested context, if necessary,
      // and memoize that value to avoid unnecessary context updates.

      const overriddenContextValue =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        if (didStoreComeFromProps) {
          // This component is directly subscribed to a store from props.
          // We don't want descendants reading from this store - pass down whatever
          // the existing context value is from the nearest connected ancestor.
          return contextValue;
        } // Otherwise, put this component's subscription instance into context, so that
        // connected descendants won't update until after this component is done

        return (
          /* istanbul ignore next */
          (0,
          /* istanbul ignore next */
          _extends2.
          /* istanbul ignore next */
          default)({}, contextValue, {
            subscription
          })
        );
      }, [didStoreComeFromProps, contextValue, subscription]); // Set up refs to coordinate values between the subscription effect and the render logic

      const lastChildProps =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)();
      const lastWrapperProps =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)(wrapperProps);
      const childPropsFromStoreUpdate =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)();
      const renderIsScheduled =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)(false);
      const isProcessingDispatch =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)(false);
      const isMounted =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)(false);
      const latestSubscriptionCallbackError =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useRef)();
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _useIsomorphicLayoutEffect.
      /* istanbul ignore next */
      useIsomorphicLayoutEffect)(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        const selector = () => {
          // Tricky logic here:
          // - This render may have been triggered by a Redux store update that produced new child props
          // - However, we may have gotten new wrapper props after that
          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
          // So, we'll use the child props from store update only if the wrapper props are the same as last time.
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          } // TODO We're reading the store directly in render() here. Bad idea?
          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
          // to determine what the child props should be.

          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
      // about useLayoutEffect in SSR, so we try to detect environment and fall back to
      // just useEffect instead to avoid the warning, since neither will run anyway.

      const subscribeForReact =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        const subscribe = reactListener => {
          if (!subscription) {
            return () => {};
          }
          return subscribeUpdates(shouldHandleStateChanges, store, subscription,
          // @ts-ignore
          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      let actualChildProps;
      try {
        actualChildProps = useSyncExternalStore(
        // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
        subscribeForReact,
        // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          ;
          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;
        }
        throw err;
      }
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _useIsomorphicLayoutEffect.
      /* istanbul ignore next */
      useIsomorphicLayoutEffect)(() => {
        latestSubscriptionCallbackError.current = undefined;
        childPropsFromStoreUpdate.current = undefined;
        lastChildProps.current = actualChildProps;
      }); // Now that all that's done, we can finally try to actually render the child component.
      // We memoize the elements for the rendered child component as an optimization.

      const renderedWrappedComponent =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        return /*#__PURE__*/(
          // @ts-ignore
          /* istanbul ignore next */
          _react.
          /* istanbul ignore next */
          default.createElement(WrappedComponent,
          /* istanbul ignore next */
          (0,
          /* istanbul ignore next */
          _extends2.
          /* istanbul ignore next */
          default)({}, actualChildProps, {
            ref: reactReduxForwardedRef
          }))
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

      const renderedChild =
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      useMemo)(() => {
        if (shouldHandleStateChanges) {
          // If this component is subscribed to store updates, we need to pass its own
          // subscription instance down to our descendants. That means rendering the same
          // Context instance, and putting a different value into the context.
          return /*#__PURE__*/(
            /* istanbul ignore next */
            _react.
            /* istanbul ignore next */
            default.createElement(ContextToUse.Provider, {
              value: overriddenContextValue
            }, renderedWrappedComponent)
          );
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = /*#__PURE__*/
    /* istanbul ignore next */
    _react.
    /* istanbul ignore next */
    default.memo(ConnectFunction);

    // Add a hacky cast to get the right output type
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      const _forwarded = /*#__PURE__*/
      /* istanbul ignore next */
      _react.
      /* istanbul ignore next */
      default.forwardRef(function forwardConnectRef(props, ref) {
        // @ts-ignore
        return /*#__PURE__*/(
          /* istanbul ignore next */
          _react.
          /* istanbul ignore next */
          default.createElement(Connect,
          /* istanbul ignore next */
          (0,
          /* istanbul ignore next */
          _extends2.
          /* istanbul ignore next */
          default)({}, props, {
            reactReduxForwardedRef: ref
          }))
        );
      });
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return (
        /* istanbul ignore next */
        (0,
        /* istanbul ignore next */
        _hoistNonReactStatics.
        /* istanbul ignore next */
        default)(forwarded, WrappedComponent)
      );
    }
    return (
      /* istanbul ignore next */
      (0,
      /* istanbul ignore next */
      _hoistNonReactStatics.
      /* istanbul ignore next */
      default)(Connect, WrappedComponent)
    );
  };
  return wrapWithConnect;
}
/* istanbul ignore next */
var _default = connect;
/* istanbul ignore next */
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZXh0ZW5kczIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlMiIsIl9ob2lzdE5vblJlYWN0U3RhdGljcyIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JlYWN0SXMiLCJfc2VsZWN0b3JGYWN0b3J5IiwiX21hcERpc3BhdGNoVG9Qcm9wcyIsIl9tYXBTdGF0ZVRvUHJvcHMiLCJfbWVyZ2VQcm9wcyIsIl9TdWJzY3JpcHRpb24iLCJfdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIl9zaGFsbG93RXF1YWwiLCJfd2FybmluZyIsIl9Db250ZXh0IiwiX3VzZVN5bmNFeHRlcm5hbFN0b3JlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsImdldCIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsIl9leGNsdWRlZCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwibm90SW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplQ29ubmVjdCIsImZuIiwiZXhwb3J0cyIsIkVNUFRZX0FSUkFZIiwiTk9fU1VCU0NSSVBUSU9OX0FSUkFZIiwic3RyaW5naWZ5Q29tcG9uZW50IiwiQ29tcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnIiLCJTdHJpbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MiLCJlZmZlY3RGdW5jIiwiZWZmZWN0QXJncyIsImRlcGVuZGVuY2llcyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjYXB0dXJlV3JhcHBlclByb3BzIiwibGFzdFdyYXBwZXJQcm9wcyIsImxhc3RDaGlsZFByb3BzIiwicmVuZGVySXNTY2hlZHVsZWQiLCJ3cmFwcGVyUHJvcHMiLCJjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlIiwibm90aWZ5TmVzdGVkU3VicyIsImN1cnJlbnQiLCJzdWJzY3JpYmVVcGRhdGVzIiwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzIiwic3RvcmUiLCJzdWJzY3JpcHRpb24iLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJnZXRTdGF0ZSIsIm5ld0NoaWxkUHJvcHMiLCJlcnJvciIsImUiLCJvblN0YXRlQ2hhbmdlIiwidHJ5U3Vic2NyaWJlIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwidHJ5VW5zdWJzY3JpYmUiLCJpbml0U3RhdGVVcGRhdGVzIiwic3RyaWN0RXF1YWwiLCJhIiwiYiIsImhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24iLCJjb25uZWN0IiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInB1cmUiLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJzaGFsbG93RXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiZm9yd2FyZFJlZiIsImNvbnRleHQiLCJSZWFjdFJlZHV4Q29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInVuZGVmaW5lZCIsIndhcm5pbmciLCJDb250ZXh0IiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsIm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkiLCJpbml0TWFwRGlzcGF0Y2hUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeSIsImluaXRNZXJnZVByb3BzIiwibWVyZ2VQcm9wc0ZhY3RvcnkiLCJCb29sZWFuIiwid3JhcFdpdGhDb25uZWN0IiwiV3JhcHBlZENvbXBvbmVudCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIkVycm9yIiwid3JhcHBlZENvbXBvbmVudE5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJzZWxlY3RvckZhY3RvcnlPcHRpb25zIiwiQ29ubmVjdEZ1bmN0aW9uIiwicHJvcHMiLCJwcm9wc0NvbnRleHQiLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiQ29udGV4dFRvVXNlIiwiQ29uc3VtZXIiLCJpc0NvbnRleHRDb25zdW1lciIsIlJlYWN0IiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHRWYWx1ZSIsInVzZUNvbnRleHQiLCJkaWRTdG9yZUNvbWVGcm9tUHJvcHMiLCJkaXNwYXRjaCIsImRpZFN0b3JlQ29tZUZyb21Db250ZXh0IiwiZ2V0U2VydmVyU3RhdGUiLCJkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IiwiY3JlYXRlU3Vic2NyaXB0aW9uIiwiYmluZCIsIm92ZXJyaWRkZW5Db250ZXh0VmFsdWUiLCJfZXh0ZW5kcyIsInVzZVJlZiIsImlzUHJvY2Vzc2luZ0Rpc3BhdGNoIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInNlbGVjdG9yIiwic3Vic2NyaWJlRm9yUmVhY3QiLCJzdWJzY3JpYmUiLCJyZWFjdExpc3RlbmVyIiwiYWN0dWFsQ2hpbGRQcm9wcyIsIm1lc3NhZ2UiLCJzdGFjayIsInJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCIsInJlZiIsInJlbmRlcmVkQ2hpbGQiLCJQcm92aWRlciIsInZhbHVlIiwiX0Nvbm5lY3QiLCJtZW1vIiwiQ29ubmVjdCIsIl9mb3J3YXJkZWQiLCJmb3J3YXJkQ29ubmVjdFJlZiIsImZvcndhcmRlZCIsImhvaXN0U3RhdGljcyIsIl9kZWZhdWx0Il0sInNvdXJjZXMiOlsiY29ubmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wicmVhY3RSZWR1eEZvcndhcmRlZFJlZlwiXTtcblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnRUeXBlLCBpc0NvbnRleHRDb25zdW1lciB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IGZyb20gJy4uL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5JztcbmltcG9ydCB7IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcyc7XG5pbXBvcnQgeyBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IH0gZnJvbSAnLi4vY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMnO1xuaW1wb3J0IHsgbWVyZ2VQcm9wc0ZhY3RvcnkgfSBmcm9tICcuLi9jb25uZWN0L21lcmdlUHJvcHMnO1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IHsgbm90SW5pdGlhbGl6ZWQgfSBmcm9tICcuLi91dGlscy91c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG5sZXQgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBub3RJbml0aWFsaXplZDtcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplQ29ubmVjdCA9IGZuID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBmbjtcbn07IC8vIERlZmluZSBzb21lIGNvbnN0YW50IGFycmF5cyBqdXN0IHRvIGF2b2lkIHJlLWNyZWF0aW5nIHRoZXNlXG5cbmNvbnN0IEVNUFRZX0FSUkFZID0gW251bGwsIDBdO1xuY29uc3QgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdOyAvLyBBdHRlbXB0cyB0byBzdHJpbmdpZnkgd2hhdGV2ZXIgbm90LXJlYWxseS1hLWNvbXBvbmVudCB2YWx1ZSB3ZSB3ZXJlIGdpdmVuXG4vLyBmb3IgbG9nZ2luZyBpbiBhbiBlcnJvciBtZXNzYWdlXG5cbmNvbnN0IHN0cmluZ2lmeUNvbXBvbmVudCA9IENvbXAgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcblxuLy8gVGhpcyBpcyBcImp1c3RcIiBhIGB1c2VMYXlvdXRFZmZlY3RgLCBidXQgd2l0aCB0d28gbW9kaWZpY2F0aW9uczpcbi8vIC0gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gYHVzZUVmZmVjdGAgaW4gU1NSIHRvIGF2b2lkIGFubm95aW5nIHdhcm5pbmdzXG4vLyAtIHdlIGV4dHJhY3QgdGhpcyB0byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIGNsb3Npbmcgb3ZlciB2YWx1ZXNcbi8vICAgYW5kIGNhdXNpbmcgbWVtb3J5IGxlYWtzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoZWZmZWN0RnVuYywgZWZmZWN0QXJncywgZGVwZW5kZW5jaWVzKSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gZWZmZWN0RnVuYyguLi5lZmZlY3RBcmdzKSwgZGVwZW5kZW5jaWVzKTtcbn0gLy8gRWZmZWN0IGNhbGxiYWNrLCBleHRyYWN0ZWQ6IGFzc2lnbiB0aGUgbGF0ZXN0IHByb3BzIHZhbHVlcyB0byByZWZzIGZvciBsYXRlciB1c2FnZVxuXG5cbmZ1bmN0aW9uIGNhcHR1cmVXcmFwcGVyUHJvcHMobGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIC8vIGFjdHVhbENoaWxkUHJvcHM6IHVua25vd24sXG5jaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIC8vIFdlIHdhbnQgdG8gY2FwdHVyZSB0aGUgd3JhcHBlciBwcm9wcyBhbmQgY2hpbGQgcHJvcHMgd2UgdXNlZCBmb3IgbGF0ZXIgY29tcGFyaXNvbnNcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gZmFsc2U7IC8vIElmIHRoZSByZW5kZXIgd2FzIGZyb20gYSBzdG9yZSB1cGRhdGUsIGNsZWFyIG91dCB0aGF0IHJlZmVyZW5jZSBhbmQgY2FzY2FkZSB0aGUgc3Vic2NyaWJlciB1cGRhdGVcblxuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn0gLy8gRWZmZWN0IGNhbGxiYWNrLCBleHRyYWN0ZWQ6IHN1YnNjcmliZSB0byB0aGUgUmVkdXggc3RvcmUgb3IgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IsXG4vLyBjaGVjayBmb3IgdXBkYXRlcyBhZnRlciBkaXNwYXRjaGVkIGFjdGlvbnMsIGFuZCB0cmlnZ2VyIHJlLXJlbmRlcnMuXG5cblxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBpc01vdW50ZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIC8vIGZvcmNlQ29tcG9uZW50VXBkYXRlRGlzcGF0Y2g6IFJlYWN0LkRpc3BhdGNoPGFueT4sXG5hZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgLy8gSWYgd2UncmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIHN0b3JlLCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiAoKSA9PiB7fTsgLy8gQ2FwdHVyZSB2YWx1ZXMgZm9yIGNoZWNraW5nIGlmIGFuZCB3aGVuIHRoaXMgY29tcG9uZW50IHVubW91bnRzXG5cbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsOyAvLyBXZSdsbCBydW4gdGhpcyBjYWxsYmFjayBldmVyeSB0aW1lIGEgc3RvcmUgc3Vic2NyaXB0aW9uIHVwZGF0ZSBwcm9wYWdhdGVzIHRvIHRoaXMgY29tcG9uZW50XG5cbiAgY29uc3QgY2hlY2tGb3JVcGRhdGVzID0gKCkgPT4ge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSB8fCAhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIC8vIERvbid0IHJ1biBzdGFsZSBsaXN0ZW5lcnMuXG4gICAgICAvLyBSZWR1eCBkb2Vzbid0IGd1YXJhbnRlZSB1bnN1YnNjcmlwdGlvbnMgaGFwcGVuIHVudGlsIG5leHQgZGlzcGF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUT0RPIFdlJ3JlIGN1cnJlbnRseSBjYWxsaW5nIGdldFN0YXRlIG91cnNlbHZlcyBoZXJlLCByYXRoZXIgdGhhbiBsZXR0aW5nIGB1U0VTYCBkbyBpdFxuXG5cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQWN0dWFsbHkgcnVuIHRoZSBzZWxlY3RvciB3aXRoIHRoZSBtb3N0IHJlY2VudCBzdG9yZSBzdGF0ZSBhbmQgd3JhcHBlciBwcm9wc1xuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoYXQgdGhlIGNoaWxkIHByb3BzIHNob3VsZCBiZVxuICAgICAgbmV3Q2hpbGRQcm9wcyA9IGNoaWxkUHJvcHNTZWxlY3RvcihsYXRlc3RTdG9yZVN0YXRlLCBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yID0gZTtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgICB9IC8vIElmIHRoZSBjaGlsZCBwcm9wcyBoYXZlbid0IGNoYW5nZWQsIG5vdGhpbmcgdG8gZG8gaGVyZSAtIGNhc2NhZGUgdGhlIHN1YnNjcmlwdGlvbiB1cGRhdGVcblxuXG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNhdmUgcmVmZXJlbmNlcyB0byB0aGUgbmV3IGNoaWxkIHByb3BzLiAgTm90ZSB0aGF0IHdlIHRyYWNrIHRoZSBcImNoaWxkIHByb3BzIGZyb20gc3RvcmUgdXBkYXRlXCJcbiAgICAgIC8vIGFzIGEgcmVmIGluc3RlYWQgb2YgYSB1c2VTdGF0ZS91c2VSZWR1Y2VyIGJlY2F1c2Ugd2UgbmVlZCBhIHdheSB0byBkZXRlcm1pbmUgaWYgdGhhdCB2YWx1ZSBoYXNcbiAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLiAgSWYgdGhpcyB3ZW50IGludG8gdXNlU3RhdGUvdXNlUmVkdWNlciwgd2UgY291bGRuJ3QgY2xlYXIgb3V0IHRoZSB2YWx1ZSB3aXRob3V0XG4gICAgICAvLyBmb3JjaW5nIGFub3RoZXIgcmUtcmVuZGVyLCB3aGljaCB3ZSBkb24ndCB3YW50LlxuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7IC8vIFRPRE8gVGhpcyBpcyBoYWNreSBhbmQgbm90IGhvdyBgdVNFU2AgaXMgbWVhbnQgdG8gYmUgdXNlZFxuICAgICAgLy8gVHJpZ2dlciB0aGUgUmVhY3QgYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCBzdWJzY3JpYmVyXG5cbiAgICAgIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfTsgLy8gQWN0dWFsbHkgc3Vic2NyaWJlIHRvIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3RvciAob3Igc3RvcmUpXG5cblxuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpOyAvLyBQdWxsIGRhdGEgZnJvbSB0aGUgc3RvcmUgYWZ0ZXIgZmlyc3QgcmVuZGVyIGluIGNhc2UgdGhlIHN0b3JlIGhhc1xuICAvLyBjaGFuZ2VkIHNpbmNlIHdlIGJlZ2FuLlxuXG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuXG4gIGNvbnN0IHVuc3Vic2NyaWJlV3JhcHBlciA9ICgpID0+IHtcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuXG4gICAgaWYgKGxhc3RUaHJvd25FcnJvcikge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdlIGNhdWdodCBhbiBlcnJvciBkdWUgdG8gYSBiYWQgbWFwU3RhdGUgZnVuY3Rpb24sIGJ1dCB0aGVcbiAgICAgIC8vIHBhcmVudCByZS1yZW5kZXJlZCB3aXRob3V0IHRoaXMgY29tcG9uZW50IGFuZCB3ZSdyZSBhYm91dCB0byB1bm1vdW50LlxuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGFzIGxvbmcgYXMgd2UgZG8gdG9wLWRvd24gc3Vic2NyaXB0aW9ucyBjb3JyZWN0bHksIGJ1dFxuICAgICAgLy8gaWYgd2UgZXZlciBkbyB0aG9zZSB3cm9uZywgdGhpcyB0aHJvdyB3aWxsIHN1cmZhY2UgdGhlIGVycm9yIGluIG91ciB0ZXN0cy5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhyb3cgdGhlIGVycm9yIGZyb20gaGVyZSBzbyBpdCBkb2Vzbid0IGdldCBsb3N0LlxuICAgICAgdGhyb3cgbGFzdFRocm93bkVycm9yO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufSAvLyBSZWR1Y2VyIGluaXRpYWwgc3RhdGUgY3JlYXRpb24gZm9yIG91ciB1cGRhdGUgcmVkdWNlclxuXG5cbmNvbnN0IGluaXRTdGF0ZVVwZGF0ZXMgPSAoKSA9PiBFTVBUWV9BUlJBWTtcblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbi8qKlxyXG4gKiBJbmZlcnMgdGhlIHR5cGUgb2YgcHJvcHMgdGhhdCBhIGNvbm5lY3RvciB3aWxsIGluamVjdCBpbnRvIGEgY29tcG9uZW50LlxyXG4gKi9cblxuXG5sZXQgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IGZhbHNlO1xuLyoqXHJcbiAqIENvbm5lY3RzIGEgUmVhY3QgY29tcG9uZW50IHRvIGEgUmVkdXggc3RvcmUuXHJcbiAqXHJcbiAqIC0gV2l0aG91dCBhcmd1bWVudHMsIGp1c3Qgd3JhcHMgdGhlIGNvbXBvbmVudCwgd2l0aG91dCBjaGFuZ2luZyB0aGUgYmVoYXZpb3IgLyBwcm9wc1xyXG4gKlxyXG4gKiAtIElmIDIgcGFyYW1zIGFyZSBwYXNzZWQgKDNyZCBwYXJhbSwgbWVyZ2VQcm9wcywgaXMgc2tpcHBlZCksIGRlZmF1bHQgYmVoYXZpb3JcclxuICogaXMgdG8gb3ZlcnJpZGUgb3duUHJvcHMgKGFzIHN0YXRlZCBpbiB0aGUgZG9jcyksIHNvIHdoYXQgcmVtYWlucyBpcyBldmVyeXRoaW5nIHRoYXQnc1xyXG4gKiBub3QgYSBzdGF0ZSBvciBkaXNwYXRjaCBwcm9wXHJcbiAqXHJcbiAqIC0gV2hlbiAzcmQgcGFyYW0gaXMgcGFzc2VkLCB3ZSBkb24ndCBrbm93IGlmIG93blByb3BzIHByb3BhZ2F0ZSBhbmQgd2hldGhlciB0aGV5XHJcbiAqIHNob3VsZCBiZSB2YWxpZCBjb21wb25lbnQgcHJvcHMsIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiBtZXJnZVByb3BzIGltcGxlbWVudGF0aW9uLlxyXG4gKiBBcyBzdWNoLCBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGV4dGVuZCBvd25Qcm9wcyBpbnRlcmZhY2UgZnJvbSBzdGF0ZSBvclxyXG4gKiBkaXNwYXRjaCBwcm9wcyBvciBib3RoIHdoZW4gYXBwbGljYWJsZVxyXG4gKlxyXG4gKiBAcGFyYW0gbWFwU3RhdGVUb1Byb3BzIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB2YWx1ZXMgZnJvbSBzdGF0ZVxyXG4gKiBAcGFyYW0gbWFwRGlzcGF0Y2hUb1Byb3BzIFNldHVwIGZvciBkaXNwYXRjaGluZyBhY3Rpb25zXHJcbiAqIEBwYXJhbSBtZXJnZVByb3BzIE9wdGlvbmFsIGNhbGxiYWNrIHRvIG1lcmdlIHN0YXRlIGFuZCBkaXNwYXRjaCBwcm9wcyB0b2dldGhlclxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgY29ubmVjdGlvblxyXG4gKlxyXG4gKi9cblxuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywge1xuICAvLyBUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLCBzbyBUUyBkb2Vzbid0IGxpa2UgdXMgZGVzdHJ1Y3R1cmluZyB0aGlzIHRvIGNoZWNrIGl0cyBleGlzdGVuY2UuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVyZSxcbiAgYXJlU3RhdGVzRXF1YWwgPSBzdHJpY3RFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAvLyB1c2UgUmVhY3QncyBmb3J3YXJkUmVmIHRvIGV4cG9zZSBhIHJlZiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnRcbiAgZm9yd2FyZFJlZiA9IGZhbHNlLFxuICAvLyB0aGUgY29udGV4dCBjb25zdW1lciB0byB1c2VcbiAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0XG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAocHVyZSAhPT0gdW5kZWZpbmVkICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoJ1RoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIGBjb25uZWN0YCBpcyBub3cgYWx3YXlzIGEgXCJwdXJlL21lbW9pemVkXCIgY29tcG9uZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQ7XG4gIGNvbnN0IGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNZXJnZVByb3BzID0gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcyk7XG4gIGNvbnN0IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcblxuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSBXcmFwcGVkQ29tcG9uZW50ID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoV3JhcHBlZENvbXBvbmVudCl9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ29ubmVjdEZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIERpc3Rpbmd1aXNoIGJldHdlZW4gYWN0dWFsIFwiZGF0YVwiIHByb3BzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZXIgY29tcG9uZW50LFxuICAgICAgICAvLyBhbmQgdmFsdWVzIG5lZWRlZCB0byBjb250cm9sIGJlaGF2aW9yIChmb3J3YXJkZWQgcmVmcywgYWx0ZXJuYXRlIGNvbnRleHQgaW5zdGFuY2VzKS5cbiAgICAgICAgLy8gVG8gbWFpbnRhaW4gdGhlIHdyYXBwZXJQcm9wcyBvYmplY3QgcmVmZXJlbmNlLCBtZW1vaXplIHRoaXMgZGVzdHJ1Y3R1cmluZy5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgfSA9IHByb3BzLFxuICAgICAgICAgICAgICB3cmFwcGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcblxuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc107XG4gICAgICB9LCBbcHJvcHNdKTtcbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAvLyBVc2VycyBtYXkgb3B0aW9uYWxseSBwYXNzIGluIGEgY3VzdG9tIGNvbnRleHQgaW5zdGFuY2UgdG8gdXNlIGluc3RlYWQgb2Ygb3VyIFJlYWN0UmVkdXhDb250ZXh0LlxuICAgICAgICAvLyBNZW1vaXplIHRoZSBjaGVjayB0aGF0IGRldGVybWluZXMgd2hpY2ggY29udGV4dCBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLlxuICAgICAgICByZXR1cm4gcHJvcHNDb250ZXh0ICYmIHByb3BzQ29udGV4dC5Db25zdW1lciAmJiAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlzQ29udGV4dENvbnN1bWVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpKSA/IHByb3BzQ29udGV4dCA6IENvbnRleHQ7XG4gICAgICB9LCBbcHJvcHNDb250ZXh0LCBDb250ZXh0XSk7IC8vIFJldHJpZXZlIHRoZSBzdG9yZSBhbmQgYW5jZXN0b3Igc3Vic2NyaXB0aW9uIHZpYSBjb250ZXh0LCBpZiBhdmFpbGFibGVcblxuICAgICAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlQ29udGV4dChDb250ZXh0VG9Vc2UpOyAvLyBUaGUgc3RvcmUgX211c3RfIGV4aXN0IGFzIGVpdGhlciBhIHByb3Agb3IgaW4gY29udGV4dC5cbiAgICAgIC8vIFdlJ2xsIGNoZWNrIHRvIHNlZSBpZiBpdCBfbG9va3NfIGxpa2UgYSBSZWR1eCBzdG9yZSBmaXJzdC5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHBhc3MgdGhyb3VnaCBhIGBzdG9yZWAgcHJvcCB0aGF0IGlzIGp1c3QgYSBwbGFpbiB2YWx1ZS5cblxuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbVByb3BzID0gQm9vbGVhbihwcm9wcy5zdG9yZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5nZXRTdGF0ZSkgJiYgQm9vbGVhbihwcm9wcy5zdG9yZS5kaXNwYXRjaCk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIGAgKyBgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBgICsgYG9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBgICsgYFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmApO1xuICAgICAgfSAvLyBCYXNlZCBvbiB0aGUgcHJldmlvdXMgY2hlY2ssIG9uZSBvZiB0aGVzZSBtdXN0IGJlIHRydWVcblxuXG4gICAgICBjb25zdCBzdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHByb3BzLnN0b3JlIDogY29udGV4dFZhbHVlLnN0b3JlO1xuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA/IGNvbnRleHRWYWx1ZS5nZXRTZXJ2ZXJTdGF0ZSA6IHN0b3JlLmdldFN0YXRlO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBjaGlsZCBwcm9wcyBzZWxlY3RvciBuZWVkcyB0aGUgc3RvcmUgcmVmZXJlbmNlIGFzIGFuIGlucHV0LlxuICAgICAgICAvLyBSZS1jcmVhdGUgdGhpcyBzZWxlY3RvciB3aGVuZXZlciB0aGUgc3RvcmUgY2hhbmdlcy5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgfSwgW3N0b3JlXSk7XG4gICAgICBjb25zdCBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTsgLy8gVGhpcyBTdWJzY3JpcHRpb24ncyBzb3VyY2Ugc2hvdWxkIG1hdGNoIHdoZXJlIHN0b3JlIGNhbWUgZnJvbTogcHJvcHMgdnMuIGNvbnRleHQuIEEgY29tcG9uZW50XG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byB0aGUgc3RvcmUgdmlhIHByb3BzIHNob3VsZG4ndCB1c2Ugc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dCwgb3IgdmljZSB2ZXJzYS5cblxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHVuZGVmaW5lZCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb24pOyAvLyBgbm90aWZ5TmVzdGVkU3Vic2AgaXMgZHVwbGljYXRlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGBzdWJzY3JpcHRpb25gIHdpbGwgdGhlbiBiZSBudWxsLiBUaGlzIGNhblxuICAgICAgICAvLyBwcm9iYWJseSBiZSBhdm9pZGVkIGlmIFN1YnNjcmlwdGlvbidzIGxpc3RlbmVycyBsb2dpYyBpcyBjaGFuZ2VkIHRvIG5vdCBjYWxsIGxpc3RlbmVyc1xuICAgICAgICAvLyB0aGF0IGhhdmUgYmVlbiB1bnN1YnNjcmliZWQgaW4gdGhlICBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuXG4gICAgICAgIGNvbnN0IG5vdGlmeU5lc3RlZFN1YnMgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uLCBub3RpZnlOZXN0ZWRTdWJzXTtcbiAgICAgIH0sIFtzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWVdKTsgLy8gRGV0ZXJtaW5lIHdoYXQge3N0b3JlLCBzdWJzY3JpcHRpb259IHZhbHVlIHNob3VsZCBiZSBwdXQgaW50byBuZXN0ZWQgY29udGV4dCwgaWYgbmVjZXNzYXJ5LFxuICAgICAgLy8gYW5kIG1lbW9pemUgdGhhdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb250ZXh0IHVwZGF0ZXMuXG5cbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpZFN0b3JlQ29tZUZyb21Qcm9wcykge1xuICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGlzIGRpcmVjdGx5IHN1YnNjcmliZWQgdG8gYSBzdG9yZSBmcm9tIHByb3BzLlxuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgZGVzY2VuZGFudHMgcmVhZGluZyBmcm9tIHRoaXMgc3RvcmUgLSBwYXNzIGRvd24gd2hhdGV2ZXJcbiAgICAgICAgICAvLyB0aGUgZXhpc3RpbmcgY29udGV4dCB2YWx1ZSBpcyBmcm9tIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3Rvci5cbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSwgcHV0IHRoaXMgY29tcG9uZW50J3Mgc3Vic2NyaXB0aW9uIGluc3RhbmNlIGludG8gY29udGV4dCwgc28gdGhhdFxuICAgICAgICAvLyBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd29uJ3QgdXBkYXRlIHVudGlsIGFmdGVyIHRoaXMgY29tcG9uZW50IGlzIGRvbmVcblxuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dFZhbHVlLCB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTsgLy8gU2V0IHVwIHJlZnMgdG8gY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiB0aGUgc3Vic2NyaXB0aW9uIGVmZmVjdCBhbmQgdGhlIHJlbmRlciBsb2dpY1xuXG4gICAgICBjb25zdCBsYXN0Q2hpbGRQcm9wcyA9IHVzZVJlZigpO1xuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IHVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSA9IHVzZVJlZigpO1xuICAgICAgY29uc3QgcmVuZGVySXNTY2hlZHVsZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNQcm9jZXNzaW5nRGlzcGF0Y2ggPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGNvbnN0IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICAvLyBUcmlja3kgbG9naWMgaGVyZTpcbiAgICAgICAgICAvLyAtIFRoaXMgcmVuZGVyIG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IGEgUmVkdXggc3RvcmUgdXBkYXRlIHRoYXQgcHJvZHVjZWQgbmV3IGNoaWxkIHByb3BzXG4gICAgICAgICAgLy8gLSBIb3dldmVyLCB3ZSBtYXkgaGF2ZSBnb3R0ZW4gbmV3IHdyYXBwZXIgcHJvcHMgYWZ0ZXIgdGhhdFxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgbmV3IGNoaWxkIHByb3BzLCBhbmQgdGhlIHNhbWUgd3JhcHBlciBwcm9wcywgd2Uga25vdyB3ZSBzaG91bGQgdXNlIHRoZSBuZXcgY2hpbGQgcHJvcHMgYXMtaXMuXG4gICAgICAgICAgLy8gQnV0LCBpZiB3ZSBoYXZlIG5ldyB3cmFwcGVyIHByb3BzLCB0aG9zZSBtaWdodCBjaGFuZ2UgdGhlIGNoaWxkIHByb3BzLCBzbyB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoaW5ncy5cbiAgICAgICAgICAvLyBTbywgd2UnbGwgdXNlIHRoZSBjaGlsZCBwcm9wcyBmcm9tIHN0b3JlIHVwZGF0ZSBvbmx5IGlmIHRoZSB3cmFwcGVyIHByb3BzIGFyZSB0aGUgc2FtZSBhcyBsYXN0IHRpbWUuXG4gICAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgICB9IC8vIFRPRE8gV2UncmUgcmVhZGluZyB0aGUgc3RvcmUgZGlyZWN0bHkgaW4gcmVuZGVyKCkgaGVyZS4gQmFkIGlkZWE/XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIGxpa2VseSBjYXVzZSBCYWQgVGhpbmdzIChUTSkgdG8gaGFwcGVuIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gdGhpcyBiZWNhdXNlIG9uIHJlbmRlcnMgX25vdF8gY2F1c2VkIGJ5IHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdGhlIGxhdGVzdCBzdG9yZSBzdGF0ZVxuICAgICAgICAgIC8vIHRvIGRldGVybWluZSB3aGF0IHRoZSBjaGlsZCBwcm9wcyBzaG91bGQgYmUuXG5cblxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pOyAvLyBXZSBuZWVkIHRoaXMgdG8gZXhlY3V0ZSBzeW5jaHJvbm91c2x5IGV2ZXJ5IHRpbWUgd2UgcmUtcmVuZGVyLiBIb3dldmVyLCBSZWFjdCB3YXJuc1xuICAgICAgLy8gYWJvdXQgdXNlTGF5b3V0RWZmZWN0IGluIFNTUiwgc28gd2UgdHJ5IHRvIGRldGVjdCBlbnZpcm9ubWVudCBhbmQgZmFsbCBiYWNrIHRvXG4gICAgICAvLyBqdXN0IHVzZUVmZmVjdCBpbnN0ZWFkIHRvIGF2b2lkIHRoZSB3YXJuaW5nLCBzaW5jZSBuZWl0aGVyIHdpbGwgcnVuIGFueXdheS5cblxuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gcmVhY3RMaXN0ZW5lciA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCByZWFjdExpc3RlbmVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vic10pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSggLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICBzdWJzY3JpYmVGb3JSZWFjdCwgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLCBnZXRTZXJ2ZXJTdGF0ZSA/ICgpID0+IGNoaWxkUHJvcHNTZWxlY3RvcihnZXRTZXJ2ZXJTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxcblxcbmA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTsgLy8gTm93IHRoYXQgYWxsIHRoYXQncyBkb25lLCB3ZSBjYW4gZmluYWxseSB0cnkgdG8gYWN0dWFsbHkgcmVuZGVyIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAvLyBXZSBtZW1vaXplIHRoZSBlbGVtZW50cyBmb3IgdGhlIHJlbmRlcmVkIGNoaWxkIGNvbXBvbmVudCBhcyBhbiBvcHRpbWl6YXRpb24uXG5cbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgYWN0dWFsQ2hpbGRQcm9wcywge1xuICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgICAgfSkpXG4gICAgICAgICk7XG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pOyAvLyBJZiBSZWFjdCBzZWVzIHRoZSBleGFjdCBzYW1lIGVsZW1lbnQgcmVmZXJlbmNlIGFzIGxhc3QgdGltZSwgaXQgYmFpbHMgb3V0IG9mIHJlLXJlbmRlcmluZ1xuICAgICAgLy8gdGhhdCBjaGlsZCwgc2FtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBSZWFjdC5tZW1vKCkgb3IgcmV0dXJuZWQgZmFsc2UgZnJvbSBzaG91bGRDb21wb25lbnRVcGRhdGUuXG5cbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGlzIHN1YnNjcmliZWQgdG8gc3RvcmUgdXBkYXRlcywgd2UgbmVlZCB0byBwYXNzIGl0cyBvd25cbiAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgZG93biB0byBvdXIgZGVzY2VuZGFudHMuIFRoYXQgbWVhbnMgcmVuZGVyaW5nIHRoZSBzYW1lXG4gICAgICAgICAgLy8gQ29udGV4dCBpbnN0YW5jZSwgYW5kIHB1dHRpbmcgYSBkaWZmZXJlbnQgdmFsdWUgaW50byB0aGUgY29udGV4dC5cbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZVxuICAgICAgICAgIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG5cbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKTtcblxuICAgIC8vIEFkZCBhIGhhY2t5IGNhc3QgdG8gZ2V0IHRoZSByaWdodCBvdXRwdXQgdHlwZVxuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3QsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlZlxuICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIGhvaXN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBob2lzdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBXaXRoQ29ubmVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdDsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUFBO0FBQUFBLFNBQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBO0FBQUE7QUFBQUMsOEJBQUEsR0FBQUYsc0JBQUEsQ0FBQUMsT0FBQTtBQUlBO0FBQUE7QUFBQUUscUJBQUEsR0FBQUgsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBO0FBQUE7QUFBQUcsTUFBQSxHQUFBQyx1QkFBQSxDQUFBSixPQUFBO0FBQ0E7QUFBQTtBQUFBSyxRQUFBLEdBQUFMLE9BQUE7QUFDQTtBQUFBO0FBQUFNLGdCQUFBLEdBQUFQLHNCQUFBLENBQUFDLE9BQUE7QUFDQTtBQUFBO0FBQUFPLG1CQUFBLEdBQUFQLE9BQUE7QUFDQTtBQUFBO0FBQUFRLGdCQUFBLEdBQUFSLE9BQUE7QUFDQTtBQUFBO0FBQUFTLFdBQUEsR0FBQVQsT0FBQTtBQUNBO0FBQUE7QUFBQVUsYUFBQSxHQUFBVixPQUFBO0FBQ0E7QUFBQTtBQUFBVywwQkFBQSxHQUFBWCxPQUFBO0FBQ0E7QUFBQTtBQUFBWSxhQUFBLEdBQUFiLHNCQUFBLENBQUFDLE9BQUE7QUFDQTtBQUFBO0FBQUFhLFFBQUEsR0FBQWQsc0JBQUEsQ0FBQUMsT0FBQTtBQUNBO0FBQUE7QUFBQWMsUUFBQSxHQUFBZCxPQUFBO0FBQ0E7QUFBQTtBQUFBZSxxQkFBQSxHQUFBZixPQUFBO0FB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