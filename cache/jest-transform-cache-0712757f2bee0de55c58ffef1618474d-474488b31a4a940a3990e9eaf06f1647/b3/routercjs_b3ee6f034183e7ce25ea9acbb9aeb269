48536eba6008f1bd091daf485558705e
/**
 * @remix-run/router v1.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
exports.Action = void 0;
/**
 * The pathname, search, and hash values of a URL.
 */

(function (Action) {
  Action["Pop"] = "POP";
  Action["Push"] = "PUSH";
  Action["Replace"] = "REPLACE";
})(exports.Action || (exports.Action = {}));
const PopStateEventType = "popstate"; //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Memory History
////////////////////////////////////////////////////////////////////////////////

/**
 * A user-supplied object that describes a location. Used when providing
 * entries to `createMemoryHistory` via its `initialEntries` option.
 */

/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 */
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries; // Declare so we can access from createMemoryLocation

  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = exports.Action.Pop;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
    return location;
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = exports.Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = exports.Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = exports.Action.Pop;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Browser History
////////////////////////////////////////////////////////////////////////////////

/**
 * A browser history stores the current location in regular URLs in a web
 * browser environment. This is the standard for most web apps and provides the
 * cleanest URLs the browser's address bar.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
 */

/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hash History
////////////////////////////////////////////////////////////////////////////////

/**
 * A hash history stores the current location in the fragment identifier portion
 * of the URL in a web browser environment.
 *
 * This is ideal for apps that do not control the server for some reason
 * (because the fragment identifier is never sent to the server), including some
 * shared hosting environments that do not provide fine-grained controls over
 * which pages are served at which URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory
 */

/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window.location.hash.substr(1));
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window, to) {
    let base = window.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region UTILS
////////////////////////////////////////////////////////////////////////////////

/**
 * @private
 */

function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);
    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */

function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */

function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = exports.Action.Pop;
  let listener = null;
  let index = getIndex(); // Index should only be null when we initialize. If not, it's because the
  // user called history.pushState or history.replaceState directly, in which
  // case we should log a warning as it will result in bugs.

  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = exports.Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = exports.Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = exports.Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    // window.location.origin is "null" (the literal string value) in Firefox
    // under certain conditions, notably when serving from a local HTML file
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
    let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window, to);
    },
    createURL,
    encodeLocation(to) {
      // Encode a Location the same way window.location would
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
} //#endregion

/**
 * Map of routeId -> data returned from a loader/action/error
 */

let ResultType;
/**
 * Successful result from a loader or action
 */

(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
/**
 * lazy() function to load a route definition, which can add non-matching
 * related properties to a route
 */

function isIndexRoute(route) {
  return route.index === true;
} // Walk the route tree generating unique IDs where necessary so we are working
// solely with AgnosticDataRouteObject's within the Router

function convertRoutesToDataRoutes(routes, detectErrorBoundary, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index) => {
    let treePath = [...parentPath, index];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id], "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
    if (isIndexRoute(route)) {
      let indexRoute = _extends({}, route, {
        hasErrorBoundary: detectErrorBoundary(route),
        id
      });
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, {
        id,
        hasErrorBoundary: detectErrorBoundary(route),
        children: undefined
      });
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, detectErrorBoundary, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/utils/match-routes
 */

function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i],
    // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    safelyDecodeURI(pathname));
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === undefined ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.

    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;

    // coarse-grain check for optional params
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
/**
 * Computes all combinations of optional path segments for a given path,
 * excluding combinations that are ambiguous and of lower priority.
 *
 * For example, `/one/:two?/three/:four?/:five?` explodes to:
 * - `/one/three`
 * - `/one/:two/three`
 * - `/one/three/:four`
 * - `/one/three/:five`
 * - `/one/:two/three/:four`
 * - `/one/:two/three/:five`
 * - `/one/three/:four/:five`
 * - `/one/:two/three/:four/:five`
 */

function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`

  let isOptional = first.endsWith("?"); // Compute the corresponding required segment: `foo?` -> `foo`

  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    // Intepret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = []; // All child paths with the prefix.  Do this for all children before the
  // optional version for all children so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explodes _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue

  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/"))); // Then if this is an optional value, add all child versions without

  if (isOptional) {
    result.push(...restExploded);
  } // for absolute paths, ensure `/` instead of empty segment

  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/utils/generate-path
 */

function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    path = path.replace(/\*$/, "/*");
  } // ensure `/` is added at the beginning if the path is absolute

  const prefix = path.startsWith("/") ? "/" : "";
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1; // only apply the splat if it's the last segment

    if (isLastSegment && segment === "*") {
      const star = "*";
      const starParam = params[star]; // Apply the splat

      return starParam;
    }
    const keyMatch = segment.match(/^:(\w+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      if (optional === "?") {
        return param == null ? "" : param;
      }
      if (param == null) {
        invariant(false, "Missing \":" + key + "\" param");
      }
      return param;
    } // Remove any optional markers from optional static segments

    return segment.replace(/\?$/g, "");
  }) // Remove empty segments
  .filter(segment => !!segment);
  return prefix + segments.join("/");
}
/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */

/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/utils/match-path
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/\/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  } // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it

  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */

function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
/**
 * @private
 */

function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.

    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
/**
 * @private
 */

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

/**
 * This is a shortcut for creating `application/json` responses. Converts `data`
 * to JSON and sets the `Content-Type` header.
 */
const json = function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), _extends({}, responseInit, {
    headers
  }));
};
class AbortedDeferredError extends Error {}
class DeferredData {
  constructor(data, responseInit) {
    this.pendingKeysSet = new Set();
    this.subscribers = new Set();
    this.deferredKeys = [];
    invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects"); // Set up an AbortController + Promise we can race against to exit early
    // cancellation

    let reject;
    this.abortPromise = new Promise((_, r) => reject = r);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref) => {
      let [key, value] = _ref;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
    if (this.done) {
      // All incoming values were resolved
      this.unlistenAbortSignal();
    }
    this.init = responseInit;
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.deferredKeys.push(key);
    this.pendingKeysSet.add(key); // We store a little wrapper promise that will be extended with
    // _data/_error props upon resolve/reject

    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on
    // errors or aborted deferred values

    promise.catch(() => {});
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeysSet.delete(key);
    if (this.done) {
      // Nothing left to abort!
      this.unlistenAbortSignal();
    }
    if (error) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      this.emit(false, key);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    this.emit(false, key);
    return data;
  }
  emit(aborted, settledKey) {
    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  }
  subscribe(fn) {
    this.subscribers.add(fn);
    return () => this.subscribers.delete(fn);
  }
  cancel() {
    this.controller.abort();
    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
    this.emit(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise(resolve => {
        this.subscribe(aborted => {
          signal.removeEventListener("abort", onAbort);
          if (aborted || this.done) {
            resolve(aborted);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
const defer = function defer(data, init) {
  if (init === void 0) {
    init = {};
  }
  let responseInit = typeof init === "number" ? {
    status: init
  } : init;
  return new DeferredData(data, responseInit);
};

/**
 * A redirect response. Sets the status code and the `Location` header.
 * Defaults to "302 Found".
 */
const redirect = function redirect(url, init) {
  if (init === void 0) {
    init = 302;
  }
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, _extends({}, responseInit, {
    headers
  }));
};
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 */

class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 */

function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * A Router instance manages all navigation and data loading/mutations
 */

const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_FETCHER = {
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const isServer = !isBrowser;
const defaultDetectErrorBoundary = route => Boolean(route.hasErrorBoundary); //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */

function createRouter(init) {
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let detectErrorBoundary = init.detectErrorBoundary || defaultDetectErrorBoundary; // Routes keyed by ID

  let manifest = {}; // Routes in tree format for matching

  let dataRoutes = convertRoutesToDataRoutes(init.routes, detectErrorBoundary, undefined, manifest);
  let inFlightDataRoutes; // Config driven behavior flags

  let future = _extends({
    v7_normalizeFormMethod: false
  }, init.future); // Cleanup function for history

  let unlistenHistory = null; // Externally-provided functions to call on all state changes

  let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing

  let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys

  let getScrollRestorationKey = null; // Externally-provided function to get current scroll position

  let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.

  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
  let initialErrors = null;
  if (initialMatches == null) {
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized =
  // All initialMatches need to be loaded before we're ready.  If we have lazy
  // functions around still then we'll need to run them in initialize()
  !initialMatches.some(m => m.route.lazy) && (
  // And we have to either have no loaders or have been provided hydrationData
  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: new Map(),
    blockers: new Map()
  }; // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)

  let pendingAction = exports.Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?

  let pendingPreventScrollReset = false; // AbortController for the active navigation

  let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted

  let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidate()
  //  - X-Remix-Revalidate (from redirect)

  let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission

  let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation

  let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers

  let fetchControllers = new Map(); // Track loads based on the order in which they started

  let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation

  let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions

  let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions

  let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers

  let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.

  let activeDeferreds = new Map(); // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change

  let blockerFunctions = new Map(); // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state

  let ignoreNextHistoryUpdate = false; // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();

  function initialize() {
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(_ref => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;

      // Ignore this event if it was just us resetting the URL from a
      // blocked POP navigation
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location " + "that was not created by @remix-run/router. This will fail silently in " + "production. This can happen if you are navigating outside the router " + "via `window.history.pushState`/`window.location.hash` instead of using " + "router navigation APIs.  This can also happen if you are using " + "createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        // Restore the URL to match the current UI, but don't update router state
        ignoreNextHistoryUpdate = true;
        init.history.go(delta * -1); // Put the blocker into a blocked state

        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location
            }); // Re-do the same POP navigation we just blocked

            init.history.go(delta);
          },
          reset() {
            deleteBlocker(blockerKey);
            updateState({
              blockers: new Map(router.state.blockers)
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    }); // Kick off initial data load if needed.  Use Pop to avoid modifying history
    // Note we don't do any handling of lazy here.  For SPA's it'll get handled
    // in the normal navigation flow.  For SSR it's expected that lazy modules are
    // resolved prior to router creation since we can't go into a fallbackElement
    // UI for SSR'd apps

    if (!state.initialized) {
      startNavigation(exports.Action.Pop, state.location);
    }
    return router;
  } // Clean up a router and it's side effects

  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  } // Subscribe to state updates for the router

  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  } // Update our state and notify the calling context of the change

  function updateState(newState) {
    state = _extends({}, state, newState);
    subscribers.forEach(subscriber => subscriber(state));
  } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState

  function completeNavigation(location, newState) {
    var _location$state, _location$state2;

    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
      }
    } else if (isActionReload) {
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
    } else {
      // Clear actionData on any other completed navigations
      actionData = null;
    } // Always preserve any existing loaderData from re-used routes

    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData; // On a successful navigation we can assume we got through all blockers
    // so we can start fresh

    for (let [key] of blockerFunctions) {
      deleteBlocker(key);
    } // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect

    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = undefined;
    }
    updateState(_extends({}, newState, {
      // matches, errors, fetchers go through as-is
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers: new Map(state.blockers)
    }));
    if (isUninterruptedRevalidation) ;else if (pendingAction === exports.Action.Pop) ;else if (pendingAction === exports.Action.Push) {
      init.history.push(location, location.state);
    } else if (pendingAction === exports.Action.Replace) {
      init.history.replace(location, location.state);
    } // Reset stateful navigation vars

    pendingAction = exports.Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  } // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission

  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(to, future, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history

    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : undefined;
    let historyAction = exports.Action.Push;
    if (userReplace === true) {
      historyAction = exports.Action.Replace;
    } else if (userReplace === false) ;else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = exports.Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation
          }); // Send the same navigation through

          navigate(to, opts);
        },
        reset() {
          deleteBlocker(blockerKey);
          updateState({
            blockers: new Map(state.blockers)
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  } // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round

  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    }); // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders

    if (state.navigation.state === "submitting") {
      return;
    } // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation

    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    } // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes

    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  } // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation

  async function startNavigation(historyAction, location, opts) {
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion

    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing

    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse); // Cancel all pending deferred on 404s since we don't keep any routes

      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    } // Short circuit if it's only a hash change and not a mutation submission
    // For example, on /page#hash and submit a <Form method="post"> which will
    // default to a navigation to /page

    if (isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    } // Create a controller/Request for this navigation

    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      // Call action if we received an action submission
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      let navigation = _extends({
        state: "loading",
        location
      }, opts.submission);
      loadingNavigation = navigation; // Create a GET request for the loaders

      request = new Request(request.url, {
        signal: request.signal
      });
    } // Call loaders

    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    } // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation

    pendingNavigationController = null;
    completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  } // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors

  async function handleAction(request, location, submission, matches, opts) {
    interruptActiveLoads(); // Put us in a submitting state

    let navigation = _extends({
      state: "submitting",
      location
    }, submission);
    updateState({
      navigation
    }); // Call our action and get the result

    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, detectErrorBoundary, router.basename);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again

      if ((opts && opts.replace) !== true) {
        pendingAction = exports.Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  } // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.

  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation;
    if (!loadingNavigation) {
      let navigation = _extends({
        state: "loading",
        location,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined
      }, submission);
      loadingNavigation = navigation;
    } // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available

    let activeSubmission = submission || fetcherSubmission ? submission || fetcherSubmission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
      formMethod: loadingNavigation.formMethod,
      formAction: loadingNavigation.formAction,
      formData: loadingNavigation.formData,
      formEncType: loadingNavigation.formEncType
    } : undefined;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, init.basename, pendingActionData, pendingError); // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op

    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run

    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      completeNavigation(location, _extends({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}));
      return {
        shortCircuited: true
      };
    } // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)

    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach(rf => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
        };
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach(rf => fetchControllers.set(rf.key, pendingNavigationController));
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    } // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation

    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key)); // If any loaders returned a redirect Response, start a new REPLACE navigation

    let redirect = findRedirect(results);
    if (redirect) {
      await startRedirectNavigation(state, redirect, {
        replace
      });
      return {
        shortCircuited: true
      };
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle

    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe(aborted => {
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends({
      loaderData,
      errors
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  } // Trigger a fetcher load/submit for the given fetcher key

  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key)) abortFetcher(key);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = matchRoutes(routesToUse, href, init.basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: href
      }));
      return;
    }
    let {
      path,
      submission
    } = normalizeNavigateOptions(href, future, opts, true);
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
    } // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations

    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, submission);
  } // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation

  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action && !match.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId: routeId
      });
      setFetcherError(key, routeId, error);
      return;
    } // Put this fetcher into it's submitting state

    let existingFetcher = state.fetchers.get(key);
    let fetcher = _extends({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the action for the fetcher

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, detectErrorBoundary, router.basename);
    if (fetchRequest.signal.aborted) {
      // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);
      let loadingFetcher = _extends({
        state: "loading"
      }, submission, {
        data: undefined,
        " _hasFetcherDoneAnything ": true
      });
      state.fetchers.set(key, loadingFetcher);
      updateState({
        fetchers: new Map(state.fetchers)
      });
      return startRedirectNavigation(state, actionResult, {
        submission,
        isFetchActionRedirect: true
      });
    } // Process any non-redirect errors thrown

    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    } // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation

    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, init.basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = _extends({
      state: "loading",
      data: actionResult.data
    }, submission, {
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, init.basename, {
      [match.route.id]: actionResult.data
    }, undefined // No need to send through errors since we short circuit above
    ); // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data

    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher = state.fetchers.get(staleKey);
      let revalidatingFetcher = {
        state: "loading",
        data: existingFetcher && existingFetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(staleKey, revalidatingFetcher);
      fetchControllers.set(staleKey, abortController);
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect = findRedirect(results);
    if (redirect) {
      return startRedirectNavigation(state, redirect);
    } // Process and commit output from loaders

    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
    let doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data

    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState(_extends({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.

  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state

    let loadingFetcher = _extends({
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true
    });
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }); // Call the loader for this fetcher route match

    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, detectErrorBoundary, router.basename); // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens

    if (isDeferredResult(result)) {
      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    } // We can delete this so long as we weren't aborted by ou our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers

    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    } // If the loader threw a redirect Response, start a new REPLACE navigation

    if (isRedirectResult(result)) {
      await startRedirectNavigation(state, result);
      return;
    } // Process any non-redirect errors thrown

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
      // do we need to behave any differently with our non-redirect errors?
      // What if it was a non-redirect Response?

      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"); // Put the fetcher back into an idle state

    let doneFetcher = {
      state: "idle",
      data: result.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true
    };
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */

  async function startRedirectNavigation(state, redirect, _temp) {
    var _window;
    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(state.location, redirect.location,
    // TODO: This can be removed once we get rid of useTransition in Remix v2
    _extends({
      _isRedirect: true
    }, isFetchActionRedirect ? {
      _isFetchActionRedirect: true
    } : {}));
    invariant(redirectLocation, "Expected a location on the redirect navigation"); // Check if this an absolute external redirect that goes to a new origin

    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) !== "undefined") {
      let url = init.history.createURL(redirect.location);
      let isDifferentBasename = stripBasename(url.pathname, init.basename || "/") == null;
      if (window.location.origin !== url.origin || isDifferentBasename) {
        if (replace) {
          window.location.replace(redirect.location);
        } else {
          window.location.assign(redirect.location);
        }
        return;
      }
    } // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled

    pendingNavigationController = null;
    let redirectHistoryAction = replace === true ? exports.Action.Replace : exports.Action.Push; // Use the incoming submission if provided, fallback on the active one in
    // state.navigation

    let {
      formMethod,
      formAction,
      formEncType,
      formData
    } = state.navigation;
    if (!submission && formMethod && formAction && formData && formEncType) {
      submission = {
        formMethod,
        formAction,
        formEncType,
        formData
      };
    } // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location

    if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, submission, {
          formAction: redirect.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else if (isFetchActionRedirect) {
      // For a fetch action redirect, we kick off a new loading navigation
      // without the fetcher submission, but we send it along for shouldRevalidate
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: {
          state: "loading",
          location: redirectLocation,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined
        },
        fetcherSubmission: submission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      // Otherwise, we kick off a new loading navigation, preserving the
      // submission info for the duration of this navigation
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: {
          state: "loading",
          location: redirectLocation,
          formMethod: submission ? submission.formMethod : undefined,
          formAction: submission ? submission.formAction : undefined,
          formEncType: submission ? submission.formEncType : undefined,
          formData: submission ? submission.formData : undefined
        },
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, detectErrorBoundary, router.basename)), ...fetchersToLoad.map(f => {
      if (f.matches && f.match) {
        return callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, request.signal), f.match, f.matches, manifest, detectErrorBoundary, router.basename);
      } else {
        let error = {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        };
        return error;
      }
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, request.signal, true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    // Every interruption triggers a revalidation
    isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation

    cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads

    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key)) abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        data: fetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
      }
    }
    markFetchersDone(doneKeys);
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  } // Utility function to update blockers, ensuring valid state transitions

  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER; // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM

    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    state.blockers.set(key, newBlocker);
    updateState({
      blockers: new Map(state.blockers)
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    } // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet

    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
    } // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function

    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  } // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component

  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available

    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      let y = savedScrollPositions[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    inFlightDataRoutes = newRoutes;
  }
  router = {
    get basename() {
      return init.basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let detectErrorBoundary = (opts == null ? void 0 : opts.detectErrorBoundary) || defaultDetectErrorBoundary;
  let dataRoutes = convertRoutesToDataRoutes(routes, detectErrorBoundary, undefined, manifest);
  let basename = (opts ? opts.basename : null) || "/";
  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */

  async function query(request, _temp2) {
    let {
      requestContext
    } = _temp2 === void 0 ? {} : _temp2;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) {
      return result;
    } // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location

    return _extends({
      location,
      basename
    }, result);
  }
  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */

  async function queryRoute(request, _temp3) {
    let {
      routeId,
      requestContext
    } = _temp3 === void 0 ? {} : _temp3;
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      // This should never hit I don't think?
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let result = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) {
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
    } // Pick off the right state value to return

    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      var _result$activeDeferre;
      let data = Object.values(result.loaderData)[0];
      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      }
      return data;
    }
    return undefined;
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase())) {
        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
        return result;
      }
      let result = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) {
        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {
          throw e.response;
        }
        return e.response;
      } // Redirects are always returned since they don't propagate to catch
      // boundaries

      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, detectErrorBoundary, basename, true, isRouteRequest, requestContext);
      if (request.signal.aborted) {
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(method + "() call aborted");
      }
    }
    if (isRedirectResult(result)) {
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, {
        status: result.status,
        headers: {
          Location: result.location
        }
      });
    }
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result)) {
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(request, matches, requestContext, undefined, {
        [boundaryMatch.route.id]: result.error
      }); // action status codes take precedence over loader status codes

      return _extends({}, context, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    } // Create a GET request for the loaders

    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    let context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result.data
      },
      actionHeaders: _extends({}, result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())

    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);
    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy); // Short circuit if we have no loaders to run (query())

    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    }
    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, manifest, detectErrorBoundary, basename, true, isRouteRequest, requestContext))]);
    if (request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    } // Process and commit output from loaders

    let activeDeferreds = new Map();
    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client

    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        context.loaderData[match.route.id] = null;
      }
    });
    return _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */

function getStaticContextFromError(routes, context, error) {
  let newContext = _extends({}, context, {
    statusCode: 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes[0].id]: error
    }
  });
  return newContext;
}
function isSubmissionNavigation(opts) {
  return opts != null && "formData" in opts;
} // Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params

function normalizeNavigateOptions(to, future, opts, isFetcher) {
  if (isFetcher === void 0) {
    isFetcher = false;
  }
  let path = typeof to === "string" ? to : createPath(to); // Return location verbatim on non-submission navigations

  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  } // Create a Submission on non-GET navigations

  let submission;
  if (opts.formData) {
    let formMethod = opts.formMethod || "get";
    submission = {
      formMethod: future.v7_normalizeFormMethod ? formMethod.toUpperCase() : formMethod.toLowerCase(),
      formAction: stripHashFromPath(path),
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData: opts.formData
    };
    if (isMutationMethod(submission.formMethod)) {
      return {
        path,
        submission
      };
    }
  } // Flatten submission onto URLSearchParams for GET submissions

  let parsedPath = parsePath(path);
  let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to
  // navigation GET submissions which run all loaders), we need to preserve
  // any incoming ?index params

  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
} // Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them

function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index = matches.findIndex(m => m.route.id === boundaryId);
    if (index >= 0) {
      boundaryMatches = matches.slice(0, index);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let defaultShouldRevalidate =
  // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
  isRevalidationRequired ||
  // Clicked the same link, resubmitted a GET form
  currentUrl.toString() === nextUrl.toString() ||
  // Search params affect all loaders
  currentUrl.search !== nextUrl.search; // Pick navigation matches that are net-new or qualify for revalidation

  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index) => {
    if (match.route.lazy) {
      // We haven't loaded this route yet so we don't know if it's got a loader!
      return true;
    }
    if (match.route.loader == null) {
      return false;
    } // Always call the loader on new route instances and pending defer cancellations

    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {
      return true;
    } // This is the default implementation for when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases

    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: defaultShouldRevalidate || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  }); // Pick fetcher.loads that need to be revalidated

  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    // Don't revalidate if fetcher won't be present in the subsequent render
    if (!matches.some(m => m.route.id === f.routeId)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename); // If the fetcher path no longer matches, push it in with null matches so
    // we can trigger a 404 in callLoadersAndMaybeResolveData

    if (!fetcherMatches) {
      revalidatingFetchers.push(_extends({
        key
      }, f, {
        matches: null,
        match: null
      }));
      return;
    }
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    if (cancelledFetcherLoads.includes(key)) {
      revalidatingFetchers.push(_extends({
        key,
        matches: fetcherMatches,
        match: fetcherMatch
      }, f));
      return;
    } // Revalidating fetchers are decoupled from the route matches since they
    // hit a static href, so they _always_ check shouldRevalidate and the
    // default is strictly if a revalidation is explicitly required (action
    // submissions, useRevalidator, X-Remix-Revalidate).

    let shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
      currentUrl,
      currentParams: state.matches[state.matches.length - 1].params,
      nextUrl,
      nextParams: matches[matches.length - 1].params
    }, submission, {
      actionResult,
      defaultShouldRevalidate
    }));
    if (shouldRevalidate) {
      revalidatingFetchers.push(_extends({
        key,
        matches: fetcherMatches,
        match: fetcherMatch
      }, f));
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred

  let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data

  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
/**
 * Execute route.lazy() methods to lazily load route modules (loader, action,
 * shouldRevalidate) and update the routeManifest in place which shares objects
 * with dataRoutes so those get updated as well.
 */

async function loadLazyRouteModule(route, detectErrorBoundary, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy(); // If the lazy route function was executed and removed by another parallel
  // call then we can return - first lazy() to finish wins because the return
  // value of lazy is expected to be static

  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest"); // Update the route in place.  This should be safe because there's no way
  // we could yet be sitting on this route as we can't get there without
  // resolving lazy() first.
  //
  // This is different than the HMR "update" use-case where we may actively be
  // on the route being updated.  The main concern boils down to "does this
  // mutation affect any ongoing navigations or any current state.matches
  // values?".  If not, it should be safe to update in place.

  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, "Route \"" + routeToUpdate.id + "\" has a static property \"" + lazyRouteProperty + "\" " + "defined but its lazy function is also returning a value for this property. " + ("The lazy route property \"" + lazyRouteProperty + "\" will be ignored."));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  } // Mutate the route with the provided updates.  Do this first so we pass
  // the updated version to detectErrorBoundary

  Object.assign(routeToUpdate, routeUpdates); // Mutate the `hasErrorBoundary` property on the route based on the route
  // updates and remove the `lazy` function so we don't resolve the lazy
  // route again.

  Object.assign(routeToUpdate, {
    // To keep things framework agnostic, we use the provided
    // `detectErrorBoundary` function to set the `hasErrorBoundary` route
    // property since the logic will differ between frameworks.
    hasErrorBoundary: detectErrorBoundary(_extends({}, routeToUpdate)),
    lazy: undefined
  });
}
async function callLoaderOrAction(type, request, match, matches, manifest, detectErrorBoundary, basename, isStaticRequest, isRouteRequest, requestContext) {
  if (basename === void 0) {
    basename = "/";
  }
  if (isStaticRequest === void 0) {
    isStaticRequest = false;
  }
  if (isRouteRequest === void 0) {
    isRouteRequest = false;
  }
  let resultType;
  let result;
  let onReject;
  let runHandler = handler => {
    // Setup a promise we can race against so that abort signals short circuit
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    return Promise.race([handler({
      request,
      params: match.params,
      context: requestContext
    }), abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        // Run statically defined handler in parallel with lazy()
        let values = await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, detectErrorBoundary, manifest)]);
        result = values[0];
      } else {
        // Load lazy route module, then run any returned handler
        await loadLazyRouteModule(match.route, detectErrorBoundary, manifest);
        handler = match.route[type];
        if (handler) {
          // Handler still run even if we got interrupted to maintain consistency
          // with un-abortable behavior of handler execution on non-lazy or
          // previously-lazy-loaded routes
          result = await runHandler(handler);
        } else if (type === "action") {
          throw getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: match.route.id
          });
        } else {
          // lazy() route has no loader to run.  Short circuit here so we don't
          // hit the invariant below that errors on returning undefined.
          return {
            type: ResultType.data,
            data: undefined
          };
        }
      }
    } else {
      invariant(handler, "Could not find the " + type + " to run on the \"" + match.route.id + "\" route");
      result = await runHandler(handler);
    }
    invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    resultType = ResultType.error;
    result = e;
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  if (isResponse(result)) {
    let status = result.status; // Process redirects

    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"); // Support relative routing in internal redirects

      if (!ABSOLUTE_URL_REGEX.test(location)) {
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
        let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);
        let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
        invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location); // Prepend the basename to the redirect location if we have one

        if (basename) {
          let path = resolvedLocation.pathname;
          resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
        }
        location = createPath(resolvedLocation);
      } else if (!isStaticRequest) {
        // Strip off the protocol+origin for same-origin + same-basename absolute
        // redirects. If this is a static request, we can let it go back to the
        // browser as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          location = url.pathname + url.search + url.hash;
        }
      } // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account

      if (isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null
      };
    } // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown

    if (isRouteRequest) {
      // eslint-disable-next-line no-throw-literal
      throw {
        type: resultType || ResultType.data,
        response: result
      };
    }
    let data;
    let contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last
    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type

    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
} // Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)

function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission; // Didn't think we needed this but it turns out unlike other methods, patch
    // won't be properly normalized to uppercase and results in a 405 error.
    // See: https://fetch.spec.whatwg.org/#concept-method

    init.method = formMethod.toUpperCase();
    init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)

  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs
    searchParams.append(key, value instanceof File ? value.name : value);
  }
  return searchParams;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  // Fill in loaderData/errors from our loaders
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {}; // Process loader results into state.loaderData/state.errors

  results.forEach((result, index) => {
    let id = matchesToLoad[index].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error; // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed

      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = undefined;
      }
      errors = errors || {}; // Prefer higher error values if lower errors bubble to the same boundary

      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      } // Clear our any prior loaderData for the throwing route

      loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding

      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
      } else {
        loaderData[id] = result.data;
      } // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.

      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  }); // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route

  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers

  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      match
    } = revalidatingFetchers[index];
    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
    let result = fetcherResults[index]; // Process fetcher non-redirect errors

    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = {
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) {
      if (newLoaderData[id] !== undefined) {
        mergedLoaderData[id] = newLoaderData[id];
      }
    } else if (loaderData[id] !== undefined && match.route.loader) {
      // Preserve existing keys not included in newLoaderData and where a loader
      // wasn't removed by HMR
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      // Don't keep any loader data below the boundary
      break;
    }
  }
  return mergedLoaderData;
} // Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match

function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.find(r => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = "No route matches URL \"" + pathname + "\"";
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    }
  }
  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
} // Find any returned redirect errors, starting from the lowest match

function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return result;
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectResponse(result) {
  if (!isResponse(result)) {
    return false;
  }
  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {
  for (let index = 0; index < results.length; index++) {
    let result = results[index];
    let match = matchesToLoad[index]; // If we don't have a match, then we can have a deferred result to do
    // anything with.  This is for revalidating fetchers where the route was
    // removed during HMR

    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      await resolveDeferredData(result, signal, isFetcher).then(result => {
        if (result) {
          results[index] = result || results[index];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e) {
      // Handle any TrackedPromise._error values encountered while unwrapping
      return {
        type: ResultType.error,
        error: e
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
} // Note: This should match the format exported by useMatches, so if you change
// this please also change that :)  Eventually we'll DRY this up

function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
  } // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)

  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
} //#endregion

exports.AbortedDeferredError = AbortedDeferredError;
exports.ErrorResponse = ErrorResponse;
exports.IDLE_BLOCKER = IDLE_BLOCKER;
exports.IDLE_FETCHER = IDLE_FETCHER;
exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
exports.UNSAFE_DeferredData = DeferredData;
exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
exports.UNSAFE_getPathContributingMatches = getPathContributingMatches;
exports.UNSAFE_invariant = invariant;
exports.UNSAFE_warning = warning;
exports.createBrowserHistory = createBrowserHistory;
exports.createHashHistory = createHashHistory;
exports.createMemoryHistory = createMemoryHistory;
exports.createPath = createPath;
exports.createRouter = createRouter;
exports.createStaticHandler = createStaticHandler;
exports.defer = defer;
exports.generatePath = generatePath;
exports.getStaticContextFromError = getStaticContextFromError;
exports.getToPathname = getToPathname;
exports.isDeferredData = isDeferredData;
exports.isRouteErrorResponse = isRouteErrorResponse;
exports.joinPaths = joinPaths;
exports.json = json;
exports.matchPath = matchPath;
exports.matchRoutes = matchRoutes;
exports.normalizePathname = normalizePathname;
exports.parsePath = parsePath;
exports.redirect = redirect;
exports.resolvePath = resolvePath;
exports.resolveTo = resolveTo;
exports.stripBasename = stripBasename;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJleHBvcnRzIiwiQWN0aW9uIiwiUG9wU3RhdGVFdmVudFR5cGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5Iiwib3B0aW9ucyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwidjVDb21wYXQiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJpbmRleCIsImNyZWF0ZU1lbW9yeUxvY2F0aW9uIiwic3RhdGUiLCJ1bmRlZmluZWQiLCJjbGFtcEluZGV4IiwibGVuZ3RoIiwiYWN0aW9uIiwiUG9wIiwibGlzdGVuZXIiLCJuIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRMb2NhdGlvbiIsInRvIiwia2V5IiwibG9jYXRpb24iLCJjcmVhdGVMb2NhdGlvbiIsInBhdGhuYW1lIiwid2FybmluZyIsImNoYXJBdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjcmVhdGVIcmVmIiwiY3JlYXRlUGF0aCIsImhpc3RvcnkiLCJjcmVhdGVVUkwiLCJVUkwiLCJlbmNvZGVMb2NhdGlvbiIsInBhdGgiLCJwYXJzZVBhdGgiLCJzZWFyY2giLCJoYXNoIiwicHVzaCIsIlB1c2giLCJuZXh0TG9jYXRpb24iLCJzcGxpY2UiLCJkZWx0YSIsInJlcGxhY2UiLCJSZXBsYWNlIiwiZ28iLCJuZXh0SW5kZXgiLCJsaXN0ZW4iLCJmbiIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlQnJvd3NlckxvY2F0aW9uIiwid2luZG93IiwiZ2xvYmFsSGlzdG9yeSIsInVzciIsImNyZWF0ZUJyb3dzZXJIcmVmIiwiZ2V0VXJsQmFzZWRIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjcmVhdGVIYXNoTG9jYXRpb24iLCJzdWJzdHIiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfZXh0ZW5kcyIsIl9yZWYiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiLCJnZXRMb2NhdGlvbiIsInZhbGlkYXRlTG9jYXRpb24iLCJkZWZhdWx0VmlldyIsImdldEluZGV4IiwicmVwbGFjZVN0YXRlIiwiaGFuZGxlUG9wIiwiaGlzdG9yeVN0YXRlIiwicHVzaFN0YXRlIiwiZXJyb3IiLCJhc3NpZ24iLCJvcmlnaW4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlJlc3VsdFR5cGUiLCJpbW11dGFibGVSb3V0ZUtleXMiLCJTZXQiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJkZXRlY3RFcnJvckJvdW5kYXJ5IiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJoYXNFcnJvckJvdW5kYXJ5IiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwiaSIsIm1hdGNoUm91dGVCcmFuY2giLCJzYWZlbHlEZWNvZGVVUkkiLCJwYXJlbnRzTWV0YSIsImZsYXR0ZW5Sb3V0ZSIsInJlbGF0aXZlUGF0aCIsIm1ldGEiLCJjYXNlU2Vuc2l0aXZlIiwiY2hpbGRyZW5JbmRleCIsInN0YXJ0c1dpdGgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiX3JvdXRlJHBhdGgiLCJpbmNsdWRlcyIsImV4cGxvZGVkIiwiZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMiLCJzZWdtZW50cyIsInNwbGl0IiwiZmlyc3QiLCJyZXN0IiwiaXNPcHRpb25hbCIsImVuZHNXaXRoIiwicmVxdWlyZWQiLCJyZXN0RXhwbG9kZWQiLCJyZXN1bHQiLCJzdWJwYXRoIiwic29ydCIsImEiLCJiIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInMiLCJpbml0aWFsU2NvcmUiLCJzb21lIiwiZmlsdGVyIiwicmVkdWNlIiwic2VnbWVudCIsInRlc3QiLCJzaWJsaW5ncyIsImV2ZXJ5IiwiYnJhbmNoIiwibWF0Y2hlZFBhcmFtcyIsIm1hdGNoZWRQYXRobmFtZSIsImVuZCIsInJlbWFpbmluZ1BhdGhuYW1lIiwibWF0Y2giLCJtYXRjaFBhdGgiLCJPYmplY3QiLCJwYXJhbXMiLCJwYXRobmFtZUJhc2UiLCJub3JtYWxpemVQYXRobmFtZSIsImdlbmVyYXRlUGF0aCIsIm9yaWdpbmFsUGF0aCIsInByZWZpeCIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJzdGFyUGFyYW0iLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsInBhcmFtTmFtZXMiLCJjb21waWxlUGF0aCIsImNhcHR1cmVHcm91cHMiLCJtZW1vIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInNhZmVseURlY29kZVVSSUNvbXBvbmVudCIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJkZWNvZGVVUkkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0SW5kZXgiLCJuZXh0Q2hhciIsInJlc29sdmVQYXRoIiwiZnJvbVBhdGhuYW1lIiwidG9QYXRobmFtZSIsInJlc29sdmVQYXRobmFtZSIsIm5vcm1hbGl6ZVNlYXJjaCIsIm5vcm1hbGl6ZUhhc2giLCJyZWxhdGl2ZVNlZ21lbnRzIiwicG9wIiwiZ2V0SW52YWxpZFBhdGhFcnJvciIsImNoYXIiLCJmaWVsZCIsImRlc3QiLCJnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJkYXRhIiwiaW5pdCIsInJlc3BvbnNlSW5pdCIsInN0YXR1cyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiaGFzIiwic2V0IiwiUmVzcG9uc2UiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkRlZmVycmVkRGF0YSIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0tleXNTZXQiLCJzdWJzY3JpYmVycyIsImRlZmVycmVkS2V5cyIsIkFycmF5IiwiaXNBcnJheSIsInJlamVjdCIsImFib3J0UHJvbWlzZSIsIlByb21pc2UiLCJyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIm9uQWJvcnQiLCJ1bmxpc3RlbkFib3J0U2lnbmFsIiwic2lnbmFsIiwiYWNjIiwidHJhY2tQcm9taXNlIiwiZG9uZSIsImFkZCIsInByb21pc2UiLCJyYWNlIiwidGhlbiIsIm9uU2V0dGxlIiwiY2F0Y2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFib3J0ZWQiLCJkZWxldGUiLCJlbWl0Iiwic2V0dGxlZEtleSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJyZXNvbHZlIiwic2l6ZSIsInVud3JhcHBlZERhdGEiLCJfcmVmMiIsInVud3JhcFRyYWNrZWRQcm9taXNlIiwicGVuZGluZ0tleXMiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJFcnJvclJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJ2YWxpZE11dGF0aW9uTWV0aG9kc0FyciIsInZhbGlkTXV0YXRpb25NZXRob2RzIiwidmFsaWRSZXF1ZXN0TWV0aG9kc0FyciIsInZhbGlkUmVxdWVzdE1ldGhvZHMiLCJyZWRpcmVjdFN0YXR1c0NvZGVzIiwicmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzIiwiSURMRV9OQVZJR0FUSU9OIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1EYXRhIiwiSURMRV9GRVRDSEVSIiwiSURMRV9CTE9DS0VSIiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiaXNCcm93c2VyIiwiY3JlYXRlRWxlbWVudCIsImlzU2VydmVyIiwiZGVmYXVsdERldGVjdEVycm9yQm91bmRhcnkiLCJCb29sZWFuIiwiY3JlYXRlUm91dGVyIiwiZGF0YVJvdXRlcyIsImluRmxpZ2h0RGF0YVJvdXRlcyIsImZ1dHVyZSIsInY3X25vcm1hbGl6ZUZvcm1NZXRob2QiLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzYXZlZFNjcm9sbFBvc2l0aW9ucyIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5IiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJpbml0aWFsU2Nyb2xsUmVzdG9yZWQiLCJoeWRyYXRpb25EYXRhIiwiaW5pdGlhbE1hdGNoZXMiLCJpbml0aWFsRXJyb3JzIiwiZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvciIsImdldFNob3J0Q2lyY3VpdE1hdGNoZXMiLCJpbml0aWFsaXplZCIsIm0iLCJsYXp5IiwibG9hZGVyIiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJsb2FkZXJEYXRhIiwiYWN0aW9uRGF0YSIsImVycm9ycyIsImZldGNoZXJzIiwiTWFwIiwiYmxvY2tlcnMiLCJwZW5kaW5nQWN0aW9uIiwicGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCIsInBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyIsImNhbmNlbGxlZEZldGNoZXJMb2FkcyIsImZldGNoQ29udHJvbGxlcnMiLCJpbmNyZW1lbnRpbmdMb2FkSWQiLCJwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCIsImZldGNoUmVsb2FkSWRzIiwiZmV0Y2hSZWRpcmVjdElkcyIsImZldGNoTG9hZE1hdGNoZXMiLCJhY3RpdmVEZWZlcnJlZHMiLCJibG9ja2VyRnVuY3Rpb25zIiwiaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUiLCJpbml0aWFsaXplIiwiYmxvY2tlcktleSIsInNob3VsZEJsb2NrTmF2aWdhdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsInVwZGF0ZUJsb2NrZXIiLCJkZWxldGVCbG9ja2VyIiwidXBkYXRlU3RhdGUiLCJzdGFydE5hdmlnYXRpb24iLCJkaXNwb3NlIiwiY2xlYXIiLCJkZWxldGVGZXRjaGVyIiwibmV3U3RhdGUiLCJjb21wbGV0ZU5hdmlnYXRpb24iLCJfbG9jYXRpb24kc3RhdGUiLCJfbG9jYXRpb24kc3RhdGUyIiwiaXNBY3Rpb25SZWxvYWQiLCJpc011dGF0aW9uTWV0aG9kIiwiX2lzUmVkaXJlY3QiLCJrZXlzIiwibWVyZ2VMb2FkZXJEYXRhIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwib3B0cyIsInN1Ym1pc3Npb24iLCJub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMiLCJ1c2VyUmVwbGFjZSIsInBlbmRpbmdFcnJvciIsInJldmFsaWRhdGUiLCJpbnRlcnJ1cHRBY3RpdmVMb2FkcyIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInJvdXRlc1RvVXNlIiwibG9hZGluZ05hdmlnYXRpb24iLCJub3RGb3VuZE1hdGNoZXMiLCJjYW5jZWxBY3RpdmVEZWZlcnJlZHMiLCJpc0hhc2hDaGFuZ2VPbmx5IiwicmVxdWVzdCIsImNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0IiwicGVuZGluZ0FjdGlvbkRhdGEiLCJmaW5kTmVhcmVzdEJvdW5kYXJ5IiwiYWN0aW9uT3V0cHV0IiwiaGFuZGxlQWN0aW9uIiwic2hvcnRDaXJjdWl0ZWQiLCJwZW5kaW5nQWN0aW9uRXJyb3IiLCJSZXF1ZXN0IiwiaGFuZGxlTG9hZGVycyIsImZldGNoZXJTdWJtaXNzaW9uIiwiYWN0aW9uTWF0Y2giLCJnZXRUYXJnZXRNYXRjaCIsInR5cGUiLCJtZXRob2QiLCJyb3V0ZUlkIiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwiYWN0aXZlU3VibWlzc2lvbiIsIm1hdGNoZXNUb0xvYWQiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJyZiIsImZldGNoZXIiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsInByb2Nlc3NMb2FkZXJEYXRhIiwiZGVmZXJyZWREYXRhIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwiZ2V0RmV0Y2hlciIsImZldGNoIiwiYWJvcnRGZXRjaGVyIiwic2V0RmV0Y2hlckVycm9yIiwiaGFuZGxlRmV0Y2hlckFjdGlvbiIsImhhbmRsZUZldGNoZXJMb2FkZXIiLCJyZXF1ZXN0TWF0Y2hlcyIsImV4aXN0aW5nRmV0Y2hlciIsImFib3J0Q29udHJvbGxlciIsImZldGNoUmVxdWVzdCIsImFjdGlvblJlc3VsdCIsImxvYWRpbmdGZXRjaGVyIiwiaXNGZXRjaEFjdGlvblJlZGlyZWN0IiwicmV2YWxpZGF0aW9uUmVxdWVzdCIsImxvYWRJZCIsImxvYWRGZXRjaGVyIiwic3RhbGVLZXkiLCJkb25lRmV0Y2hlciIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcCIsIl93aW5kb3ciLCJyZWRpcmVjdExvY2F0aW9uIiwiX2lzRmV0Y2hBY3Rpb25SZWRpcmVjdCIsImlzRGlmZmVyZW50QmFzZW5hbWUiLCJyZWRpcmVjdEhpc3RvcnlBY3Rpb24iLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiYWxsIiwiZiIsInJlc29sdmVEZWZlcnJlZFJlc3VsdHMiLCJtYXJrRmV0Y2hlcnNEb25lIiwiZG9uZUtleXMiLCJsYW5kZWRJZCIsInllZXRlZEtleXMiLCJnZXRCbG9ja2VyIiwiYmxvY2tlciIsIm5ld0Jsb2NrZXIiLCJibG9ja2VyRnVuY3Rpb24iLCJwcmVkaWNhdGUiLCJjYW5jZWxsZWRSb3V0ZUlkcyIsImRmZCIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJnZXRLZXkiLCJ5IiwidXNlck1hdGNoZXMiLCJjcmVhdGVVc2VNYXRjaGVzTWF0Y2giLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJuZXdSb3V0ZXMiLCJfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzIiwiX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzIiwiVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCIsIlN5bWJvbCIsImNyZWF0ZVN0YXRpY0hhbmRsZXIiLCJxdWVyeSIsIl90ZW1wMiIsInJlcXVlc3RDb250ZXh0IiwiaXNWYWxpZE1ldGhvZCIsIm1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzIiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwicXVlcnlJbXBsIiwiaXNSZXNwb25zZSIsInF1ZXJ5Um91dGUiLCJfdGVtcDMiLCJmaW5kIiwidmFsdWVzIiwiX3Jlc3VsdCRhY3RpdmVEZWZlcnJlIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc1F1ZXJ5Um91dGVSZXNwb25zZSIsImlzUmVkaXJlY3RSZXNwb25zZSIsInJlc3BvbnNlIiwiaXNSb3V0ZVJlcXVlc3QiLCJMb2NhdGlvbiIsImNvbnRleHQiLCJsb2FkZXJSZXF1ZXN0IiwiZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkiLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZXhlY3V0ZWRMb2FkZXJzIiwiZnJvbUVudHJpZXMiLCJnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yIiwibmV3Q29udGV4dCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImlzRmV0Y2hlciIsInRvVXBwZXJDYXNlIiwic3RyaXBIYXNoRnJvbVBhdGgiLCJzZWFyY2hQYXJhbXMiLCJjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyIsImhhc05ha2VkSW5kZXhRdWVyeSIsImFwcGVuZCIsImJvdW5kYXJ5SWQiLCJib3VuZGFyeU1hdGNoZXMiLCJmaW5kSW5kZXgiLCJjdXJyZW50VXJsIiwibmV4dFVybCIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwibmF2aWdhdGlvbk1hdGNoZXMiLCJpc05ld0xvYWRlciIsImN1cnJlbnRSb3V0ZU1hdGNoIiwibmV4dFJvdXRlTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJpc05ld1JvdXRlSW5zdGFuY2UiLCJmZXRjaGVyTWF0Y2hlcyIsImZldGNoZXJNYXRjaCIsInNob3VsZFJldmFsaWRhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJyb3V0ZUNob2ljZSIsImxvYWRMYXp5Um91dGVNb2R1bGUiLCJsYXp5Um91dGUiLCJyb3V0ZVRvVXBkYXRlIiwicm91dGVVcGRhdGVzIiwibGF6eVJvdXRlUHJvcGVydHkiLCJzdGF0aWNSb3V0ZVZhbHVlIiwiaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkIiwiaXNTdGF0aWNSZXF1ZXN0IiwicmVzdWx0VHlwZSIsIm9uUmVqZWN0IiwicnVuSGFuZGxlciIsImhhbmRsZXIiLCJhY3RpdmVNYXRjaGVzIiwicmVzb2x2ZWRMb2NhdGlvbiIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJjb250ZW50VHlwZSIsInRleHQiLCJpc0RlZmVycmVkRGF0YSIsIl9yZXN1bHQkaW5pdCIsIl9yZXN1bHQkaW5pdDIiLCJkZWZlcnJlZCIsImJvZHkiLCJVUkxTZWFyY2hQYXJhbXMiLCJGaWxlIiwibmFtZSIsImZvdW5kRXJyb3IiLCJuZXdMb2FkZXJEYXRhIiwibWVyZ2VkTG9hZGVyRGF0YSIsImhhc093blByb3BlcnR5IiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsIl90ZW1wNCIsImVycm9yTWVzc2FnZSIsIm9iaiIsImlzUmV2YWxpZGF0aW5nTG9hZGVyIiwidW53cmFwIiwiZ2V0QWxsIiwiaGFuZGxlIiwicGF0aE1hdGNoZXMiXSwic291cmNlcyI6WyIuLi9oaXN0b3J5LnRzIiwiLi4vdXRpbHMudHMiLCIuLi9yb3V0ZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFjdGlvbnMgcmVwcmVzZW50IHRoZSB0eXBlIG9mIGNoYW5nZSB0byBhIGxvY2F0aW9uIHZhbHVlLlxuICovXG5leHBvcnQgZW51bSBBY3Rpb24ge1xuICAvKipcbiAgICogQSBQT1AgaW5kaWNhdGVzIGEgY2hhbmdlIHRvIGFuIGFyYml0cmFyeSBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaFxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uLCBvbmx5IHRoYXQgdGhlIGN1cnJlbnQgaW5kZXggY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxuICAgKi9cbiAgUG9wID0gXCJQT1BcIixcblxuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBQdXNoID0gXCJQVVNIXCIsXG5cbiAgLyoqXG4gICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cbiAgICovXG4gIFJlcGxhY2UgPSBcIlJFUExBQ0VcIixcbn1cblxuLyoqXG4gKiBUaGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggdmFsdWVzIG9mIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGgge1xuICAvKipcbiAgICogQSBVUkwgcGF0aG5hbWUsIGJlZ2lubmluZyB3aXRoIGEgLy5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgVVJMIHNlYXJjaCBzdHJpbmcsIGJlZ2lubmluZyB3aXRoIGEgPy5cbiAgICovXG4gIHNlYXJjaDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIFVSTCBmcmFnbWVudCBpZGVudGlmaWVyLCBiZWdpbm5pbmcgd2l0aCBhICMuXG4gICAqL1xuICBoYXNoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQW4gZW50cnkgaW4gYSBoaXN0b3J5IHN0YWNrLiBBIGxvY2F0aW9uIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogVVJMIHBhdGgsIGFzIHdlbGwgYXMgcG9zc2libHkgc29tZSBhcmJpdHJhcnkgc3RhdGUgYW5kIGEga2V5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uIGV4dGVuZHMgUGF0aCB7XG4gIC8qKlxuICAgKiBBIHZhbHVlIG9mIGFyYml0cmFyeSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLlxuICAgKi9cbiAgc3RhdGU6IGFueTtcblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxvY2F0aW9uLiBNYXkgYmUgdXNlZCB0byBzYWZlbHkgc3RvcmVcbiAgICogYW5kIHJldHJpZXZlIGRhdGEgaW4gc29tZSBvdGhlciBzdG9yYWdlIEFQSSwgbGlrZSBgbG9jYWxTdG9yYWdlYC5cbiAgICpcbiAgICogTm90ZTogVGhpcyB2YWx1ZSBpcyBhbHdheXMgXCJkZWZhdWx0XCIgb24gdGhlIGluaXRpYWwgbG9jYXRpb24uXG4gICAqL1xuICBrZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNoYW5nZSB0byB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGUge1xuICAvKipcbiAgICogVGhlIGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgY2hhbmdlLlxuICAgKi9cbiAgYWN0aW9uOiBBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBuZXcgbG9jYXRpb24uXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWx0YSBiZXR3ZWVuIHRoaXMgbG9jYXRpb24gYW5kIHRoZSBmb3JtZXIgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2tcbiAgICovXG4gIGRlbHRhOiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBub3RpZmljYXRpb25zIGFib3V0IGxvY2F0aW9uIGNoYW5nZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXIge1xuICAodXBkYXRlOiBVcGRhdGUpOiB2b2lkO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGxvY2F0aW9uIHRoYXQgaXMgdGhlIGRlc3RpbmF0aW9uIG9mIHNvbWUgbmF2aWdhdGlvbiwgZWl0aGVyIHZpYVxuICogYGhpc3RvcnkucHVzaGAgb3IgYGhpc3RvcnkucmVwbGFjZWAuIE1heSBiZSBlaXRoZXIgYSBVUkwgb3IgdGhlIHBpZWNlcyBvZiBhXG4gKiBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgVG8gPSBzdHJpbmcgfCBQYXJ0aWFsPFBhdGg+O1xuXG4vKipcbiAqIEEgaGlzdG9yeSBpcyBhbiBpbnRlcmZhY2UgdG8gdGhlIG5hdmlnYXRpb24gc3RhY2suIFRoZSBoaXN0b3J5IHNlcnZlcyBhcyB0aGVcbiAqIHNvdXJjZSBvZiB0cnV0aCBmb3IgdGhlIGN1cnJlbnQgbG9jYXRpb24sIGFzIHdlbGwgYXMgcHJvdmlkZXMgYSBzZXQgb2ZcbiAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgdXNlZCB0byBjaGFuZ2UgaXQuXG4gKlxuICogSXQgaXMgc2ltaWxhciB0byB0aGUgRE9NJ3MgYHdpbmRvdy5oaXN0b3J5YCBvYmplY3QsIGJ1dCB3aXRoIGEgc21hbGxlciwgbW9yZVxuICogZm9jdXNlZCBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeSB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBhY3Rpb24gdGhhdCBtb2RpZmllZCB0aGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyB3aWxsIGFsd2F5cyBiZVxuICAgKiBBY3Rpb24uUG9wIHdoZW4gYSBoaXN0b3J5IGluc3RhbmNlIGlzIGZpcnN0IGNyZWF0ZWQuIFRoaXMgdmFsdWUgaXMgbXV0YWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGFjdGlvbjogQWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsb2NhdGlvbi4gVGhpcyB2YWx1ZSBpcyBtdXRhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IExvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsaWQgaHJlZiBmb3IgdGhlIGdpdmVuIGB0b2AgdmFsdWUgdGhhdCBtYXkgYmUgdXNlZCBhc1xuICAgKiB0aGUgdmFsdWUgb2YgYW4gPGEgaHJlZj4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gICAqL1xuICBjcmVhdGVIcmVmKHRvOiBUbyk6IHN0cmluZztcblxuICAvKipcbiAgICogUmV0dXJucyBhIFVSTCBmb3IgdGhlIGdpdmVuIGB0b2AgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIFVSTFxuICAgKi9cbiAgY3JlYXRlVVJMKHRvOiBUbyk6IFVSTDtcblxuICAvKipcbiAgICogRW5jb2RlIGEgbG9jYXRpb24gdGhlIHNhbWUgd2F5IHdpbmRvdy5oaXN0b3J5IHdvdWxkIGRvIChuby1vcCBmb3IgbWVtb3J5XG4gICAqIGhpc3RvcnkpIHNvIHdlIGVuc3VyZSBvdXIgUFVTSC9SRVBMQUNFIG5hdmlnYXRpb25zIGZvciBkYXRhIHJvdXRlcnNcbiAgICogYmVoYXZlIHRoZSBzYW1lIGFzIFBPUFxuICAgKlxuICAgKiBAcGFyYW0gdG8gVW5lbmNvZGVkIHBhdGhcbiAgICovXG4gIGVuY29kZUxvY2F0aW9uKHRvOiBUbyk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIFB1c2hlcyBhIG5ldyBsb2NhdGlvbiBvbnRvIHRoZSBoaXN0b3J5IHN0YWNrLCBpbmNyZWFzaW5nIGl0cyBsZW5ndGggYnkgb25lLlxuICAgKiBJZiB0aGVyZSB3ZXJlIGFueSBlbnRyaWVzIGluIHRoZSBzdGFjayBhZnRlciB0aGUgY3VycmVudCBvbmUsIHRoZXkgYXJlXG4gICAqIGxvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB0byAtIFRoZSBuZXcgVVJMXG4gICAqIEBwYXJhbSBzdGF0ZSAtIERhdGEgdG8gYXNzb2NpYXRlIHdpdGggdGhlIG5ldyBsb2NhdGlvblxuICAgKi9cbiAgcHVzaCh0bzogVG8sIHN0YXRlPzogYW55KTogdm9pZDtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGhpc3Rvcnkgc3RhY2sgd2l0aCBhIG5ldyBvbmUuICBUaGVcbiAgICogbG9jYXRpb24gdGhhdCB3YXMgcmVwbGFjZWQgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gLSBUaGUgbmV3IFVSTFxuICAgKiBAcGFyYW0gc3RhdGUgLSBEYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbG9jYXRpb25cbiAgICovXG4gIHJlcGxhY2UodG86IFRvLCBzdGF0ZT86IGFueSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlcyBgbmAgZW50cmllcyBiYWNrd2FyZC9mb3J3YXJkIGluIHRoZSBoaXN0b3J5IHN0YWNrIHJlbGF0aXZlIHRvIHRoZVxuICAgKiBjdXJyZW50IGluZGV4LiBGb3IgZXhhbXBsZSwgYSBcImJhY2tcIiBuYXZpZ2F0aW9uIHdvdWxkIHVzZSBnbygtMSkuXG4gICAqXG4gICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkZWx0YSBpbiB0aGUgc3RhY2sgaW5kZXhcbiAgICovXG4gIGdvKGRlbHRhOiBudW1iZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgKiBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgKiBAcmV0dXJucyB1bmxpc3RlbiAtIEEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBzdG9wIGxpc3RlbmluZ1xuICAgKi9cbiAgbGlzdGVuKGxpc3RlbmVyOiBMaXN0ZW5lcik6ICgpID0+IHZvaWQ7XG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID0ge1xuICB1c3I6IGFueTtcbiAga2V5Pzogc3RyaW5nO1xuICBpZHg6IG51bWJlcjtcbn07XG5cbmNvbnN0IFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gTWVtb3J5IEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSB1c2VyLXN1cHBsaWVkIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGxvY2F0aW9uLiBVc2VkIHdoZW4gcHJvdmlkaW5nXG4gKiBlbnRyaWVzIHRvIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCB2aWEgaXRzIGBpbml0aWFsRW50cmllc2Agb3B0aW9uLlxuICovXG5leHBvcnQgdHlwZSBJbml0aWFsRW50cnkgPSBzdHJpbmcgfCBQYXJ0aWFsPExvY2F0aW9uPjtcblxuZXhwb3J0IHR5cGUgTWVtb3J5SGlzdG9yeU9wdGlvbnMgPSB7XG4gIGluaXRpYWxFbnRyaWVzPzogSW5pdGlhbEVudHJ5W107XG4gIGluaXRpYWxJbmRleD86IG51bWJlcjtcbiAgdjVDb21wYXQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBBIG1lbW9yeSBoaXN0b3J5IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LiBUaGlzIGlzIHVzZWZ1bCBpbiBzdGF0ZWZ1bFxuICogZW52aXJvbm1lbnRzIHdoZXJlIHRoZXJlIGlzIG5vIHdlYiBicm93c2VyLCBzdWNoIGFzIG5vZGUgdGVzdHMgb3IgUmVhY3RcbiAqIE5hdGl2ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlIaXN0b3J5IGV4dGVuZHMgSGlzdG9yeSB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIHJlYWRvbmx5IGluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoXG4gIG9wdGlvbnM6IE1lbW9yeUhpc3RvcnlPcHRpb25zID0ge31cbik6IE1lbW9yeUhpc3Rvcnkge1xuICBsZXQgeyBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sIGluaXRpYWxJbmRleCwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGVudHJpZXM6IExvY2F0aW9uW107IC8vIERlY2xhcmUgc28gd2UgY2FuIGFjY2VzcyBmcm9tIGNyZWF0ZU1lbW9yeUxvY2F0aW9uXG4gIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoKGVudHJ5LCBpbmRleCkgPT5cbiAgICBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICAgIGVudHJ5LFxuICAgICAgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLFxuICAgICAgaW5kZXggPT09IDAgPyBcImRlZmF1bHRcIiA6IHVuZGVmaW5lZFxuICAgIClcbiAgKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChcbiAgICBpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleFxuICApO1xuICBsZXQgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGNsYW1wSW5kZXgobjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TG9jYXRpb24oXG4gICAgdG86IFRvLFxuICAgIHN0YXRlOiBhbnkgPSBudWxsLFxuICAgIGtleT86IHN0cmluZ1xuICApOiBMb2NhdGlvbiB7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBlbnRyaWVzID8gZ2V0Q3VycmVudExvY2F0aW9uKCkucGF0aG5hbWUgOiBcIi9cIixcbiAgICAgIHRvLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXlcbiAgICApO1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9YFxuICAgICk7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bzogVG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5OiBNZW1vcnlIaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZixcbiAgICBjcmVhdGVVUkwodG8pIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bzogVG8pIHtcbiAgICAgIGxldCBwYXRoID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcbiAgICAgICAgc2VhcmNoOiBwYXRoLnNlYXJjaCB8fCBcIlwiLFxuICAgICAgICBoYXNoOiBwYXRoLmhhc2ggfHwgXCJcIixcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IG5leHRMb2NhdGlvbiwgZGVsdGE6IDAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyID0gZm47XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBCcm93c2VyIEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBicm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcyBpbiBhIHdlYlxuICogYnJvd3NlciBlbnZpcm9ubWVudC4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yIG1vc3Qgd2ViIGFwcHMgYW5kIHByb3ZpZGVzIHRoZVxuICogY2xlYW5lc3QgVVJMcyB0aGUgYnJvd3NlcidzIGFkZHJlc3MgYmFyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjYnJvd3Nlcmhpc3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCcm93c2VySGlzdG9yeSBleHRlbmRzIFVybEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgQnJvd3Nlckhpc3RvcnlPcHRpb25zID0gVXJsSGlzdG9yeU9wdGlvbnM7XG5cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShcbiAgb3B0aW9uczogQnJvd3Nlckhpc3RvcnlPcHRpb25zID0ge31cbik6IEJyb3dzZXJIaXN0b3J5IHtcbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckxvY2F0aW9uKFxuICAgIHdpbmRvdzogV2luZG93LFxuICAgIGdsb2JhbEhpc3Rvcnk6IFdpbmRvd1tcImhpc3RvcnlcIl1cbiAgKSB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgKGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IpIHx8IG51bGwsXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSkgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQnJvd3NlckhyZWYod2luZG93OiBXaW5kb3csIHRvOiBUbykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVCcm93c2VyTG9jYXRpb24sXG4gICAgY3JlYXRlQnJvd3NlckhyZWYsXG4gICAgbnVsbCxcbiAgICBvcHRpb25zXG4gICk7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIYXNoIEhpc3Rvcnlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBoYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIHBvcnRpb25cbiAqIG9mIHRoZSBVUkwgaW4gYSB3ZWIgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqXG4gKiBUaGlzIGlzIGlkZWFsIGZvciBhcHBzIHRoYXQgZG8gbm90IGNvbnRyb2wgdGhlIHNlcnZlciBmb3Igc29tZSByZWFzb25cbiAqIChiZWNhdXNlIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIGlzIG5ldmVyIHNlbnQgdG8gdGhlIHNlcnZlciksIGluY2x1ZGluZyBzb21lXG4gKiBzaGFyZWQgaG9zdGluZyBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgcHJvdmlkZSBmaW5lLWdyYWluZWQgY29udHJvbHMgb3ZlclxuICogd2hpY2ggcGFnZXMgYXJlIHNlcnZlZCBhdCB3aGljaCBVUkxzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjaGFzaGhpc3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYXNoSGlzdG9yeSBleHRlbmRzIFVybEhpc3Rvcnkge31cblxuZXhwb3J0IHR5cGUgSGFzaEhpc3RvcnlPcHRpb25zID0gVXJsSGlzdG9yeU9wdGlvbnM7XG5cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KFxuICBvcHRpb25zOiBIYXNoSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogSGFzaEhpc3Rvcnkge1xuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24oXG4gICAgd2luZG93OiBXaW5kb3csXG4gICAgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXVxuICApIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIixcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICAoZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzcikgfHwgbnVsbCxcbiAgICAgIChnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIYXNoSHJlZih3aW5kb3c6IFdpbmRvdywgdG86IFRvKSB7XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYgPSBcIlwiO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSB7XG4gICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICBsZXQgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVIYXNoTG9jYXRpb24obG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pIHtcbiAgICB3YXJuaW5nKFxuICAgICAgbG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIixcbiAgICAgIGByZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdG9cbiAgICAgICl9KWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVIYXNoTG9jYXRpb24sXG4gICAgY3JlYXRlSGFzaEhyZWYsXG4gICAgdmFsaWRhdGVIYXNoTG9jYXRpb24sXG4gICAgb3B0aW9uc1xuICApO1xufVxuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZTogYm9vbGVhbiwgbWVzc2FnZT86IHN0cmluZyk6IGFzc2VydHMgdmFsdWU7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50PFQ+KFxuICB2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQsXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbik6IGFzc2VydHMgdmFsdWUgaXMgVDtcbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQodmFsdWU6IGFueSwgbWVzc2FnZT86IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2FybmluZyhjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIGhpc3RvcnkhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuXG4vKipcbiAqIEZvciBicm93c2VyLWJhc2VkIGhpc3Rvcmllcywgd2UgY29tYmluZSB0aGUgc3RhdGUgYW5kIGtleSBpbnRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb246IExvY2F0aW9uLCBpbmRleDogbnVtYmVyKTogSGlzdG9yeVN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxuICAgIGtleTogbG9jYXRpb24ua2V5LFxuICAgIGlkeDogaW5kZXgsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihcbiAgY3VycmVudDogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHRvOiBUbyxcbiAgc3RhdGU6IGFueSA9IG51bGwsXG4gIGtleT86IHN0cmluZ1xuKTogUmVhZG9ubHk8TG9jYXRpb24+IHtcbiAgbGV0IGxvY2F0aW9uOiBSZWFkb25seTxMb2NhdGlvbj4gPSB7XG4gICAgcGF0aG5hbWU6IHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiID8gY3VycmVudCA6IGN1cnJlbnQucGF0aG5hbWUsXG4gICAgc2VhcmNoOiBcIlwiLFxuICAgIGhhc2g6IFwiXCIsXG4gICAgLi4uKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0byksXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogKHRvICYmICh0byBhcyBMb2NhdGlvbikua2V5KSB8fCBrZXkgfHwgY3JlYXRlS2V5KCksXG4gIH07XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCIsXG59OiBQYXJ0aWFsPFBhdGg+KSB7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIilcbiAgICBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSBcIiNcIilcbiAgICBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aDogc3RyaW5nKTogUGFydGlhbDxQYXRoPiB7XG4gIGxldCBwYXJzZWRQYXRoOiBQYXJ0aWFsPFBhdGg+ID0ge307XG5cbiAgaWYgKHBhdGgpIHtcbiAgICBsZXQgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICBsZXQgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVybEhpc3RvcnkgZXh0ZW5kcyBIaXN0b3J5IHt9XG5cbmV4cG9ydCB0eXBlIFVybEhpc3RvcnlPcHRpb25zID0ge1xuICB3aW5kb3c/OiBXaW5kb3c7XG4gIHY1Q29tcGF0PzogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShcbiAgZ2V0TG9jYXRpb246ICh3aW5kb3c6IFdpbmRvdywgZ2xvYmFsSGlzdG9yeTogV2luZG93W1wiaGlzdG9yeVwiXSkgPT4gTG9jYXRpb24sXG4gIGNyZWF0ZUhyZWY6ICh3aW5kb3c6IFdpbmRvdywgdG86IFRvKSA9PiBzdHJpbmcsXG4gIHZhbGlkYXRlTG9jYXRpb246ICgobG9jYXRpb246IExvY2F0aW9uLCB0bzogVG8pID0+IHZvaWQpIHwgbnVsbCxcbiAgb3B0aW9uczogVXJsSGlzdG9yeU9wdGlvbnMgPSB7fVxuKTogVXJsSGlzdG9yeSB7XG4gIGxldCB7IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ISwgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lcjogTGlzdGVuZXIgfCBudWxsID0gbnVsbDtcblxuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpITtcbiAgLy8gSW5kZXggc2hvdWxkIG9ubHkgYmUgbnVsbCB3aGVuIHdlIGluaXRpYWxpemUuIElmIG5vdCwgaXQncyBiZWNhdXNlIHRoZVxuICAvLyB1c2VyIGNhbGxlZCBoaXN0b3J5LnB1c2hTdGF0ZSBvciBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBkaXJlY3RseSwgaW4gd2hpY2hcbiAgLy8gY2FzZSB3ZSBzaG91bGQgbG9nIGEgd2FybmluZyBhcyBpdCB3aWxsIHJlc3VsdCBpbiBidWdzLlxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IC4uLmdsb2JhbEhpc3Rvcnkuc3RhdGUsIGlkeDogaW5kZXggfSwgXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbmRleCgpOiBudW1iZXIge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG86IFRvLCBzdGF0ZT86IGFueSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcblxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvOiBUbywgc3RhdGU/OiBhbnkpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG5cbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcblxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG86IFRvKTogVVJMIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPVxuICAgICAgd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCJcbiAgICAgICAgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgICAgIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaW52YXJpYW50KFxuICAgICAgYmFzZSxcbiAgICAgIGBObyB3aW5kb3cubG9jYXRpb24uKG9yaWdpbnxocmVmKSBhdmFpbGFibGUgdG8gY3JlYXRlIFVSTCBmb3IgaHJlZjogJHtocmVmfWBcbiAgICApO1xuICAgIHJldHVybiBuZXcgVVJMKGhyZWYsIGJhc2UpO1xuICB9XG5cbiAgbGV0IGhpc3Rvcnk6IEhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3RlbihmbjogTGlzdGVuZXIpIHtcbiAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGhpc3Rvcnkgb25seSBhY2NlcHRzIG9uZSBhY3RpdmUgbGlzdGVuZXJcIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgIGxpc3RlbmVyID0gZm47XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaCxcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoLFxuICAgIHJlcGxhY2UsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuLy8jZW5kcmVnaW9uXG4iLCJpbXBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCIuL2hpc3RvcnlcIjtcbmltcG9ydCB7IHdhcm5pbmcsIGludmFyaWFudCwgcGFyc2VQYXRoIH0gZnJvbSBcIi4vaGlzdG9yeVwiO1xuXG4vKipcbiAqIE1hcCBvZiByb3V0ZUlkIC0+IGRhdGEgcmV0dXJuZWQgZnJvbSBhIGxvYWRlci9hY3Rpb24vZXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZURhdGEge1xuICBbcm91dGVJZDogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgZW51bSBSZXN1bHRUeXBlIHtcbiAgZGF0YSA9IFwiZGF0YVwiLFxuICBkZWZlcnJlZCA9IFwiZGVmZXJyZWRcIixcbiAgcmVkaXJlY3QgPSBcInJlZGlyZWN0XCIsXG4gIGVycm9yID0gXCJlcnJvclwiLFxufVxuXG4vKipcbiAqIFN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3VjY2Vzc1Jlc3VsdCB7XG4gIHR5cGU6IFJlc3VsdFR5cGUuZGF0YTtcbiAgZGF0YTogYW55O1xuICBzdGF0dXNDb2RlPzogbnVtYmVyO1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBTdWNjZXNzZnVsIGRlZmVyKCkgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVmZXJyZWRSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkO1xuICBkZWZlcnJlZERhdGE6IERlZmVycmVkRGF0YTtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgaGVhZGVycz86IEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVkaXJlY3QgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVkaXJlY3RSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0O1xuICBzdGF0dXM6IG51bWJlcjtcbiAgbG9jYXRpb246IHN0cmluZztcbiAgcmV2YWxpZGF0ZTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBVbnN1Y2Nlc3NmdWwgcmVzdWx0IGZyb20gYSBsb2FkZXIgb3IgYWN0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JSZXN1bHQge1xuICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yO1xuICBlcnJvcjogYW55O1xuICBoZWFkZXJzPzogSGVhZGVycztcbn1cblxuLyoqXG4gKiBSZXN1bHQgZnJvbSBhIGxvYWRlciBvciBhY3Rpb24gLSBwb3RlbnRpYWxseSBzdWNjZXNzZnVsIG9yIHVuc3VjY2Vzc2Z1bFxuICovXG5leHBvcnQgdHlwZSBEYXRhUmVzdWx0ID1cbiAgfCBTdWNjZXNzUmVzdWx0XG4gIHwgRGVmZXJyZWRSZXN1bHRcbiAgfCBSZWRpcmVjdFJlc3VsdFxuICB8IEVycm9yUmVzdWx0O1xuXG50eXBlIExvd2VyQ2FzZUZvcm1NZXRob2QgPSBcImdldFwiIHwgXCJwb3N0XCIgfCBcInB1dFwiIHwgXCJwYXRjaFwiIHwgXCJkZWxldGVcIjtcbnR5cGUgVXBwZXJDYXNlRm9ybU1ldGhvZCA9IFVwcGVyY2FzZTxMb3dlckNhc2VGb3JtTWV0aG9kPjtcblxuLyoqXG4gKiBVc2VycyBjYW4gc3BlY2lmeSBlaXRoZXIgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZSBmb3JtIG1ldGhvZHMgb24gPEZvcm0+LFxuICogdXNlU3VibWl0KCksIDxmZXRjaGVyLkZvcm0+LCBldGMuXG4gKi9cbmV4cG9ydCB0eXBlIEhUTUxGb3JtTWV0aG9kID0gTG93ZXJDYXNlRm9ybU1ldGhvZCB8IFVwcGVyQ2FzZUZvcm1NZXRob2Q7XG5cbi8qKlxuICogQWN0aXZlIG5hdmlnYXRpb24vZmV0Y2hlciBmb3JtIG1ldGhvZHMgYXJlIGV4cG9zZWQgaW4gbG93ZXJjYXNlIG9uIHRoZVxuICogUm91dGVyU3RhdGVcbiAqL1xuZXhwb3J0IHR5cGUgRm9ybU1ldGhvZCA9IExvd2VyQ2FzZUZvcm1NZXRob2Q7XG5leHBvcnQgdHlwZSBNdXRhdGlvbkZvcm1NZXRob2QgPSBFeGNsdWRlPEZvcm1NZXRob2QsIFwiZ2V0XCI+O1xuXG4vKipcbiAqIEluIHY3LCBhY3RpdmUgbmF2aWdhdGlvbi9mZXRjaGVyIGZvcm0gbWV0aG9kcyBhcmUgZXhwb3NlZCBpbiB1cHBlcmNhc2Ugb24gdGhlXG4gKiBSb3V0ZXJTdGF0ZS4gIFRoaXMgaXMgdG8gYWxpZ24gd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBkb25lIHZpYSBmZXRjaCgpLlxuICovXG5leHBvcnQgdHlwZSBWN19Gb3JtTWV0aG9kID0gVXBwZXJDYXNlRm9ybU1ldGhvZDtcbmV4cG9ydCB0eXBlIFY3X011dGF0aW9uRm9ybU1ldGhvZCA9IEV4Y2x1ZGU8VjdfRm9ybU1ldGhvZCwgXCJHRVRcIj47XG5cbmV4cG9ydCB0eXBlIEZvcm1FbmNUeXBlID1cbiAgfCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gIHwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEludGVybmFsIGludGVyZmFjZSB0byBwYXNzIGFyb3VuZCBmb3IgYWN0aW9uIHN1Ym1pc3Npb25zLCBub3QgaW50ZW5kZWQgZm9yXG4gKiBleHRlcm5hbCBjb25zdW1wdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pc3Npb24ge1xuICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZDtcbiAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gIGZvcm1EYXRhOiBGb3JtRGF0YTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQXJndW1lbnRzIHBhc3NlZCB0byByb3V0ZSBsb2FkZXIvYWN0aW9uIGZ1bmN0aW9ucy4gIFNhbWUgZm9yIG5vdyBidXQgd2Uga2VlcFxuICogdGhpcyBhcyBhIHByaXZhdGUgaW1wbGVtZW50YXRpb24gZGV0YWlsIGluIGNhc2UgdGhleSBkaXZlcmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmludGVyZmFjZSBEYXRhRnVuY3Rpb25BcmdzIHtcbiAgcmVxdWVzdDogUmVxdWVzdDtcbiAgcGFyYW1zOiBQYXJhbXM7XG4gIGNvbnRleHQ/OiBhbnk7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIHBhc3NlZCB0byBsb2FkZXIgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb25BcmdzIGV4dGVuZHMgRGF0YUZ1bmN0aW9uQXJncyB7fVxuXG4vKipcbiAqIEFyZ3VtZW50cyBwYXNzZWQgdG8gYWN0aW9uIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkZ1bmN0aW9uQXJncyBleHRlbmRzIERhdGFGdW5jdGlvbkFyZ3Mge31cblxuLyoqXG4gKiBSb3V0ZSBsb2FkZXIgZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyRnVuY3Rpb24ge1xuICAoYXJnczogTG9hZGVyRnVuY3Rpb25BcmdzKTogUHJvbWlzZTxSZXNwb25zZT4gfCBSZXNwb25zZSB8IFByb21pc2U8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBhY3Rpb24gZnVuY3Rpb24gc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uRnVuY3Rpb24ge1xuICAoYXJnczogQWN0aW9uRnVuY3Rpb25BcmdzKTogUHJvbWlzZTxSZXNwb25zZT4gfCBSZXNwb25zZSB8IFByb21pc2U8YW55PiB8IGFueTtcbn1cblxuLyoqXG4gKiBSb3V0ZSBzaG91bGRSZXZhbGlkYXRlIGZ1bmN0aW9uIHNpZ25hdHVyZS4gIFRoaXMgcnVucyBhZnRlciBhbnkgc3VibWlzc2lvblxuICogKG5hdmlnYXRpb24gb3IgZmV0Y2hlciksIHNvIHdlIGZsYXR0ZW4gdGhlIG5hdmlnYXRpb24vZmV0Y2hlciBzdWJtaXNzaW9uXG4gKiBvbnRvIHRoZSBhcmd1bWVudHMuICBJdCBzaG91bGRuJ3QgbWF0dGVyIHdoZXRoZXIgaXQgY2FtZSBmcm9tIGEgbmF2aWdhdGlvblxuICogb3IgYSBmZXRjaGVyLCB3aGF0IHJlYWxseSBtYXR0ZXJzIGlzIHRoZSBVUkxzIGFuZCB0aGUgZm9ybURhdGEgc2luY2UgbG9hZGVyc1xuICogaGF2ZSB0byByZS1ydW4gYmFzZWQgb24gdGhlIGRhdGEgbW9kZWxzIHRoYXQgd2VyZSBwb3RlbnRpYWxseSBtdXRhdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbiB7XG4gIChhcmdzOiB7XG4gICAgY3VycmVudFVybDogVVJMO1xuICAgIGN1cnJlbnRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gICAgbmV4dFVybDogVVJMO1xuICAgIG5leHRQYXJhbXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXCJwYXJhbXNcIl07XG4gICAgZm9ybU1ldGhvZD86IFN1Ym1pc3Npb25bXCJmb3JtTWV0aG9kXCJdO1xuICAgIGZvcm1BY3Rpb24/OiBTdWJtaXNzaW9uW1wiZm9ybUFjdGlvblwiXTtcbiAgICBmb3JtRW5jVHlwZT86IFN1Ym1pc3Npb25bXCJmb3JtRW5jVHlwZVwiXTtcbiAgICBmb3JtRGF0YT86IFN1Ym1pc3Npb25bXCJmb3JtRGF0YVwiXTtcbiAgICBhY3Rpb25SZXN1bHQ/OiBEYXRhUmVzdWx0O1xuICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBib29sZWFuO1xuICB9KTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgZnJhbWV3b3JrLWF3YXJlIGxheWVycyB0byBzZXQgYGhhc0Vycm9yQm91bmRhcnlgXG4gKiBmcm9tIHRoZSBmcmFtZXdvcmstYXdhcmUgYGVycm9yRWxlbWVudGAgcHJvcFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbiB7XG4gIChyb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdCk6IGJvb2xlYW47XG59XG5cbi8qKlxuICogS2V5cyB3ZSBjYW5ub3QgY2hhbmdlIGZyb20gd2l0aGluIGEgbGF6eSgpIGZ1bmN0aW9uLiBXZSBzcHJlYWQgYWxsIG90aGVyIGtleXNcbiAqIG9udG8gdGhlIHJvdXRlLiBFaXRoZXIgdGhleSdyZSBtZWFuaW5nZnVsIHRvIHRoZSByb3V0ZXIsIG9yIHRoZXknbGwgZ2V0XG4gKiBpZ25vcmVkLlxuICovXG5leHBvcnQgdHlwZSBJbW11dGFibGVSb3V0ZUtleSA9XG4gIHwgXCJsYXp5XCJcbiAgfCBcImNhc2VTZW5zaXRpdmVcIlxuICB8IFwicGF0aFwiXG4gIHwgXCJpZFwiXG4gIHwgXCJpbmRleFwiXG4gIHwgXCJjaGlsZHJlblwiO1xuXG5leHBvcnQgY29uc3QgaW1tdXRhYmxlUm91dGVLZXlzID0gbmV3IFNldDxJbW11dGFibGVSb3V0ZUtleT4oW1xuICBcImxhenlcIixcbiAgXCJjYXNlU2Vuc2l0aXZlXCIsXG4gIFwicGF0aFwiLFxuICBcImlkXCIsXG4gIFwiaW5kZXhcIixcbiAgXCJjaGlsZHJlblwiLFxuXSk7XG5cbi8qKlxuICogbGF6eSgpIGZ1bmN0aW9uIHRvIGxvYWQgYSByb3V0ZSBkZWZpbml0aW9uLCB3aGljaCBjYW4gYWRkIG5vbi1tYXRjaGluZ1xuICogcmVsYXRlZCBwcm9wZXJ0aWVzIHRvIGEgcm91dGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMYXp5Um91dGVGdW5jdGlvbjxSIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdD4ge1xuICAoKTogUHJvbWlzZTxPbWl0PFIsIEltbXV0YWJsZVJvdXRlS2V5Pj47XG59XG5cbi8qKlxuICogQmFzZSBSb3V0ZU9iamVjdCB3aXRoIGNvbW1vbiBwcm9wcyBzaGFyZWQgYnkgYWxsIHR5cGVzIG9mIHJvdXRlc1xuICovXG50eXBlIEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ID0ge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbiAgaWQ/OiBzdHJpbmc7XG4gIGxvYWRlcj86IExvYWRlckZ1bmN0aW9uO1xuICBhY3Rpb24/OiBBY3Rpb25GdW5jdGlvbjtcbiAgaGFzRXJyb3JCb3VuZGFyeT86IGJvb2xlYW47XG4gIHNob3VsZFJldmFsaWRhdGU/OiBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb247XG4gIGhhbmRsZT86IGFueTtcbiAgbGF6eT86IExhenlSb3V0ZUZ1bmN0aW9uPEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0Pjtcbn07XG5cbi8qKlxuICogSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0ID0gQWdub3N0aWNCYXNlUm91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogdW5kZWZpbmVkO1xuICBpbmRleDogdHJ1ZTtcbn07XG5cbi8qKlxuICogTm9uLWluZGV4IHJvdXRlcyBtYXkgaGF2ZSBjaGlsZHJlbiwgYnV0IGNhbm5vdCBoYXZlIGluZGV4XG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljQmFzZVJvdXRlT2JqZWN0ICYge1xuICBjaGlsZHJlbj86IEFnbm9zdGljUm91dGVPYmplY3RbXTtcbiAgaW5kZXg/OiBmYWxzZTtcbn07XG5cbi8qKlxuICogQSByb3V0ZSBvYmplY3QgcmVwcmVzZW50cyBhIGxvZ2ljYWwgcm91dGUsIHdpdGggKG9wdGlvbmFsbHkpIGl0cyBjaGlsZFxuICogcm91dGVzIG9yZ2FuaXplZCBpbiBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCB0eXBlIEFnbm9zdGljUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdFxuICB8IEFnbm9zdGljTm9uSW5kZXhSb3V0ZU9iamVjdDtcblxuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IEFnbm9zdGljSW5kZXhSb3V0ZU9iamVjdCAmIHtcbiAgaWQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEFnbm9zdGljRGF0YU5vbkluZGV4Um91dGVPYmplY3QgPSBBZ25vc3RpY05vbkluZGV4Um91dGVPYmplY3QgJiB7XG4gIGNoaWxkcmVuPzogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgaWQ6IHN0cmluZztcbn07XG5cbi8qKlxuICogQSBkYXRhIHJvdXRlIG9iamVjdCwgd2hpY2ggaXMganVzdCBhIFJvdXRlT2JqZWN0IHdpdGggYSByZXF1aXJlZCB1bmlxdWUgSURcbiAqL1xuZXhwb3J0IHR5cGUgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgPVxuICB8IEFnbm9zdGljRGF0YUluZGV4Um91dGVPYmplY3RcbiAgfCBBZ25vc3RpY0RhdGFOb25JbmRleFJvdXRlT2JqZWN0O1xuXG5leHBvcnQgdHlwZSBSb3V0ZU1hbmlmZXN0ID0gUmVjb3JkPHN0cmluZywgQWdub3N0aWNEYXRhUm91dGVPYmplY3QgfCB1bmRlZmluZWQ+O1xuXG4vLyBSZWN1cnNpdmUgaGVscGVyIGZvciBmaW5kaW5nIHBhdGggcGFyYW1ldGVycyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbnR5cGUgX1BhdGhQYXJhbTxQYXRoIGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIHNwbGl0IHBhdGggaW50byBpbmRpdmlkdWFsIHBhdGggc2VnbWVudHNcbiAgUGF0aCBleHRlbmRzIGAke2luZmVyIEx9LyR7aW5mZXIgUn1gXG4gICAgPyBfUGF0aFBhcmFtPEw+IHwgX1BhdGhQYXJhbTxSPlxuICAgIDogLy8gZmluZCBwYXJhbXMgYWZ0ZXIgYDpgXG4gICAgUGF0aCBleHRlbmRzIGA6JHtpbmZlciBQYXJhbX1gXG4gICAgPyBQYXJhbSBleHRlbmRzIGAke2luZmVyIE9wdGlvbmFsfT9gXG4gICAgICA/IE9wdGlvbmFsXG4gICAgICA6IFBhcmFtXG4gICAgOiAvLyBvdGhlcndpc2UsIHRoZXJlIGFyZW4ndCBhbnkgcGFyYW1zIHByZXNlbnRcbiAgICAgIG5ldmVyO1xuXG4vKipcbiAqIEV4YW1wbGVzOlxuICogXCIvYS9iLypcIiAtPiBcIipcIlxuICogXCI6YVwiIC0+IFwiYVwiXG4gKiBcIi9hLzpiXCIgLT4gXCJiXCJcbiAqIFwiL2EvYmxhaGJsYWhibGFoOmJcIiAtPiBcImJcIlxuICogXCIvOmEvOmJcIiAtPiBcImFcIiB8IFwiYlwiXG4gKiBcIi86YS9iLzpjLypcIiAtPiBcImFcIiB8IFwiY1wiIHwgXCIqXCJcbiAqL1xudHlwZSBQYXRoUGFyYW08UGF0aCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBjaGVjayBpZiBwYXRoIGlzIGp1c3QgYSB3aWxkY2FyZFxuICBQYXRoIGV4dGVuZHMgXCIqXCIgfCBcIi8qXCJcbiAgICA/IFwiKlwiXG4gICAgOiAvLyBsb29rIGZvciB3aWxkY2FyZCBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoXG4gICAgUGF0aCBleHRlbmRzIGAke2luZmVyIFJlc3R9LypgXG4gICAgPyBcIipcIiB8IF9QYXRoUGFyYW08UmVzdD5cbiAgICA6IC8vIGxvb2sgZm9yIHBhcmFtcyBpbiB0aGUgYWJzZW5jZSBvZiB3aWxkY2FyZHNcbiAgICAgIF9QYXRoUGFyYW08UGF0aD47XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxuZXhwb3J0IHR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIC8vIGlmIGNvdWxkIG5vdCBmaW5kIHBhdGggcGFyYW1zLCBmYWxsYmFjayB0byBgc3RyaW5nYFxuICBbUGF0aFBhcmFtPFNlZ21lbnQ+XSBleHRlbmRzIFtuZXZlcl0gPyBzdHJpbmcgOiBQYXRoUGFyYW08U2VnbWVudD47XG5cbi8qKlxuICogVGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhcnNlZCBmcm9tIHRoZSBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyYW1zPEtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtrZXkgaW4gS2V5XTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBIFJvdXRlTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSByb3V0ZSBtYXRjaGVkIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFnbm9zdGljUm91dGVNYXRjaDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsXG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcm91dGUgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICByb3V0ZTogUm91dGVPYmplY3RUeXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hcbiAgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlTWF0Y2g8c3RyaW5nLCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdD4ge31cblxuZnVuY3Rpb24gaXNJbmRleFJvdXRlKFxuICByb3V0ZTogQWdub3N0aWNSb3V0ZU9iamVjdFxuKTogcm91dGUgaXMgQWdub3N0aWNJbmRleFJvdXRlT2JqZWN0IHtcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xufVxuXG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3Nhcnkgc28gd2UgYXJlIHdvcmtpbmdcbi8vIHNvbGVseSB3aXRoIEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0J3Mgd2l0aGluIHRoZSBSb3V0ZXJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgZGV0ZWN0RXJyb3JCb3VuZGFyeTogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uLFxuICBwYXJlbnRQYXRoOiBudW1iZXJbXSA9IFtdLFxuICBtYW5pZmVzdDogUm91dGVNYW5pZmVzdCA9IHt9XG4pOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgbGV0IGlkID0gdHlwZW9mIHJvdXRlLmlkID09PSBcInN0cmluZ1wiID8gcm91dGUuaWQgOiB0cmVlUGF0aC5qb2luKFwiLVwiKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sXG4gICAgICBgQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVgXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhbWFuaWZlc3RbaWRdLFxuICAgICAgYEZvdW5kIGEgcm91dGUgaWQgY29sbGlzaW9uIG9uIGlkIFwiJHtpZH1cIi4gIFJvdXRlIGAgK1xuICAgICAgICBcImlkJ3MgbXVzdCBiZSBnbG9iYWxseSB1bmlxdWUgd2l0aGluIERhdGEgUm91dGVyIHVzYWdlc1wiXG4gICAgKTtcblxuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZTogQWdub3N0aWNEYXRhSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpLFxuICAgICAgICBpZCxcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZTogQWdub3N0aWNEYXRhTm9uSW5kZXhSb3V0ZU9iamVjdCA9IHtcbiAgICAgICAgLi4ucm91dGUsXG4gICAgICAgIGlkLFxuICAgICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKSxcbiAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcblxuICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgIHBhdGhPckxheW91dFJvdXRlLmNoaWxkcmVuID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICAgICAgICByb3V0ZS5jaGlsZHJlbixcbiAgICAgICAgICBkZXRlY3RFcnJvckJvdW5kYXJ5LFxuICAgICAgICAgIHRyZWVQYXRoLFxuICAgICAgICAgIG1hbmlmZXN0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlczxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIHJvdXRlczogUm91dGVPYmplY3RUeXBlW10sXG4gIGxvY2F0aW9uQXJnOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZyxcbiAgYmFzZW5hbWUgPSBcIi9cIlxuKTogQWdub3N0aWNSb3V0ZU1hdGNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPltdIHwgbnVsbCB7XG4gIGxldCBsb2NhdGlvbiA9XG4gICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG5cbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoPHN0cmluZywgUm91dGVPYmplY3RUeXBlPihcbiAgICAgIGJyYW5jaGVzW2ldLFxuICAgICAgLy8gSW5jb21pbmcgcGF0aG5hbWVzIGFyZSBnZW5lcmFsbHkgZW5jb2RlZCBmcm9tIGVpdGhlciB3aW5kb3cubG9jYXRpb25cbiAgICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAgIC8vIHBhdGhzIGluIHRoZSByb3V0ZSBkZWZpbml0aW9ucy4gIE1lbW9yeSByb3V0ZXIgbG9jYXRpb25zIHdvbid0IGJlXG4gICAgICAvLyBlbmNvZGVkIGhlcmUgYnV0IHRoZXJlIGFsc28gc2hvdWxkbid0IGJlIGFueXRoaW5nIHRvIGRlY29kZSBzbyB0aGlzXG4gICAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAgIC8vIGhpc3RvcnktYXdhcmUuXG4gICAgICBzYWZlbHlEZWNvZGVVUkkocGF0aG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5pbnRlcmZhY2UgUm91dGVNZXRhPFxuICBSb3V0ZU9iamVjdFR5cGUgZXh0ZW5kcyBBZ25vc3RpY1JvdXRlT2JqZWN0ID0gQWdub3N0aWNSb3V0ZU9iamVjdFxuPiB7XG4gIHJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuO1xuICBjaGlsZHJlbkluZGV4OiBudW1iZXI7XG4gIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGU7XG59XG5cbmludGVyZmFjZSBSb3V0ZUJyYW5jaDxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4ge1xuICBwYXRoOiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHJvdXRlc01ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+W107XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXM8XG4gIFJvdXRlT2JqZWN0VHlwZSBleHRlbmRzIEFnbm9zdGljUm91dGVPYmplY3QgPSBBZ25vc3RpY1JvdXRlT2JqZWN0XG4+KFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0VHlwZVtdLFxuICBicmFuY2hlczogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPltdID0gW10sXG4gIHBhcmVudHNNZXRhOiBSb3V0ZU1ldGE8Um91dGVPYmplY3RUeXBlPltdID0gW10sXG4gIHBhcmVudFBhdGggPSBcIlwiXG4pOiBSb3V0ZUJyYW5jaDxSb3V0ZU9iamVjdFR5cGU+W10ge1xuICBsZXQgZmxhdHRlblJvdXRlID0gKFxuICAgIHJvdXRlOiBSb3V0ZU9iamVjdFR5cGUsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICByZWxhdGl2ZVBhdGg/OiBzdHJpbmdcbiAgKSA9PiB7XG4gICAgbGV0IG1ldGE6IFJvdXRlTWV0YTxSb3V0ZU9iamVjdFR5cGU+ID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOlxuICAgICAgICByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlLFxuICAgIH07XG5cbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIGAgK1xuICAgICAgICAgIGBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggYCArXG4gICAgICAgICAgYG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcblxuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG5cbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXkgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgLy8gT3VyIHR5cGVzIGtub3cgYmV0dGVyLCBidXQgcnVudGltZSBKUyBtYXkgbm90IVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLFxuICAgICAgICBgSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIGAgK1xuICAgICAgICAgIGBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuXG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XG4gICAgfVxuXG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJyYW5jaGVzLnB1c2goe1xuICAgICAgcGF0aCxcbiAgICAgIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLFxuICAgICAgcm91dGVzTWV0YSxcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIC8vIGNvYXJzZS1ncmFpbiBjaGVjayBmb3Igb3B0aW9uYWwgcGFyYW1zXG4gICAgaWYgKHJvdXRlLnBhdGggPT09IFwiXCIgfHwgIXJvdXRlLnBhdGg/LmluY2x1ZGVzKFwiP1wiKSkge1xuICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGV4cGxvZGVkIG9mIGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgsIGV4cGxvZGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbGwgY29tYmluYXRpb25zIG9mIG9wdGlvbmFsIHBhdGggc2VnbWVudHMgZm9yIGEgZ2l2ZW4gcGF0aCxcbiAqIGV4Y2x1ZGluZyBjb21iaW5hdGlvbnMgdGhhdCBhcmUgYW1iaWd1b3VzIGFuZCBvZiBsb3dlciBwcmlvcml0eS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYC9vbmUvOnR3bz8vdGhyZWUvOmZvdXI/LzpmaXZlP2AgZXhwbG9kZXMgdG86XG4gKiAtIGAvb25lL3RocmVlYFxuICogLSBgL29uZS86dHdvL3RocmVlYFxuICogLSBgL29uZS90aHJlZS86Zm91cmBcbiAqIC0gYC9vbmUvdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZpdmVgXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyLzpmaXZlYFxuICovXG5mdW5jdGlvbiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgbGV0IFtmaXJzdCwgLi4ucmVzdF0gPSBzZWdtZW50cztcblxuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG5cbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSW50ZXByZXQgZW1wdHkgc3RyaW5nIGFzIG9taXR0aW5nIGFuIG9wdGlvbmFsIHNlZ21lbnRcbiAgICAvLyBgW1wib25lXCIsIFwiXCIsIFwidGhyZWVcIl1gIGNvcnJlc3BvbmRzIHRvIG9taXR0aW5nIGA6dHdvYCBmcm9tIGAvb25lLzp0d28/L3RocmVlYCAtPiBgL29uZS90aHJlZWBcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG5cbiAgbGV0IHJlc3RFeHBsb2RlZCA9IGV4cGxvZGVPcHRpb25hbFNlZ21lbnRzKHJlc3Quam9pbihcIi9cIikpO1xuXG4gIGxldCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiBzbyB3ZSBnZXQgY29uc2lzdGVudCBvcmRlcmluZyB3aGVyZSB0aGVcbiAgLy8gcGFyZW50IG9wdGlvbmFsIGFzcGVjdCBpcyBwcmVmZXJyZWQgYXMgcmVxdWlyZWQuICBPdGhlcndpc2UsIHdlIGNhbiBnZXRcbiAgLy8gY2hpbGQgc2VjdGlvbnMgaW50ZXJzcGVyc2VkIHdoZXJlIGRlZXBlciBvcHRpb25hbCBzZWdtZW50cyBhcmUgaGlnaGVyIHRoYW5cbiAgLy8gcGFyZW50IG9wdGlvbmFsIHNlZ21lbnRzLCB3aGVyZSBmb3IgZXhhbXBsZSwgLzp0d28gd291bGQgZXhwbG9kZXMgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKFxuICAgIC4uLnJlc3RFeHBsb2RlZC5tYXAoKHN1YnBhdGgpID0+XG4gICAgICBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpXG4gICAgKVxuICApO1xuXG4gIC8vIFRoZW4gaWYgdGhpcyBpcyBhbiBvcHRpb25hbCB2YWx1ZSwgYWRkIGFsbCBjaGlsZCB2ZXJzaW9ucyB3aXRob3V0XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuXG4gIC8vIGZvciBhYnNvbHV0ZSBwYXRocywgZW5zdXJlIGAvYCBpbnN0ZWFkIG9mIGVtcHR5IHNlZ21lbnRcbiAgcmV0dXJuIHJlc3VsdC5tYXAoKGV4cGxvZGVkKSA9PlxuICAgIHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgICAgIClcbiAgKTtcbn1cblxuY29uc3QgcGFyYW1SZSA9IC9eOlxcdyskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gKHM6IHN0cmluZykgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoOiBzdHJpbmcsIGluZGV4OiBib29sZWFuIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbiAgICAuZmlsdGVyKChzKSA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFxuICBQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgUm91dGVPYmplY3RUeXBlIGV4dGVuZHMgQWdub3N0aWNSb3V0ZU9iamVjdCA9IEFnbm9zdGljUm91dGVPYmplY3Rcbj4oXG4gIGJyYW5jaDogUm91dGVCcmFuY2g8Um91dGVPYmplY3RUeXBlPixcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogQWdub3N0aWNSb3V0ZU1hdGNoPFBhcmFtS2V5LCBSb3V0ZU9iamVjdFR5cGU+W10gfCBudWxsIHtcbiAgbGV0IHsgcm91dGVzTWV0YSB9ID0gYnJhbmNoO1xuXG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXM6IEFnbm9zdGljUm91dGVNYXRjaDxQYXJhbUtleSwgUm91dGVPYmplY3RUeXBlPltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIC8vIFRPRE86IENhbiB0aGlzIGFzIGJlIGF2b2lkZWQ/XG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMgYXMgUGFyYW1zPFBhcmFtS2V5PixcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlLFxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9nZW5lcmF0ZS1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhdGg8UGF0aCBleHRlbmRzIHN0cmluZz4oXG4gIG9yaWdpbmFsUGF0aDogUGF0aCxcbiAgcGFyYW1zOiB7XG4gICAgW2tleSBpbiBQYXRoUGFyYW08UGF0aD5dOiBzdHJpbmcgfCBudWxsO1xuICB9ID0ge30gYXMgYW55XG4pOiBzdHJpbmcge1xuICBsZXQgcGF0aDogc3RyaW5nID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgICBgXCIke3BhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIil9XCIgYmVjYXVzZSB0aGUgXFxgKlxcYCBjaGFyYWN0ZXIgbXVzdCBgICtcbiAgICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgICApO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpIGFzIFBhdGg7XG4gIH1cblxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcblxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhcbiAgICAuc3BsaXQoL1xcLysvKVxuICAgIC5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xuXG4gICAgICAvLyBvbmx5IGFwcGx5IHRoZSBzcGxhdCBpZiBpdCdzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgIGlmIChpc0xhc3RTZWdtZW50ICYmIHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBcIipcIiBhcyBQYXRoUGFyYW08UGF0aD47XG4gICAgICAgIGNvbnN0IHN0YXJQYXJhbSA9IHBhcmFtc1tzdGFyXTtcblxuICAgICAgICAvLyBBcHBseSB0aGUgc3BsYXRcbiAgICAgICAgcmV0dXJuIHN0YXJQYXJhbTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5TWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihcXHcrKShcXD8/KSQvKTtcbiAgICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgICBsZXQgcGFyYW0gPSBwYXJhbXNba2V5IGFzIFBhdGhQYXJhbTxQYXRoPl07XG5cbiAgICAgICAgaWYgKG9wdGlvbmFsID09PSBcIj9cIikge1xuICAgICAgICAgIHJldHVybiBwYXJhbSA9PSBudWxsID8gXCJcIiA6IHBhcmFtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgICAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvXFw/JC9nLCBcIlwiKTtcbiAgICB9KVxuICAgIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHNlZ21lbnQpID0+ICEhc2VnbWVudCk7XG5cbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFBhdGg8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihcbiAgcGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuXG4gIGxldCBbbWF0Y2hlciwgcGFyYW1OYW1lc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG5cbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXM6IFBhcmFtcyA9IHBhcmFtTmFtZXMucmVkdWNlPE11dGFibGU8UGFyYW1zPj4oXG4gICAgKG1lbW8sIHBhcmFtTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aClcbiAgICAgICAgICAucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsXG4gICAgICAgIHBhcmFtTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21waWxlUGF0aChcbiAgcGF0aDogc3RyaW5nLFxuICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gIGVuZCA9IHRydWVcbik6IFtSZWdFeHAsIHN0cmluZ1tdXSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBgICtcbiAgICAgIGBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGAgK1xuICAgICAgYGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYCArXG4gICAgICBgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG5cbiAgbGV0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCByZWdleHBTb3VyY2UgPVxuICAgIFwiXlwiICtcbiAgICBwYXRoXG4gICAgICAucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcbiAgICAgIC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKSAvLyBNYWtlIHN1cmUgaXQgaGFzIGEgbGVhZGluZyAvXG4gICAgICAucmVwbGFjZSgvW1xcXFwuKiteJD97fXwoKVtcXF1dL2csIFwiXFxcXCQmXCIpIC8vIEVzY2FwZSBzcGVjaWFsIHJlZ2V4IGNoYXJzXG4gICAgICAucmVwbGFjZSgvXFwvOihcXHcrKS9nLCAoXzogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuIFwiLyhbXlxcXFwvXSspXCI7XG4gICAgICB9KTtcblxuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikpIHtcbiAgICBwYXJhbU5hbWVzLnB1c2goXCIqXCIpO1xuICAgIHJlZ2V4cFNvdXJjZSArPVxuICAgICAgcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiXG4gICAgICAgID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXG4gIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIlxcXFwvKiRcIjtcbiAgfSBlbHNlIGlmIChwYXRoICE9PSBcIlwiICYmIHBhdGggIT09IFwiL1wiKSB7XG4gICAgLy8gSWYgb3VyIHBhdGggaXMgbm9uLWVtcHR5IGFuZCBjb250YWlucyBhbnl0aGluZyBiZXlvbmQgYW4gaW5pdGlhbCBzbGFzaCxcbiAgICAvLyB0aGVuIHdlIGhhdmUgX3NvbWVfIGZvcm0gb2YgcGF0aCBpbiBvdXIgcmVnZXggc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3RoaW5nIHRvIG1hdGNoIGZvciBcIlwiIG9yIFwiL1wiXG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSSh2YWx1ZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSBVUkwgcGF0aCBcIiR7dmFsdWV9XCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBpcyBhIGAgK1xuICAgICAgICBgbWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5IGR1ZSB0byBhIGJhZCBwZXJjZW50IGAgK1xuICAgICAgICBgZW5jb2RpbmcgKCR7ZXJyb3J9KS5gXG4gICAgKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQodmFsdWU6IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIHZhbHVlIGZvciB0aGUgVVJMIHBhcmFtIFwiJHtwYXJhbU5hbWV9XCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlYCArXG4gICAgICAgIGAgdGhlIHN0cmluZyBcIiR7dmFsdWV9XCIgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHlgICtcbiAgICAgICAgYCBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoXG4gIHBhdGhuYW1lOiBzdHJpbmcsXG4gIGJhc2VuYW1lOiBzdHJpbmdcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG5cbiAgaWYgKCFwYXRobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYmFzZW5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFdlIHdhbnQgdG8gbGVhdmUgdHJhaWxpbmcgc2xhc2ggYmVoYXZpb3IgaW4gdGhlIHVzZXIncyBjb250cm9sLCBzbyBpZiB0aGV5XG4gIC8vIHNwZWNpZnkgYSBiYXNlbmFtZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2gsIHdlIHNob3VsZCBzdXBwb3J0IGl0XG4gIGxldCBzdGFydEluZGV4ID0gYmFzZW5hbWUuZW5kc1dpdGgoXCIvXCIpXG4gICAgPyBiYXNlbmFtZS5sZW5ndGggLSAxXG4gICAgOiBiYXNlbmFtZS5sZW5ndGg7XG4gIGxldCBuZXh0Q2hhciA9IHBhdGhuYW1lLmNoYXJBdChzdGFydEluZGV4KTtcbiAgaWYgKG5leHRDaGFyICYmIG5leHRDaGFyICE9PSBcIi9cIikge1xuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWUuc2xpY2Uoc3RhcnRJbmRleCkgfHwgXCIvXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG86IFRvLCBmcm9tUGF0aG5hbWUgPSBcIi9cIik6IFBhdGgge1xuICBsZXQge1xuICAgIHBhdGhuYW1lOiB0b1BhdGhuYW1lLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG5cbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZVxuICAgID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgPyB0b1BhdGhuYW1lXG4gICAgICA6IHJlc29sdmVQYXRobmFtZSh0b1BhdGhuYW1lLCBmcm9tUGF0aG5hbWUpXG4gICAgOiBmcm9tUGF0aG5hbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGg6IHN0cmluZywgZnJvbVBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcblxuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQpID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKFxuICBjaGFyOiBzdHJpbmcsXG4gIGZpZWxkOiBzdHJpbmcsXG4gIGRlc3Q6IHN0cmluZyxcbiAgcGF0aDogUGFydGlhbDxQYXRoPlxuKSB7XG4gIHJldHVybiAoXG4gICAgYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBgICtcbiAgICBgXFxgdG8uJHtmaWVsZH1cXGAgZmllbGQgWyR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBwYXRoXG4gICAgKX1dLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgYCArXG4gICAgYFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYCArXG4gICAgYGEgc3RyaW5nIGluIDxMaW5rIHRvPVwiLi4uXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5gXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlczxcbiAgVCBleHRlbmRzIEFnbm9zdGljUm91dGVNYXRjaCA9IEFnbm9zdGljUm91dGVNYXRjaFxuPihtYXRjaGVzOiBUW10pIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKFxuICAgIChtYXRjaCwgaW5kZXgpID0+XG4gICAgICBpbmRleCA9PT0gMCB8fCAobWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDApXG4gICk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVUbyhcbiAgdG9Bcmc6IFRvLFxuICByb3V0ZVBhdGhuYW1lczogc3RyaW5nW10sXG4gIGxvY2F0aW9uUGF0aG5hbWU6IHN0cmluZyxcbiAgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZVxuKTogUGF0aCB7XG4gIGxldCB0bzogUGFydGlhbDxQYXRoPjtcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IHsgLi4udG9BcmcgfTtcblxuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJwYXRobmFtZVwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLFxuICAgICAgZ2V0SW52YWxpZFBhdGhFcnJvcihcIiNcIiwgXCJzZWFyY2hcIiwgXCJoYXNoXCIsIHRvKVxuICAgICk7XG4gIH1cblxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG5cbiAgbGV0IGZyb206IHN0cmluZztcblxuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmIChpc1BhdGhSZWxhdGl2ZSB8fCB0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCBcInRvXCIgaGFkIG9uZVxuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID1cbiAgICB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPVxuICAgIChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmIChcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKVxuICApIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBqb2luUGF0aHMgPSAocGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+XG4gIHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZTogc3RyaW5nKTogc3RyaW5nID0+XG4gIHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IChzZWFyY2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCJcbiAgICA/IFwiXCJcbiAgICA6IHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKVxuICAgID8gc2VhcmNoXG4gICAgOiBcIj9cIiArIHNlYXJjaDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplSGFzaCA9IChoYXNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG5cbmV4cG9ydCB0eXBlIEpzb25GdW5jdGlvbiA9IDxEYXRhPihcbiAgZGF0YTogRGF0YSxcbiAgaW5pdD86IG51bWJlciB8IFJlc3BvbnNlSW5pdFxuKSA9PiBSZXNwb25zZTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5leHBvcnQgY29uc3QganNvbjogSnNvbkZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIHtcbiAgICAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVycyxcbiAgfSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZWRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTxhbnk+IHtcbiAgX3RyYWNrZWQ/OiBib29sZWFuO1xuICBfZGF0YT86IGFueTtcbiAgX2Vycm9yPzogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQWJvcnRlZERlZmVycmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgRGVmZXJyZWREYXRhIHtcbiAgcHJpdmF0ZSBwZW5kaW5nS2V5c1NldDogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG4gIHByaXZhdGUgYWJvcnRQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xuICBwcml2YXRlIHVubGlzdGVuQWJvcnRTaWduYWw6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgc3Vic2NyaWJlcnM6IFNldDwoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykgPT4gdm9pZD4gPVxuICAgIG5ldyBTZXQoKTtcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIGluaXQ/OiBSZXNwb25zZUluaXQ7XG4gIGRlZmVycmVkS2V5czogc3RyaW5nW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgcmVzcG9uc2VJbml0PzogUmVzcG9uc2VJbml0KSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSxcbiAgICAgIFwiZGVmZXIoKSBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0c1wiXG4gICAgKTtcblxuICAgIC8vIFNldCB1cCBhbiBBYm9ydENvbnRyb2xsZXIgKyBQcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3QgdG8gZXhpdCBlYXJseVxuICAgIC8vIGNhbmNlbGxhdGlvblxuICAgIGxldCByZWplY3Q6IChlOiBBYm9ydGVkRGVmZXJyZWRFcnJvcikgPT4gdm9pZDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiAocmVqZWN0ID0gcikpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgb25BYm9ydCA9ICgpID0+XG4gICAgICByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PlxuICAgICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgdGhpcy5jb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG5cbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW2tleV06IHRoaXMudHJhY2tQcm9taXNlKGtleSwgdmFsdWUpLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIEFsbCBpbmNvbWluZyB2YWx1ZXMgd2VyZSByZXNvbHZlZFxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0ID0gcmVzcG9uc2VJbml0O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFja1Byb21pc2UoXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IFByb21pc2U8dW5rbm93bj4gfCB1bmtub3duXG4gICk6IFRyYWNrZWRQcm9taXNlIHwgdW5rbm93biB7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmFkZChrZXkpO1xuXG4gICAgLy8gV2Ugc3RvcmUgYSBsaXR0bGUgd3JhcHBlciBwcm9taXNlIHRoYXQgd2lsbCBiZSBleHRlbmRlZCB3aXRoXG4gICAgLy8gX2RhdGEvX2Vycm9yIHByb3BzIHVwb24gcmVzb2x2ZS9yZWplY3RcbiAgICBsZXQgcHJvbWlzZTogVHJhY2tlZFByb21pc2UgPSBQcm9taXNlLnJhY2UoW3ZhbHVlLCB0aGlzLmFib3J0UHJvbWlzZV0pLnRoZW4oXG4gICAgICAoZGF0YSkgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIG51bGwsIGRhdGEgYXMgdW5rbm93biksXG4gICAgICAoZXJyb3IpID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCBlcnJvciBhcyB1bmtub3duKVxuICAgICk7XG5cbiAgICAvLyBSZWdpc3RlciByZWplY3Rpb24gbGlzdGVuZXJzIHRvIGF2b2lkIHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0aW9ucyBvblxuICAgIC8vIGVycm9ycyBvciBhYm9ydGVkIGRlZmVycmVkIHZhbHVlc1xuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwgeyBnZXQ6ICgpID0+IHRydWUgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBwcml2YXRlIG9uU2V0dGxlKFxuICAgIHByb21pc2U6IFRyYWNrZWRQcm9taXNlLFxuICAgIGtleTogc3RyaW5nLFxuICAgIGVycm9yOiB1bmtub3duLFxuICAgIGRhdGE/OiB1bmtub3duXG4gICk6IHVua25vd24ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvclxuICAgICkge1xuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwgeyBnZXQ6ICgpID0+IGVycm9yIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7IGdldDogKCkgPT4gZGF0YSB9KTtcbiAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwcml2YXRlIGVtaXQoYWJvcnRlZDogYm9vbGVhbiwgc2V0dGxlZEtleT86IHN0cmluZykge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihhYm9ydGVkLCBzZXR0bGVkS2V5KSk7XG4gIH1cblxuICBzdWJzY3JpYmUoZm46IChhYm9ydGVkOiBib29sZWFuLCBzZXR0bGVkS2V5Pzogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrKSk7XG4gICAgdGhpcy5lbWl0KHRydWUpO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZURhdGEoc2lnbmFsOiBBYm9ydFNpZ25hbCkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIGxldCBvbkFib3J0ID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKGFib3J0ZWQpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgIGlmIChhYm9ydGVkIHx8IHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShhYm9ydGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhYm9ydGVkO1xuICB9XG5cbiAgZ2V0IGRvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIGdldCB1bndyYXBwZWREYXRhKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuZGF0YSAhPT0gbnVsbCAmJiB0aGlzLmRvbmUsXG4gICAgICBcIkNhbiBvbmx5IHVud3JhcCBkYXRhIG9uIGluaXRpYWxpemVkIGFuZCBzZXR0bGVkIGRlZmVycmVkc1wiXG4gICAgKTtcblxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgICBba2V5XTogdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpLFxuICAgICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIGdldCBwZW5kaW5nS2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RyYWNrZWRQcm9taXNlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBUcmFja2VkUHJvbWlzZSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlICYmICh2YWx1ZSBhcyBUcmFja2VkUHJvbWlzZSkuX3RyYWNrZWQgPT09IHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWU6IGFueSkge1xuICBpZiAoIWlzVHJhY2tlZFByb21pc2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlLl9lcnJvcikge1xuICAgIHRocm93IHZhbHVlLl9lcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsdWUuX2RhdGE7XG59XG5cbmV4cG9ydCB0eXBlIERlZmVyRnVuY3Rpb24gPSAoXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBpbml0PzogbnVtYmVyIHwgUmVzcG9uc2VJbml0XG4pID0+IERlZmVycmVkRGF0YTtcblxuZXhwb3J0IGNvbnN0IGRlZmVyOiBEZWZlckZ1bmN0aW9uID0gKGRhdGEsIGluaXQgPSB7fSkgPT4ge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7IHN0YXR1czogaW5pdCB9IDogaW5pdDtcblxuICByZXR1cm4gbmV3IERlZmVycmVkRGF0YShkYXRhLCByZXNwb25zZUluaXQpO1xufTtcblxuZXhwb3J0IHR5cGUgUmVkaXJlY3RGdW5jdGlvbiA9IChcbiAgdXJsOiBzdHJpbmcsXG4gIGluaXQ/OiBudW1iZXIgfCBSZXNwb25zZUluaXRcbikgPT4gUmVzcG9uc2U7XG5cbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKi9cbmV4cG9ydCBjb25zdCByZWRpcmVjdDogUmVkaXJlY3RGdW5jdGlvbiA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVXRpbGl0eSBjbGFzcyB3ZSB1c2UgdG8gaG9sZCBhdXRvLXVud3JhcHBlZCA0eHgvNXh4IFJlc3BvbnNlIGJvZGllc1xuICovXG5leHBvcnQgY2xhc3MgRXJyb3JSZXNwb25zZSB7XG4gIHN0YXR1czogbnVtYmVyO1xuICBzdGF0dXNUZXh0OiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbiAgZXJyb3I/OiBFcnJvcjtcbiAgaW50ZXJuYWw6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzOiBudW1iZXIsXG4gICAgc3RhdHVzVGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGRhdGE6IGFueSxcbiAgICBpbnRlcm5hbCA9IGZhbHNlXG4gICkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcbiAgICB0aGlzLmludGVybmFsID0gaW50ZXJuYWw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcjogYW55KTogZXJyb3IgaXMgRXJyb3JSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgZXJyb3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiZcbiAgICB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiZcbiAgICBcImRhdGFcIiBpbiBlcnJvclxuICApO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBIaXN0b3J5LCBMb2NhdGlvbiwgUGF0aCwgVG8gfSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQge1xuICBBY3Rpb24gYXMgSGlzdG9yeUFjdGlvbixcbiAgY3JlYXRlTG9jYXRpb24sXG4gIGNyZWF0ZVBhdGgsXG4gIGludmFyaWFudCxcbiAgcGFyc2VQYXRoLFxuICB3YXJuaW5nLFxufSBmcm9tIFwiLi9oaXN0b3J5XCI7XG5pbXBvcnQgdHlwZSB7XG4gIERhdGFSZXN1bHQsXG4gIERlZmVycmVkRGF0YSxcbiAgQWdub3N0aWNEYXRhUm91dGVNYXRjaCxcbiAgQWdub3N0aWNEYXRhUm91dGVPYmplY3QsXG4gIERlZmVycmVkUmVzdWx0LFxuICBFcnJvclJlc3VsdCxcbiAgRm9ybUVuY1R5cGUsXG4gIEZvcm1NZXRob2QsXG4gIERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbixcbiAgUmVkaXJlY3RSZXN1bHQsXG4gIFJvdXRlRGF0YSxcbiAgQWdub3N0aWNSb3V0ZU9iamVjdCxcbiAgU3VibWlzc2lvbixcbiAgU3VjY2Vzc1Jlc3VsdCxcbiAgQWdub3N0aWNSb3V0ZU1hdGNoLFxuICBTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24sXG4gIFJvdXRlTWFuaWZlc3QsXG4gIEltbXV0YWJsZVJvdXRlS2V5LFxuICBBY3Rpb25GdW5jdGlvbixcbiAgTG9hZGVyRnVuY3Rpb24sXG4gIFY3X011dGF0aW9uRm9ybU1ldGhvZCxcbiAgVjdfRm9ybU1ldGhvZCxcbiAgSFRNTEZvcm1NZXRob2QsXG4gIE11dGF0aW9uRm9ybU1ldGhvZCxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIEVycm9yUmVzcG9uc2UsXG4gIFJlc3VsdFR5cGUsXG4gIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsXG4gIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLFxuICBpbW11dGFibGVSb3V0ZUtleXMsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBqb2luUGF0aHMsXG4gIG1hdGNoUm91dGVzLFxuICByZXNvbHZlVG8sXG4gIHN0cmlwQmFzZW5hbWUsXG59IGZyb20gXCIuL3V0aWxzXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBBIFJvdXRlciBpbnN0YW5jZSBtYW5hZ2VzIGFsbCBuYXZpZ2F0aW9uIGFuZCBkYXRhIGxvYWRpbmcvbXV0YXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBSZXR1cm4gdGhlIGJhc2VuYW1lIGZvciB0aGUgcm91dGVyXG4gICAqL1xuICBnZXQgYmFzZW5hbWUoKTogUm91dGVySW5pdFtcImJhc2VuYW1lXCJdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByb3V0ZXJcbiAgICovXG4gIGdldCBzdGF0ZSgpOiBSb3V0ZXJTdGF0ZTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFJldHVybiB0aGUgcm91dGVzIGZvciB0aGlzIHJvdXRlciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHJvdXRlcygpOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBpbmNsdWRpbmcgYWRkaW5nIGhpc3RvcnkgbGlzdGVuZXJzIGFuZCBraWNraW5nIG9mZlxuICAgKiBpbml0aWFsIGRhdGEgZmV0Y2hlcy4gIFJldHVybnMgYSBmdW5jdGlvbiB0byBjbGVhbnVwIGxpc3RlbmVycyBhbmQgYWJvcnRcbiAgICogYW55IGluLXByb2dyZXNzIGxvYWRzXG4gICAqL1xuICBpbml0aWFsaXplKCk6IFJvdXRlcjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFN1YnNjcmliZSB0byByb3V0ZXIuc3RhdGUgdXBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHRoZSBuZXcgc3RhdGVcbiAgICovXG4gIHN1YnNjcmliZShmbjogUm91dGVyU3Vic2NyaWJlcik6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGJlaGF2aW9yIGluIHRoZSByb3V0ZXJcbiAgICpcbiAgICogQHBhcmFtIHNhdmVkU2Nyb2xsUG9zaXRpb25zIE9iamVjdCB0aGF0IHdpbGwgbWFuYWdlIHBvc2l0aW9ucywgaW4gY2FzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQncyBiZWluZyByZXN0b3JlZCBmcm9tIHNlc3Npb25TdG9yYWdlXG4gICAqIEBwYXJhbSBnZXRTY3JvbGxQb3NpdGlvbiAgICBGdW5jdGlvbiB0byBnZXQgdGhlIGFjdGl2ZSBZIHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZ2V0S2V5ICAgICAgICAgICAgICAgRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgdG8gdXNlIGZvciByZXN0b3JhdGlvblxuICAgKi9cbiAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24sXG4gICAgZ2V0S2V5PzogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvblxuICApOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogTmF2aWdhdGUgZm9yd2FyZC9iYWNrd2FyZCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBAcGFyYW0gdG8gRGVsdGEgdG8gbW92ZSBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKi9cbiAgbmF2aWdhdGUodG86IG51bWJlcik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBnaXZlbiBwYXRoXG4gICAqIEBwYXJhbSB0byBQYXRoIHRvIG5hdmlnYXRlIHRvXG4gICAqIEBwYXJhbSBvcHRzIE5hdmlnYXRpb24gb3B0aW9ucyAobWV0aG9kLCBzdWJtaXNzaW9uLCBldGMuKVxuICAgKi9cbiAgbmF2aWdhdGUodG86IFRvLCBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFRyaWdnZXIgYSBmZXRjaGVyIGxvYWQvc3VibWlzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ga2V5ICAgICBGZXRjaGVyIGtleVxuICAgKiBAcGFyYW0gcm91dGVJZCBSb3V0ZSB0aGF0IG93bnMgdGhlIGZldGNoZXJcbiAgICogQHBhcmFtIGhyZWYgICAgaHJlZiB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0cyAgICBGZXRjaGVyIG9wdGlvbnMsIChtZXRob2QsIHN1Ym1pc3Npb24sIGV0Yy4pXG4gICAqL1xuICBmZXRjaChcbiAgICBrZXk6IHN0cmluZyxcbiAgICByb3V0ZUlkOiBzdHJpbmcsXG4gICAgaHJlZjogc3RyaW5nLFxuICAgIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnNcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIFRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYWxsIGN1cnJlbnQgcm91dGUgbG9hZGVycyBhbmQgZmV0Y2hlciBsb2Fkc1xuICAgKi9cbiAgcmV2YWxpZGF0ZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaHJlZiBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uXG4gICAqIEBwYXJhbSBsb2NhdGlvblxuICAgKi9cbiAgY3JlYXRlSHJlZihsb2NhdGlvbjogTG9jYXRpb24gfCBVUkwpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIFVSTCBlbmNvZGUgYSBkZXN0aW5hdGlvbiBwYXRoIGFjY29yZGluZyB0byB0aGUgaW50ZXJuYWxcbiAgICogaGlzdG9yeSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gdG9cbiAgICovXG4gIGVuY29kZUxvY2F0aW9uKHRvOiBUbyk6IFBhdGg7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBHZXQvY3JlYXRlIGEgZmV0Y2hlciBmb3IgdGhlIGdpdmVuIGtleVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBnZXRGZXRjaGVyPFREYXRhID0gYW55PihrZXk/OiBzdHJpbmcpOiBGZXRjaGVyPFREYXRhPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIERlbGV0ZSB0aGUgZmV0Y2hlciBmb3IgYSBnaXZlbiBrZXlcbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgZGVsZXRlRmV0Y2hlcihrZXk/OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogQ2xlYW51cCBsaXN0ZW5lcnMgYW5kIGFib3J0IGFueSBpbi1wcm9ncmVzcyBsb2Fkc1xuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogR2V0IGEgbmF2aWdhdGlvbiBibG9ja2VyXG4gICAqIEBwYXJhbSBrZXkgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2VyXG4gICAqIEBwYXJhbSBmbiBUaGUgYmxvY2tlciBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbik6IEJsb2NrZXI7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBQUklWQVRFIC0gRE8gTk9UIFVTRVxuICAgKlxuICAgKiBEZWxldGUgYSBuYXZpZ2F0aW9uIGJsb2NrZXJcbiAgICogQHBhcmFtIGtleSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrZXJcbiAgICovXG4gIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogUFJJVkFURSAtIERPIE5PVCBVU0VcbiAgICpcbiAgICogSE1SIG5lZWRzIHRvIHBhc3MgaW4tZmxpZ2h0IHJvdXRlIHVwZGF0ZXMgdG8gUmVhY3QgUm91dGVyXG4gICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGdyYW51bGFyIHJvdXRlIHVwZGF0ZSBBUElzIChhZGRSb3V0ZSwgdXBkYXRlUm91dGUsIGRlbGV0ZVJvdXRlKVxuICAgKi9cbiAgX2ludGVybmFsU2V0Um91dGVzKHJvdXRlczogQWdub3N0aWNSb3V0ZU9iamVjdFtdKTogdm9pZDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIGZldGNoIEFib3J0Q29udHJvbGxlcnMgYWNjZXNzZWQgYnkgdW5pdCB0ZXN0c1xuICAgKi9cbiAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFBSSVZBVEUgLSBETyBOT1QgVVNFXG4gICAqXG4gICAqIEludGVybmFsIHBlbmRpbmcgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBhY2Nlc3NlZCBieSB1bml0IHRlc3RzXG4gICAqL1xuICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IE1hcDxzdHJpbmcsIERlZmVycmVkRGF0YT47XG59XG5cbi8qKlxuICogU3RhdGUgbWFpbnRhaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSByb3V0ZXIuICBEdXJpbmcgYSBuYXZpZ2F0aW9uLCBhbGwgc3RhdGVzXG4gKiByZWZsZWN0IHRoZSB0aGUgXCJvbGRcIiBsb2NhdGlvbiB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gb2YgdGhlIG1vc3QgcmVjZW50IG5hdmlnYXRpb25cbiAgICovXG4gIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGxvY2F0aW9uIHJlZmxlY3RlZCBieSB0aGUgcm91dGVyXG4gICAqL1xuICBsb2NhdGlvbjogTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNldCBvZiByb3V0ZSBtYXRjaGVzXG4gICAqL1xuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW107XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHdlJ3ZlIGNvbXBsZXRlZCBvdXIgaW5pdGlhbCBkYXRhIGxvYWRcbiAgICovXG4gIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB3ZSBzaG91bGQgc3RhcnQgYXQgZm9yIGEgbmV3IHZpZXdcbiAgICogIC0gbnVtYmVyIC0+IHNjcm9sbCBwb3NpdGlvbiB0byByZXN0b3JlIHRvXG4gICAqICAtIGZhbHNlIC0+IGRvIG5vdCByZXN0b3JlIHNjcm9sbCBhdCBhbGwgKHVzZWQgZHVyaW5nIHN1Ym1pc3Npb25zKVxuICAgKiAgLSBudWxsIC0+IGRvbid0IGhhdmUgYSBzYXZlZCBwb3NpdGlvbiwgc2Nyb2xsIHRvIGhhc2ggb3IgdG9wIG9mIHBhZ2VcbiAgICovXG4gIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVtYmVyIHwgZmFsc2UgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgbmF2aWdhdGlvbiBzaG91bGQgc2tpcCByZXNldHRpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKiBpZiB3ZSBhcmUgdW5hYmxlIHRvIHJlc3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKi9cbiAgcHJldmVudFNjcm9sbFJlc2V0OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IG5hdmlnYXRpb25cbiAgICovXG4gIG5hdmlnYXRpb246IE5hdmlnYXRpb247XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBhbnkgaW4tcHJvZ3Jlc3MgcmV2YWxpZGF0aW9uc1xuICAgKi9cbiAgcmV2YWxpZGF0aW9uOiBSZXZhbGlkYXRpb25TdGF0ZTtcblxuICAvKipcbiAgICogRGF0YSBmcm9tIHRoZSBsb2FkZXJzIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBsb2FkZXJEYXRhOiBSb3V0ZURhdGE7XG5cbiAgLyoqXG4gICAqIERhdGEgZnJvbSB0aGUgYWN0aW9uIGZvciB0aGUgY3VycmVudCBtYXRjaGVzXG4gICAqL1xuICBhY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBFcnJvcnMgY2F1Z2h0IGZyb20gbG9hZGVycyBmb3IgdGhlIGN1cnJlbnQgbWF0Y2hlc1xuICAgKi9cbiAgZXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBmZXRjaGVyc1xuICAgKi9cbiAgZmV0Y2hlcnM6IE1hcDxzdHJpbmcsIEZldGNoZXI+O1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgY3VycmVudCBibG9ja2Vyc1xuICAgKi9cbiAgYmxvY2tlcnM6IE1hcDxzdHJpbmcsIEJsb2NrZXI+O1xufVxuXG4vKipcbiAqIERhdGEgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gaHlkcmF0ZSBhIFJvdXRlciBmcm9tIFNTUlxuICovXG5leHBvcnQgdHlwZSBIeWRyYXRpb25TdGF0ZSA9IFBhcnRpYWw8XG4gIFBpY2s8Um91dGVyU3RhdGUsIFwibG9hZGVyRGF0YVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImVycm9yc1wiPlxuPjtcblxuLyoqXG4gKiBGdXR1cmUgZmxhZ3MgdG8gdG9nZ2xlIG5ldyBmZWF0dXJlIGJlaGF2aW9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnV0dXJlQ29uZmlnIHtcbiAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBvcHRpb25zIGZvciBjcmVhdGVSb3V0ZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJJbml0IHtcbiAgcm91dGVzOiBBZ25vc3RpY1JvdXRlT2JqZWN0W107XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBkZXRlY3RFcnJvckJvdW5kYXJ5PzogRGV0ZWN0RXJyb3JCb3VuZGFyeUZ1bmN0aW9uO1xuICBmdXR1cmU/OiBGdXR1cmVDb25maWc7XG4gIGh5ZHJhdGlvbkRhdGE/OiBIeWRyYXRpb25TdGF0ZTtcbn1cblxuLyoqXG4gKiBTdGF0ZSByZXR1cm5lZCBmcm9tIGEgc2VydmVyLXNpZGUgcXVlcnkoKSBjYWxsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljSGFuZGxlckNvbnRleHQge1xuICBiYXNlbmFtZTogUm91dGVyW1wiYmFzZW5hbWVcIl07XG4gIGxvY2F0aW9uOiBSb3V0ZXJTdGF0ZVtcImxvY2F0aW9uXCJdO1xuICBtYXRjaGVzOiBSb3V0ZXJTdGF0ZVtcIm1hdGNoZXNcIl07XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgYWN0aW9uRGF0YTogUm91dGVyU3RhdGVbXCJhY3Rpb25EYXRhXCJdO1xuICBlcnJvcnM6IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+O1xuICBhY3Rpb25IZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBIZWFkZXJzPjtcbiAgYWN0aXZlRGVmZXJyZWRzOiBSZWNvcmQ8c3RyaW5nLCBEZWZlcnJlZERhdGE+IHwgbnVsbDtcbiAgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQ/OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKipcbiAqIEEgU3RhdGljSGFuZGxlciBpbnN0YW5jZSBtYW5hZ2VzIGEgc2luZ3VsYXIgU1NSIG5hdmlnYXRpb24vZmV0Y2ggZXZlbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNIYW5kbGVyIHtcbiAgZGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXTtcbiAgcXVlcnkoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBvcHRzPzogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfVxuICApOiBQcm9taXNlPFN0YXRpY0hhbmRsZXJDb250ZXh0IHwgUmVzcG9uc2U+O1xuICBxdWVyeVJvdXRlKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgb3B0cz86IHsgcm91dGVJZD86IHN0cmluZzsgcmVxdWVzdENvbnRleHQ/OiB1bmtub3duIH1cbiAgKTogUHJvbWlzZTxhbnk+O1xufVxuXG4vKipcbiAqIFN1YnNjcmliZXIgZnVuY3Rpb24gc2lnbmF0dXJlIGZvciBjaGFuZ2VzIHRvIHJvdXRlciBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclN1YnNjcmliZXIge1xuICAoc3RhdGU6IFJvdXRlclN0YXRlKTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIFVzZU1hdGNoZXNNYXRjaCB7XG4gIGlkOiBzdHJpbmc7XG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIHBhcmFtczogQWdub3N0aWNSb3V0ZU1hdGNoW1wicGFyYW1zXCJdO1xuICBkYXRhOiB1bmtub3duO1xuICBoYW5kbGU6IHVua25vd247XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUga2V5IHRvIGJlIHVzZWQgaW4gc2Nyb2xsIHJlc3RvcmF0aW9uXG4gKiBmb3IgYSBnaXZlbiBsb2NhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdldFNjcm9sbFJlc3RvcmF0aW9uS2V5RnVuY3Rpb24ge1xuICAobG9jYXRpb246IExvY2F0aW9uLCBtYXRjaGVzOiBVc2VNYXRjaGVzTWF0Y2hbXSk6IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gc2lnbmF0dXJlIGZvciBkZXRlcm1pbmluZyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHZXRTY3JvbGxQb3NpdGlvbkZ1bmN0aW9uIHtcbiAgKCk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBhIG5hdmlnYXRlKCkgY2FsbCBmb3IgYSBMaW5rIG5hdmlnYXRpb25cbiAqL1xudHlwZSBMaW5rTmF2aWdhdGVPcHRpb25zID0ge1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG4gIHByZXZlbnRTY3JvbGxSZXNldD86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGEgbmF2aWdhdGUoKSBjYWxsIGZvciBhIEZvcm0gbmF2aWdhdGlvblxuICovXG50eXBlIFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMgPSB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgcHJldmVudFNjcm9sbFJlc2V0PzogYm9vbGVhbjtcbiAgZm9ybU1ldGhvZD86IEhUTUxGb3JtTWV0aG9kO1xuICBmb3JtRW5jVHlwZT86IEZvcm1FbmNUeXBlO1xuICBmb3JtRGF0YTogRm9ybURhdGE7XG59O1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBuYXZpZ2F0ZSgpIGZvciBlaXRoZXIgYSBMaW5rIG9yIEZvcm0gbmF2aWdhdGlvblxuICovXG5leHBvcnQgdHlwZSBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMgPVxuICB8IExpbmtOYXZpZ2F0ZU9wdGlvbnNcbiAgfCBTdWJtaXNzaW9uTmF2aWdhdGVPcHRpb25zO1xuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byBmZXRjaCgpXG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlckZldGNoT3B0aW9ucyA9XG4gIHwgT21pdDxMaW5rTmF2aWdhdGVPcHRpb25zLCBcInJlcGxhY2VcIj5cbiAgfCBPbWl0PFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMsIFwicmVwbGFjZVwiPjtcblxuLyoqXG4gKiBQb3RlbnRpYWwgc3RhdGVzIGZvciBzdGF0ZS5uYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRpb25TdGF0ZXMgPSB7XG4gIElkbGU6IHtcbiAgICBzdGF0ZTogXCJpZGxlXCI7XG4gICAgbG9jYXRpb246IHVuZGVmaW5lZDtcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQ7XG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZDtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBsb2NhdGlvbjogTG9jYXRpb247XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IFY3X0Zvcm1NZXRob2QgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZSB8IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogRm9ybURhdGEgfCB1bmRlZmluZWQ7XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgbG9jYXRpb246IExvY2F0aW9uO1xuICAgIGZvcm1NZXRob2Q6IEZvcm1NZXRob2QgfCBWN19Gb3JtTWV0aG9kO1xuICAgIGZvcm1BY3Rpb246IHN0cmluZztcbiAgICBmb3JtRW5jVHlwZTogRm9ybUVuY1R5cGU7XG4gICAgZm9ybURhdGE6IEZvcm1EYXRhO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgTmF2aWdhdGlvbiA9IE5hdmlnYXRpb25TdGF0ZXNba2V5b2YgTmF2aWdhdGlvblN0YXRlc107XG5cbmV4cG9ydCB0eXBlIFJldmFsaWRhdGlvblN0YXRlID0gXCJpZGxlXCIgfCBcImxvYWRpbmdcIjtcblxuLyoqXG4gKiBQb3RlbnRpYWwgc3RhdGVzIGZvciBmZXRjaGVyc1xuICovXG50eXBlIEZldGNoZXJTdGF0ZXM8VERhdGEgPSBhbnk+ID0ge1xuICBJZGxlOiB7XG4gICAgc3RhdGU6IFwiaWRsZVwiO1xuICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZDtcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkO1xuICAgIGRhdGE6IFREYXRhIHwgdW5kZWZpbmVkO1xuICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiPzogYm9vbGVhbjtcbiAgfTtcbiAgTG9hZGluZzoge1xuICAgIHN0YXRlOiBcImxvYWRpbmdcIjtcbiAgICBmb3JtTWV0aG9kOiBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZCB8IHVuZGVmaW5lZDtcbiAgICBmb3JtQWN0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9ybUVuY1R5cGU6IEZvcm1FbmNUeXBlIHwgdW5kZWZpbmVkO1xuICAgIGZvcm1EYXRhOiBGb3JtRGF0YSB8IHVuZGVmaW5lZDtcbiAgICBkYXRhOiBURGF0YSB8IHVuZGVmaW5lZDtcbiAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIj86IGJvb2xlYW47XG4gIH07XG4gIFN1Ym1pdHRpbmc6IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCI7XG4gICAgZm9ybU1ldGhvZDogRm9ybU1ldGhvZCB8IFY3X0Zvcm1NZXRob2Q7XG4gICAgZm9ybUFjdGlvbjogc3RyaW5nO1xuICAgIGZvcm1FbmNUeXBlOiBGb3JtRW5jVHlwZTtcbiAgICBmb3JtRGF0YTogRm9ybURhdGE7XG4gICAgZGF0YTogVERhdGEgfCB1bmRlZmluZWQ7XG4gICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI/OiBib29sZWFuO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgRmV0Y2hlcjxURGF0YSA9IGFueT4gPVxuICBGZXRjaGVyU3RhdGVzPFREYXRhPltrZXlvZiBGZXRjaGVyU3RhdGVzPFREYXRhPl07XG5cbmludGVyZmFjZSBCbG9ja2VyQmxvY2tlZCB7XG4gIHN0YXRlOiBcImJsb2NrZWRcIjtcbiAgcmVzZXQoKTogdm9pZDtcbiAgcHJvY2VlZCgpOiB2b2lkO1xuICBsb2NhdGlvbjogTG9jYXRpb247XG59XG5cbmludGVyZmFjZSBCbG9ja2VyVW5ibG9ja2VkIHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCI7XG4gIHJlc2V0OiB1bmRlZmluZWQ7XG4gIHByb2NlZWQ6IHVuZGVmaW5lZDtcbiAgbG9jYXRpb246IHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEJsb2NrZXJQcm9jZWVkaW5nIHtcbiAgc3RhdGU6IFwicHJvY2VlZGluZ1wiO1xuICByZXNldDogdW5kZWZpbmVkO1xuICBwcm9jZWVkOiB1bmRlZmluZWQ7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgQmxvY2tlciA9IEJsb2NrZXJVbmJsb2NrZWQgfCBCbG9ja2VyQmxvY2tlZCB8IEJsb2NrZXJQcm9jZWVkaW5nO1xuXG5leHBvcnQgdHlwZSBCbG9ja2VyRnVuY3Rpb24gPSAoYXJnczoge1xuICBjdXJyZW50TG9jYXRpb246IExvY2F0aW9uO1xuICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uO1xufSkgPT4gYm9vbGVhbjtcblxuaW50ZXJmYWNlIFNob3J0Q2lyY3VpdGFibGUge1xuICAvKipcbiAgICogc3RhcnROYXZpZ2F0aW9uIGRvZXMgbm90IG5lZWQgdG8gY29tcGxldGUgdGhlIG5hdmlnYXRpb24gYmVjYXVzZSB3ZVxuICAgKiByZWRpcmVjdGVkIG9yIGdvdCBpbnRlcnJ1cHRlZFxuICAgKi9cbiAgc2hvcnRDaXJjdWl0ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSGFuZGxlQWN0aW9uUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBFcnJvciB0aHJvd24gZnJvbSB0aGUgY3VycmVudCBhY3Rpb24sIGtleWVkIGJ5IHRoZSByb3V0ZSBjb250YWluaW5nIHRoZVxuICAgKiBlcnJvciBib3VuZGFyeSB0byByZW5kZXIgdGhlIGVycm9yLiAgVG8gYmUgY29tbWl0dGVkIHRvIHRoZSBzdGF0ZSBhZnRlclxuICAgKiBsb2FkZXJzIGhhdmUgY29tcGxldGVkXG4gICAqL1xuICBwZW5kaW5nQWN0aW9uRXJyb3I/OiBSb3V0ZURhdGE7XG4gIC8qKlxuICAgKiBEYXRhIHJldHVybmVkIGZyb20gdGhlIGN1cnJlbnQgYWN0aW9uLCBrZXllZCBieSB0aGUgcm91dGUgb3duaW5nIHRoZSBhY3Rpb24uXG4gICAqIFRvIGJlIGNvbW1pdHRlZCB0byB0aGUgc3RhdGUgYWZ0ZXIgbG9hZGVycyBoYXZlIGNvbXBsZXRlZFxuICAgKi9cbiAgcGVuZGluZ0FjdGlvbkRhdGE/OiBSb3V0ZURhdGE7XG59XG5cbmludGVyZmFjZSBIYW5kbGVMb2FkZXJzUmVzdWx0IGV4dGVuZHMgU2hvcnRDaXJjdWl0YWJsZSB7XG4gIC8qKlxuICAgKiBsb2FkZXJEYXRhIHJldHVybmVkIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGxvYWRlcnNcbiAgICovXG4gIGxvYWRlckRhdGE/OiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl07XG4gIC8qKlxuICAgKiBlcnJvcnMgdGhyb3duIGZyb20gdGhlIGN1cnJlbnQgc2V0IG9mIGxvYWRlcnNcbiAgICovXG4gIGVycm9ycz86IFJvdXRlclN0YXRlW1wiZXJyb3JzXCJdO1xufVxuXG4vKipcbiAqIENhY2hlZCBpbmZvIGZvciBhY3RpdmUgZmV0Y2hlci5sb2FkKCkgaW5zdGFuY2VzIHNvIHRoZXkgY2FuIHBhcnRpY2lwYXRlXG4gKiBpbiByZXZhbGlkYXRpb25cbiAqL1xuaW50ZXJmYWNlIEZldGNoTG9hZE1hdGNoIHtcbiAgcm91dGVJZDogc3RyaW5nO1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogSWRlbnRpZmllZCBmZXRjaGVyLmxvYWQoKSBjYWxscyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAqL1xuaW50ZXJmYWNlIFJldmFsaWRhdGluZ0ZldGNoZXIgZXh0ZW5kcyBGZXRjaExvYWRNYXRjaCB7XG4gIGtleTogc3RyaW5nO1xuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaCB8IG51bGw7XG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSB8IG51bGw7XG59XG5cbi8qKlxuICogV3JhcHBlciBvYmplY3QgdG8gYWxsb3cgdXMgdG8gdGhyb3cgYW55IHJlc3BvbnNlIG91dCBmcm9tIGNhbGxMb2FkZXJPckFjdGlvblxuICogZm9yIHF1ZXJ5Um91dGVyIHdoaWxlIHByZXNlcnZpbmcgd2hldGhlciBvciBub3QgaXQgd2FzIHRocm93biBvciByZXR1cm5lZFxuICogZnJvbSB0aGUgbG9hZGVyL2FjdGlvblxuICovXG5pbnRlcmZhY2UgUXVlcnlSb3V0ZVJlc3BvbnNlIHtcbiAgdHlwZTogUmVzdWx0VHlwZS5kYXRhIHwgUmVzdWx0VHlwZS5lcnJvcjtcbiAgcmVzcG9uc2U6IFJlc3BvbnNlO1xufVxuXG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kc0FycjogTXV0YXRpb25Gb3JtTWV0aG9kW10gPSBbXG4gIFwicG9zdFwiLFxuICBcInB1dFwiLFxuICBcInBhdGNoXCIsXG4gIFwiZGVsZXRlXCIsXG5dO1xuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0PE11dGF0aW9uRm9ybU1ldGhvZD4oXG4gIHZhbGlkTXV0YXRpb25NZXRob2RzQXJyXG4pO1xuXG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzQXJyOiBGb3JtTWV0aG9kW10gPSBbXG4gIFwiZ2V0XCIsXG4gIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyLFxuXTtcbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHMgPSBuZXcgU2V0PEZvcm1NZXRob2Q+KHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIpO1xuXG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmNvbnN0IHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwNywgMzA4XSk7XG5cbmV4cG9ydCBjb25zdCBJRExFX05BVklHQVRJT046IE5hdmlnYXRpb25TdGF0ZXNbXCJJZGxlXCJdID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGNvbnN0IElETEVfRkVUQ0hFUjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBjb25zdCBJRExFX0JMT0NLRVI6IEJsb2NrZXJVbmJsb2NrZWQgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gIHJlc2V0OiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG59O1xuXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5cbmNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBpc1NlcnZlciA9ICFpc0Jyb3dzZXI7XG5cbmNvbnN0IGRlZmF1bHREZXRlY3RFcnJvckJvdW5kYXJ5ID0gKHJvdXRlOiBBZ25vc3RpY1JvdXRlT2JqZWN0KSA9PlxuICBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpO1xuLy8jZW5kcmVnaW9uXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZSBhIHJvdXRlciBhbmQgbGlzdGVuIHRvIGhpc3RvcnkgUE9QIG5hdmlnYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdDogUm91dGVySW5pdCk6IFJvdXRlciB7XG4gIGludmFyaWFudChcbiAgICBpbml0LnJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCJcbiAgKTtcblxuICBsZXQgZGV0ZWN0RXJyb3JCb3VuZGFyeSA9XG4gICAgaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5IHx8IGRlZmF1bHREZXRlY3RFcnJvckJvdW5kYXJ5O1xuXG4gIC8vIFJvdXRlcyBrZXllZCBieSBJRFxuICBsZXQgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QgPSB7fTtcbiAgLy8gUm91dGVzIGluIHRyZWUgZm9ybWF0IGZvciBtYXRjaGluZ1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgaW5pdC5yb3V0ZXMsXG4gICAgZGV0ZWN0RXJyb3JCb3VuZGFyeSxcbiAgICB1bmRlZmluZWQsXG4gICAgbWFuaWZlc3RcbiAgKTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSB8IHVuZGVmaW5lZDtcbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlOiBGdXR1cmVDb25maWcgPSB7XG4gICAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogZmFsc2UsXG4gICAgLi4uaW5pdC5mdXR1cmUsXG4gIH07XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcbiAgbGV0IHVubGlzdGVuSGlzdG9yeTogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb25zIHRvIGNhbGwgb24gYWxsIHN0YXRlIGNoYW5nZXNcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldDxSb3V0ZXJTdWJzY3JpYmVyPigpO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIG9iamVjdCB0byBob2xkIHNjcm9sbCByZXN0b3JhdGlvbiBsb2NhdGlvbnMgZHVyaW5nIHJvdXRpbmdcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHwgbnVsbCA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTogR2V0U2Nyb2xsUmVzdG9yYXRpb25LZXlGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9uIHRvIGdldCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb246IEdldFNjcm9sbFBvc2l0aW9uRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgLy8gT25lLXRpbWUgZmxhZyB0byBjb250cm9sIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24uICBCZWNhdXNlXG4gIC8vIHdlIGRvbid0IGdldCB0aGUgc2F2ZWQgcG9zaXRpb25zIGZyb20gPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHVudGlsIF9hZnRlcl9cbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xuICAvLyBzZW5kIGFsb25nIHRoZSByZXN0b3JlU2Nyb2xsUG9zaXRpb25cbiAgLy8gU2V0IHRvIHRydWUgaWYgd2UgaGF2ZSBgaHlkcmF0aW9uRGF0YWAgc2luY2Ugd2UgYXNzdW1lIHdlIHdlcmUgU1NSJ2QgYW5kIHRoYXRcbiAgLy8gU1NSIGRpZCB0aGUgaW5pdGlhbCBzY3JvbGwgcmVzdG9yYXRpb24uXG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcblxuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhcbiAgICBkYXRhUm91dGVzLFxuICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbixcbiAgICBpbml0LmJhc2VuYW1lXG4gICk7XG4gIGxldCBpbml0aWFsRXJyb3JzOiBSb3V0ZURhdGEgfCBudWxsID0gbnVsbDtcblxuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICB9KTtcbiAgICBsZXQgeyBtYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfVxuXG4gIGxldCBpbml0aWFsaXplZCA9XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgICFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxhenkpICYmXG4gICAgLy8gQW5kIHdlIGhhdmUgdG8gZWl0aGVyIGhhdmUgbm8gbG9hZGVycyBvciBoYXZlIGJlZW4gcHJvdmlkZWQgaHlkcmF0aW9uRGF0YVxuICAgICghaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sb2FkZXIpIHx8IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsKTtcblxuICBsZXQgcm91dGVyOiBSb3V0ZXI7XG4gIGxldCBzdGF0ZTogUm91dGVyU3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSkgfHwge30sXG4gICAgYWN0aW9uRGF0YTogKGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSkgfHwgbnVsbCxcbiAgICBlcnJvcnM6IChpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycykgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKCksXG4gIH07XG5cbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uOiBIaXN0b3J5QWN0aW9uID0gSGlzdG9yeUFjdGlvbi5Qb3A7XG5cbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG5cbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcblxuICAvLyBXZSB1c2UgdGhpcyB0byBhdm9pZCB0b3VjaGluZyBoaXN0b3J5IGluIGNvbXBsZXRlTmF2aWdhdGlvbiBpZiBhXG4gIC8vIHJldmFsaWRhdGlvbiBpcyBlbnRpcmVseSB1bmludGVycnVwdGVkXG4gIGxldCBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBmbGFnIHRvIGZvcmNlIHJldmFsaWRhdGlvbiBvZiBhbGwgbG9hZGVyczpcbiAgLy8gIC0gc3VibWlzc2lvbnMgKGNvbXBsZXRlZCBvciBpbnRlcnJ1cHRlZClcbiAgLy8gIC0gdXNlUmV2YWxpZGF0ZSgpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIHJvdXRlcyB0aGF0IHJlcXVpcmUgcmV2YWxpZGF0aW9uIGR1ZVxuICAvLyB0byBhIGNhbmNlbGxlZCBkZWZlcnJlZCBvbiBhY3Rpb24gc3VibWlzc2lvblxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSBmZXRjaGVyIGxvYWRzIHRoYXQgd2VyZSBjYW5jZWxsZWQgYnkgYW5cbiAgLy8gYWN0aW9uIG5hdmlnYXRpb24gYW5kIHJlcXVpcmUgcmV2YWxpZGF0aW9uXG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQWJvcnRDb250cm9sbGVycyBmb3IgYW55IGluLWZsaWdodCBmZXRjaGVyc1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBBYm9ydENvbnRyb2xsZXI+KCk7XG5cbiAgLy8gVHJhY2sgbG9hZHMgYmFzZWQgb24gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgc3RhcnRlZFxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcblxuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XG4gIC8vIHRoZSBnbG9iYWxseSBpbmNyZW1lbnRpbmcgbG9hZCB3aGVuIGEgZmV0Y2hlciBsb2FkIGxhbmRzIGFmdGVyIGEgY29tcGxldGVkXG4gIC8vIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG5cbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9ucyBmcm9tIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBNb3N0IHJlY2VudCBocmVmL21hdGNoIGZvciBmZXRjaGVyLmxvYWQgY2FsbHMgZm9yIGZldGNoZXJzXG4gIGxldCBmZXRjaExvYWRNYXRjaGVzID0gbmV3IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPigpO1xuXG4gIC8vIFN0b3JlIERlZmVycmVkRGF0YSBpbnN0YW5jZXMgZm9yIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLiAgV2hlbiBhXG4gIC8vIHJvdXRlIGxvYWRlciByZXR1cm5zIGRlZmVyKCkgd2Ugc3RpY2sgb25lIGluIGhlcmUuICBUaGVuLCB3aGVuIGEgbmVzdGVkXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxuICAvLyBjYW5jZWwgYWN0aXZlIGRlZmVycmVkcyBmb3IgZWxpbWluYXRlZCByb3V0ZXMuXG4gIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwPHN0cmluZywgRGVmZXJyZWREYXRhPigpO1xuXG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIHRoZXkgY2hhbmdlXG4gIGxldCBibG9ja2VyRnVuY3Rpb25zID0gbmV3IE1hcDxzdHJpbmcsIEJsb2NrZXJGdW5jdGlvbj4oKTtcblxuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxuICAvLyBhIFBPUCBuYXZpZ2F0aW9uIHRoYXQgd2FzIGJsb2NrZWQgYnkgdGhlIHVzZXIgd2l0aG91dCB0b3VjaGluZyByb3V0ZXIgc3RhdGVcbiAgbGV0IGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gZmFsc2U7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgYSBGbHVlbnQgQVBJIGZvciBlYXNlIG9mOlxuICAvLyAgIGxldCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdCkuaW5pdGlhbGl6ZSgpO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElmIGhpc3RvcnkgaW5mb3JtcyB1cyBvZiBhIFBPUCBuYXZpZ2F0aW9uLCBzdGFydCB0aGUgbmF2aWdhdGlvbiBidXQgZG8gbm90IHVwZGF0ZVxuICAgIC8vIHN0YXRlLiAgV2UnbGwgdXBkYXRlIG91ciBvd24gc3RhdGUgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKFxuICAgICAgKHsgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgZGVsdGEgfSkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgICAgLy8gYmxvY2tlZCBQT1AgbmF2aWdhdGlvblxuICAgICAgICBpZiAoaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zaXplID09PSAwIHx8IGRlbHRhICE9IG51bGwsXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiBcIiArXG4gICAgICAgICAgICBcInRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArXG4gICAgICAgICAgICBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICtcbiAgICAgICAgICAgIFwidmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyBcIiArXG4gICAgICAgICAgICBcInJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIFwiICtcbiAgICAgICAgICAgIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGJsb2NrZXJLZXkgPSBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBoaXN0b3J5QWN0aW9uLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgVVJMIHRvIG1hdGNoIHRoZSBjdXJyZW50IFVJLCBidXQgZG9uJ3QgdXBkYXRlIHJvdXRlciBzdGF0ZVxuICAgICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG5cbiAgICAgICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5ISwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIFJlLWRvIHRoZSBzYW1lIFBPUCBuYXZpZ2F0aW9uIHdlIGp1c3QgYmxvY2tlZFxuICAgICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBkZWxldGVCbG9ja2VyKGJsb2NrZXJLZXkhKTtcbiAgICAgICAgICAgICAgdXBkYXRlU3RhdGUoeyBibG9ja2VyczogbmV3IE1hcChyb3V0ZXIuc3RhdGUuYmxvY2tlcnMpIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gS2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWQgaWYgbmVlZGVkLiAgVXNlIFBvcCB0byBhdm9pZCBtb2RpZnlpbmcgaGlzdG9yeVxuICAgIC8vIE5vdGUgd2UgZG9uJ3QgZG8gYW55IGhhbmRsaW5nIG9mIGxhenkgaGVyZS4gIEZvciBTUEEncyBpdCdsbCBnZXQgaGFuZGxlZFxuICAgIC8vIGluIHRoZSBub3JtYWwgbmF2aWdhdGlvbiBmbG93LiAgRm9yIFNTUiBpdCdzIGV4cGVjdGVkIHRoYXQgbGF6eSBtb2R1bGVzIGFyZVxuICAgIC8vIHJlc29sdmVkIHByaW9yIHRvIHJvdXRlciBjcmVhdGlvbiBzaW5jZSB3ZSBjYW4ndCBnbyBpbnRvIGEgZmFsbGJhY2tFbGVtZW50XG4gICAgLy8gVUkgZm9yIFNTUidkIGFwcHNcbiAgICBpZiAoIXN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICBzdGFydE5hdmlnYXRpb24oSGlzdG9yeUFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cblxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm46IFJvdXRlclN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG5cbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZTogUGFydGlhbDxSb3V0ZXJTdGF0ZT4pOiB2b2lkIHtcbiAgICBzdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgfTtcbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyKHN0YXRlKSk7XG4gIH1cblxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBuZXdTdGF0ZTogUGFydGlhbDxPbWl0PFJvdXRlclN0YXRlLCBcImFjdGlvblwiIHwgXCJsb2NhdGlvblwiIHwgXCJuYXZpZ2F0aW9uXCI+PlxuICApOiB2b2lkIHtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9XG4gICAgICBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmXG4gICAgICBsb2NhdGlvbi5zdGF0ZT8uX2lzUmVkaXJlY3QgIT09IHRydWU7XG5cbiAgICBsZXQgYWN0aW9uRGF0YTogUm91dGVEYXRhIHwgbnVsbDtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbXB0eSBhY3Rpb25EYXRhIC0+IGNsZWFyIHByaW9yIGFjdGlvbkRhdGEgZHVlIHRvIGFuIGFjdGlvbiBlcnJvclxuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IGRhdGEgaWYgd2UncmUgd3JhcHBpbmcgdXAgdGhlIGFjdGlvbiByZWxvYWRcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhciBhY3Rpb25EYXRhIG9uIGFueSBvdGhlciBjb21wbGV0ZWQgbmF2aWdhdGlvbnNcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhXG4gICAgICA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgICAgICBzdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgICAgIG5ld1N0YXRlLmxvYWRlckRhdGEsXG4gICAgICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgICAgICBuZXdTdGF0ZS5lcnJvcnNcbiAgICAgICAgKVxuICAgICAgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuXG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBmb3IgKGxldCBba2V5XSBvZiBibG9ja2VyRnVuY3Rpb25zKSB7XG4gICAgICBkZWxldGVCbG9ja2VyKGtleSk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHJlc3BlY3QgdGhlIHVzZXIgZmxhZy4gIE90aGVyd2lzZSBkb24ndCByZXNldCBvbiBtdXRhdGlvblxuICAgIC8vIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnMgdW5sZXNzIHRoZXkgcmVkaXJlY3RcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHxcbiAgICAgIChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJlxuICAgICAgICBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgICAgbG9jYXRpb24uc3RhdGU/Ll9pc1JlZGlyZWN0ICE9PSB0cnVlKTtcblxuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgLi4ubmV3U3RhdGUsIC8vIG1hdGNoZXMsIGVycm9ycywgZmV0Y2hlcnMgZ28gdGhyb3VnaCBhcy1pc1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBuZXdTdGF0ZS5tYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXNcbiAgICAgICksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2VyczogbmV3IE1hcChzdGF0ZS5ibG9ja2VycyksXG4gICAgfSk7XG5cbiAgICBpZiAoaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiB0aGVuIGRvIG5vdCB0b3VjaCBoaXN0b3J5XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBIaXN0b3J5QWN0aW9uLlBvcCkge1xuICAgICAgLy8gRG8gbm90aGluZyBmb3IgUE9QIC0gVVJMIGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5QdXNoKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gSGlzdG9yeUFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBIaXN0b3J5QWN0aW9uLlBvcDtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cblxuICAvLyBUcmlnZ2VyIGEgbmF2aWdhdGlvbiBldmVudCwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBQT1Agb3IgYSBQVVNIXG4gIC8vIHJlcGxhY2Ugd2l0aCBhbiBvcHRpb25hbCBzdWJtaXNzaW9uXG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKFxuICAgIHRvOiBudW1iZXIgfCBUbyxcbiAgICBvcHRzPzogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIHRvLFxuICAgICAgZnV0dXJlLFxuICAgICAgb3B0c1xuICAgICk7XG5cbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBwYXRoLCBvcHRzICYmIG9wdHMuc3RhdGUpO1xuXG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0ge1xuICAgICAgLi4ubmV4dExvY2F0aW9uLFxuICAgICAgLi4uaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbiksXG4gICAgfTtcblxuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIGlmICh1c2VyUmVwbGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkge1xuICAgICAgLy8gbm8tb3BcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgc3VibWlzc2lvbiAhPSBudWxsICYmXG4gICAgICBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkgJiZcbiAgICAgIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2hcbiAgICApIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUmVwbGFjZTtcbiAgICB9XG5cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID1cbiAgICAgIG9wdHMgJiYgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiBpbiBvcHRzXG4gICAgICAgID8gb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uLFxuICAgIH0pO1xuICAgIGlmIChibG9ja2VyS2V5KSB7XG4gICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5ISwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gU2VuZCB0aGUgc2FtZSBuYXZpZ2F0aW9uIHRocm91Z2hcbiAgICAgICAgICBuYXZpZ2F0ZSh0bywgb3B0cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGRlbGV0ZUJsb2NrZXIoYmxvY2tlcktleSEpO1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnM6IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpIH0pO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBuZXh0TG9jYXRpb24sIHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXG4gICAgICAvLyByZW5kZXIgYXQgdGhlIHJpZ2h0IGVycm9yIGJvdW5kYXJ5IGFmdGVyIHdlIG1hdGNoIHJvdXRlc1xuICAgICAgcGVuZGluZ0Vycm9yOiBlcnJvcixcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHJlcGxhY2U6IG9wdHMgJiYgb3B0cy5yZXBsYWNlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2YWxpZGF0ZSBhbGwgY3VycmVudCBsb2FkZXJzLiAgSWYgYSBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzIG9yIGlmIHRoaXNcbiAgLy8gaXMgaW50ZXJydXB0ZWQgYnkgYSBuYXZpZ2F0aW9uLCBhbGxvdyB0aGlzIHRvIFwic3VjY2VlZFwiIGJ5IGNhbGxpbmcgYWxsXG4gIC8vIGxvYWRlcnMgZHVyaW5nIHRoZSBuZXh0IGxvYWRlciByb3VuZFxuICBmdW5jdGlvbiByZXZhbGlkYXRlKCkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgdXBkYXRlU3RhdGUoeyByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiIH0pO1xuXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW4gYW4gaWRsZSBzdGF0ZSwgc3RhcnQgYSBuZXcgbmF2aWdhdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAgICAvLyBhY3Rpb24vbG9jYXRpb24gYW5kIG1hcmsgaXQgYXMgdW5pbnRlcnJ1cHRlZCwgd2hpY2ggd2lsbCBza2lwIHRoZSBoaXN0b3J5XG4gICAgLy8gdXBkYXRlIGluIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgaWYgd2UncmUgY3VycmVudGx5IGluIGEgbG9hZGluZyBzdGF0ZSwganVzdCBzdGFydCBhIG5ld1xuICAgIC8vIG5hdmlnYXRpb24gdG8gdGhlIG5hdmlnYXRpb24ubG9jYXRpb24gYnV0IGRvIG5vdCB0cmlnZ2VyIGFuIHVuaW50ZXJydXB0ZWRcbiAgICAvLyByZXZhbGlkYXRpb24gc28gdGhhdCBoaXN0b3J5IGNvcnJlY3RseSB1cGRhdGVzIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXG4gICAgc3RhcnROYXZpZ2F0aW9uKFxuICAgICAgcGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbixcbiAgICAgIHsgb3ZlcnJpZGVOYXZpZ2F0aW9uOiBzdGF0ZS5uYXZpZ2F0aW9uIH1cbiAgICApO1xuICB9XG5cbiAgLy8gU3RhcnQgYSBuYXZpZ2F0aW9uIHRvIHRoZSBnaXZlbiBhY3Rpb24vbG9jYXRpb24uICBDYW4gb3B0aW9uYWxseSBwcm92aWRlIGFcbiAgLy8gb3ZlcnJpZGVOYXZpZ2F0aW9uIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIG5vcm1hbExvYWQgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdFxuICAvLyBuYXZpZ2F0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmF2aWdhdGlvbihcbiAgICBoaXN0b3J5QWN0aW9uOiBIaXN0b3J5QWN0aW9uLFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBvcHRzPzoge1xuICAgICAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICBmZXRjaGVyU3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gICAgICBvdmVycmlkZU5hdmlnYXRpb24/OiBOYXZpZ2F0aW9uO1xuICAgICAgcGVuZGluZ0Vycm9yPzogRXJyb3JSZXNwb25zZTtcbiAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbj86IGJvb2xlYW47XG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ/OiBib29sZWFuO1xuICAgICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9XG4gICAgICAob3B0cyAmJiBvcHRzLnN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgPT09IHRydWU7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3B0cyAmJiBvcHRzLm92ZXJyaWRlTmF2aWdhdGlvbjtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgaW5pdC5iYXNlbmFtZSk7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgICAgbGV0IHsgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLCByb3V0ZSB9ID1cbiAgICAgICAgZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhyb3V0ZXNUb1VzZSk7XG4gICAgICAvLyBDYW5jZWwgYWxsIHBlbmRpbmcgZGVmZXJyZWQgb24gNDA0cyBzaW5jZSB3ZSBkb24ndCBrZWVwIGFueSByb3V0ZXNcbiAgICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcygpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBpdCdzIG9ubHkgYSBoYXNoIGNoYW5nZSBhbmQgbm90IGEgbXV0YXRpb24gc3VibWlzc2lvblxuICAgIC8vIEZvciBleGFtcGxlLCBvbiAvcGFnZSNoYXNoIGFuZCBzdWJtaXQgYSA8Rm9ybSBtZXRob2Q9XCJwb3N0XCI+IHdoaWNoIHdpbGxcbiAgICAvLyBkZWZhdWx0IHRvIGEgbmF2aWdhdGlvbiB0byAvcGFnZVxuICAgIGlmIChcbiAgICAgIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJlxuICAgICAgIShvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSlcbiAgICApIHtcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgeyBtYXRjaGVzIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNvbnRyb2xsZXIvUmVxdWVzdCBmb3IgdGhpcyBuYXZpZ2F0aW9uXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCByZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwsXG4gICAgICBvcHRzICYmIG9wdHMuc3VibWlzc2lvblxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhOiBSb3V0ZURhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHBlbmRpbmdFcnJvcjogUm91dGVEYXRhIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvcixcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9wdHMgJiZcbiAgICAgIG9wdHMuc3VibWlzc2lvbiAmJlxuICAgICAgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZClcbiAgICApIHtcbiAgICAgIC8vIENhbGwgYWN0aW9uIGlmIHdlIHJlY2VpdmVkIGFuIGFjdGlvbiBzdWJtaXNzaW9uXG4gICAgICBsZXQgYWN0aW9uT3V0cHV0ID0gYXdhaXQgaGFuZGxlQWN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgb3B0cy5zdWJtaXNzaW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICB7IHJlcGxhY2U6IG9wdHMucmVwbGFjZSB9XG4gICAgICApO1xuXG4gICAgICBpZiAoYWN0aW9uT3V0cHV0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuXG4gICAgICBsZXQgbmF2aWdhdGlvbjogTmF2aWdhdGlvblN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIC4uLm9wdHMuc3VibWlzc2lvbixcbiAgICAgIH07XG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbiA9IG5hdmlnYXRpb247XG5cbiAgICAgIC8vIENyZWF0ZSBhIEdFVCByZXF1ZXN0IGZvciB0aGUgbG9hZGVyc1xuICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7IHNpZ25hbDogcmVxdWVzdC5zaWduYWwgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBsb2FkZXJzXG4gICAgbGV0IHsgc2hvcnRDaXJjdWl0ZWQsIGxvYWRlckRhdGEsIGVycm9ycyB9ID0gYXdhaXQgaGFuZGxlTG9hZGVycyhcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkaW5nTmF2aWdhdGlvbixcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLmZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnJlcGxhY2UsXG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YSxcbiAgICAgIHBlbmRpbmdFcnJvclxuICAgICk7XG5cbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBub3cgdGhhdCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZlxuICAgIC8vIHdlIHNob3J0IGNpcmN1aXRlZCBiZWNhdXNlIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciB3aWxsIGhhdmUgYWxyZWFkeVxuICAgIC8vIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgY29udHJvbGxlciBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG5cbiAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICAuLi4ocGVuZGluZ0FjdGlvbkRhdGEgPyB7IGFjdGlvbkRhdGE6IHBlbmRpbmdBY3Rpb25EYXRhIH0gOiB7fSksXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIG1hdGNoZWQgYnkgdGhlIGxlYWYgcm91dGUgZm9yIHRoaXMgbmF2aWdhdGlvbiBhbmQgaGFuZGxlXG4gIC8vIHJlZGlyZWN0cy9lcnJvcnNcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIHN1Ym1pc3Npb246IFN1Ym1pc3Npb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG9wdHM/OiB7IHJlcGxhY2U/OiBib29sZWFuIH1cbiAgKTogUHJvbWlzZTxIYW5kbGVBY3Rpb25SZXN1bHQ+IHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuXG4gICAgLy8gUHV0IHVzIGluIGEgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICB9O1xuICAgIHVwZGF0ZVN0YXRlKHsgbmF2aWdhdGlvbiB9KTtcblxuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcblxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcbiAgICAgICAgXCJhY3Rpb25cIixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYWN0aW9uTWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBkZXRlY3RFcnJvckJvdW5kYXJ5LFxuICAgICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U6IGJvb2xlYW47XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9XG4gICAgICAgICAgcmVzdWx0LmxvY2F0aW9uID09PSBzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSArIHN0YXRlLmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQsIHsgc3VibWlzc2lvbiwgcmVwbGFjZSB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU3RvcmUgb2ZmIHRoZSBwZW5kaW5nIGVycm9yIC0gd2UgdXNlIGl0IHRvIGRldGVybWluZSB3aGljaCBsb2FkZXJzXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgYWN0aW9uTWF0Y2gucm91dGUuaWQpO1xuXG4gICAgICAvLyBCeSBkZWZhdWx0LCBhbGwgc3VibWlzc2lvbnMgYXJlIFJFUExBQ0UgbmF2aWdhdGlvbnMsIGJ1dCBpZiB0aGVcbiAgICAgIC8vIGFjdGlvbiB0aHJldyBhbiBlcnJvciB0aGF0J2xsIGJlIHJlbmRlcmVkIGluIGFuIGVycm9yRWxlbWVudCwgd2UgZmFsbFxuICAgICAgLy8gYmFjayB0byBQVVNIIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0aGUgYmFjayBidXR0b24gdG8gZ2V0IGJhY2sgdG9cbiAgICAgIC8vIHRoZSBwcmUtc3VibWlzc2lvbiBmb3JtIGxvY2F0aW9uIHRvIHRyeSBhZ2FpblxuICAgICAgaWYgKChvcHRzICYmIG9wdHMucmVwbGFjZSkgIT09IHRydWUpIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IEhpc3RvcnlBY3Rpb24uUHVzaDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU2VuZCBiYWNrIGFuIGVtcHR5IG9iamVjdCB3ZSBjYW4gdXNlIHRvIGNsZWFyIG91dCBhbnkgcHJpb3IgYWN0aW9uRGF0YVxuICAgICAgICBwZW5kaW5nQWN0aW9uRGF0YToge30sXG4gICAgICAgIHBlbmRpbmdBY3Rpb25FcnJvcjogeyBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvciB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwgeyB0eXBlOiBcImRlZmVyLWFjdGlvblwiIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YTogeyBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSB9LFxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGFsbCBhcHBsaWNhYmxlIGxvYWRlcnMgZm9yIHRoZSBnaXZlbiBtYXRjaGVzLCBoYW5kbGluZyByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJzKFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbG9jYXRpb246IExvY2F0aW9uLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBvdmVycmlkZU5hdmlnYXRpb24/OiBOYXZpZ2F0aW9uLFxuICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uLFxuICAgIGZldGNoZXJTdWJtaXNzaW9uPzogU3VibWlzc2lvbixcbiAgICByZXBsYWNlPzogYm9vbGVhbixcbiAgICBwZW5kaW5nQWN0aW9uRGF0YT86IFJvdXRlRGF0YSxcbiAgICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGFcbiAgKTogUHJvbWlzZTxIYW5kbGVMb2FkZXJzUmVzdWx0PiB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGlmICghbG9hZGluZ05hdmlnYXRpb24pIHtcbiAgICAgIGxldCBuYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICB9O1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBuYXZpZ2F0aW9uO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2FzIGEgcmVkaXJlY3QgZnJvbSBhbiBhY3Rpb24gd2UgZG9uJ3QgaGF2ZSBhIFwic3VibWlzc2lvblwiIGJ1dFxuICAgIC8vIHdlIGhhdmUgaXQgb24gdGhlIGxvYWRpbmcgbmF2aWdhdGlvbiBzbyB1c2UgdGhhdCBpZiBhdmFpbGFibGVcbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9XG4gICAgICBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uXG4gICAgICAgID8gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvblxuICAgICAgICA6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1NZXRob2QgJiZcbiAgICAgICAgICBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtQWN0aW9uICYmXG4gICAgICAgICAgbG9hZGluZ05hdmlnYXRpb24uZm9ybURhdGEgJiZcbiAgICAgICAgICBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtRW5jVHlwZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2Q6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uOiBsb2FkaW5nTmF2aWdhdGlvbi5mb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybURhdGE6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1EYXRhLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IGxvYWRpbmdOYXZpZ2F0aW9uLmZvcm1FbmNUeXBlLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgW21hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzXSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBhY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkLFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsXG4gICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICBpbml0LmJhc2VuYW1lLFxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEsXG4gICAgICBwZW5kaW5nRXJyb3JcbiAgICApO1xuXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICAgIChyb3V0ZUlkKSA9PlxuICAgICAgICAhKG1hdGNoZXMgJiYgbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHxcbiAgICAgICAgKG1hdGNoZXNUb0xvYWQgJiYgbWF0Y2hlc1RvTG9hZC5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSlcbiAgICApO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXG4gICAgaWYgKG1hdGNoZXNUb0xvYWQubGVuZ3RoID09PSAwICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgIGVycm9yczogcGVuZGluZ0Vycm9yIHx8IG51bGwsXG4gICAgICAgIC4uLihwZW5kaW5nQWN0aW9uRGF0YSA/IHsgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGEgfSA6IHt9KSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9uLCB3ZSByZW1haW4gaW4gb3VyIGN1cnJlbnQgaWRsZVxuICAgIC8vIHN0YXRlLiAgSWYgbm90LCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBvdXIgbG9hZGluZyBzdGF0ZSBhbmQgbG9hZCBkYXRhLFxuICAgIC8vIHByZXNlcnZpbmcgYW55IG5ldyBhY3Rpb24gZGF0YSBvciBleGlzdGluZyBhY3Rpb24gZGF0YSAoaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyBhIHJldmFsaWRhdGlvbiBpbnRlcnJ1cHRpbmcgYW4gYWN0aW9uUmVsb2FkKVxuICAgIGlmICghaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChyZi5rZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIkxvYWRpbmdcIl0gPSB7XG4gICAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgIGRhdGE6IGZldGNoZXIgJiYgZmV0Y2hlci5kYXRhLFxuICAgICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQocmYua2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGFjdGlvbkRhdGEgPSBwZW5kaW5nQWN0aW9uRGF0YSB8fCBzdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBuYXZpZ2F0aW9uOiBsb2FkaW5nTmF2aWdhdGlvbixcbiAgICAgICAgLi4uKGFjdGlvbkRhdGFcbiAgICAgICAgICA/IE9iamVjdC5rZXlzKGFjdGlvbkRhdGEpLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyB7IGFjdGlvbkRhdGE6IG51bGwgfVxuICAgICAgICAgICAgOiB7IGFjdGlvbkRhdGEgfVxuICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4ocmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMFxuICAgICAgICAgID8geyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfVxuICAgICAgICAgIDoge30pLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT5cbiAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyISlcbiAgICApO1xuXG4gICAgbGV0IHsgcmVzdWx0cywgbG9hZGVyUmVzdWx0cywgZmV0Y2hlclJlc3VsdHMgfSA9XG4gICAgICBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoXG4gICAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLFxuICAgICAgICByZXF1ZXN0XG4gICAgICApO1xuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgX2FmdGVyXyBsb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWYgd2Ugc2hvcnRcbiAgICAvLyBjaXJjdWl0ZWQgYmVjYXVzZSBmZXRjaENvbnRyb2xsZXJzIHdvdWxkIGhhdmUgYmVlbiBhYm9ydGVkIGFuZFxuICAgIC8vIHJlYXNzaWduZWQgdG8gbmV3IGNvbnRyb2xsZXJzIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocmYpID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHJmLmtleSkpO1xuXG4gICAgLy8gSWYgYW55IGxvYWRlcnMgcmV0dXJuZWQgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlZGlyZWN0LCB7IHJlcGxhY2UgfSk7XG4gICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgcGVuZGluZ0Vycm9yLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgIGFjdGl2ZURlZmVycmVkc1xuICAgICk7XG5cbiAgICAvLyBXaXJlIHVwIHN1YnNjcmliZXJzIHRvIHVwZGF0ZSBsb2FkZXJEYXRhIGFzIHByb21pc2VzIHNldHRsZVxuICAgIGFjdGl2ZURlZmVycmVkcy5mb3JFYWNoKChkZWZlcnJlZERhdGEsIHJvdXRlSWQpID0+IHtcbiAgICAgIGRlZmVycmVkRGF0YS5zdWJzY3JpYmUoKGFib3J0ZWQpID0+IHtcbiAgICAgICAgLy8gTm90ZTogTm8gbmVlZCB0byB1cGRhdGVTdGF0ZSBoZXJlIHNpbmNlIHRoZSBUcmFja2VkUHJvbWlzZSBvblxuICAgICAgICAvLyBsb2FkZXJEYXRhIGlzIHN0YWJsZSBhY3Jvc3MgcmVzb2x2ZS9yZWplY3RcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgaW5zdGFuY2UgaWYgd2Ugd2VyZSBhYm9ydGVkIG9yIGlmIHByb21pc2VzIGhhdmUgc2V0dGxlZFxuICAgICAgICBpZiAoYWJvcnRlZCB8fCBkZWZlcnJlZERhdGEuZG9uZSkge1xuICAgICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgIGxldCBkaWRBYm9ydEZldGNoTG9hZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9ycyxcbiAgICAgIC4uLihkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMFxuICAgICAgICA/IHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH1cbiAgICAgICAgOiB7fSksXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZldGNoZXI8VERhdGEgPSBhbnk+KGtleTogc3RyaW5nKTogRmV0Y2hlcjxURGF0YT4ge1xuICAgIHJldHVybiBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIH1cblxuICAvLyBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pdCBmb3IgdGhlIGdpdmVuIGZldGNoZXIga2V5XG4gIGZ1bmN0aW9uIGZldGNoKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBocmVmOiBzdHJpbmcsXG4gICAgb3B0cz86IFJvdXRlckZldGNoT3B0aW9uc1xuICApIHtcbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJyb3V0ZXIuZmV0Y2goKSB3YXMgY2FsbGVkIGR1cmluZyB0aGUgc2VydmVyIHJlbmRlciwgYnV0IGl0IHNob3VsZG4ndCBiZS4gXCIgK1xuICAgICAgICAgIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyBhIHVzZUZldGNoZXIoKSBtZXRob2QgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICtcbiAgICAgICAgICBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG5cbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBocmVmLCBpbml0LmJhc2VuYW1lKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkLFxuICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogaHJlZiB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBzdWJtaXNzaW9uIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gICAgICBocmVmLFxuICAgICAgZnV0dXJlLFxuICAgICAgb3B0cyxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuXG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcblxuICAgIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBvZmYgdGhlIG1hdGNoIHNvIHdlIGNhbiBjYWxsIGl0J3Mgc2hvdWxkUmV2YWxpZGF0ZSBvbiBzdWJzZXF1ZW50XG4gICAgLy8gcmV2YWxpZGF0aW9uc1xuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoIH0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcmVxdWVzdE1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBzdWJtaXNzaW9uOiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcblxuICAgIGlmICghbWF0Y2gucm91dGUuYWN0aW9uICYmICFtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlSWQsXG4gICAgICB9KTtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiU3VibWl0dGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgJiYgZXhpc3RpbmdGZXRjaGVyLmRhdGEsXG4gICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgZmV0Y2hlclxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgcGF0aCxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG5cbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgcmVxdWVzdE1hdGNoZXMsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICApO1xuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChrZXkpO1xuICAgICAgbGV0IGxvYWRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAuLi5zdWJtaXNzaW9uLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRpbmdGZXRjaGVyKTtcbiAgICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIGFjdGlvblJlc3VsdCwge1xuICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICBpc0ZldGNoQWN0aW9uUmVkaXJlY3Q6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFueSBub24tcmVkaXJlY3QgZXJyb3JzIHRocm93blxuICAgIGlmIChpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJkZWZlci1hY3Rpb25cIiB9KTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGF0YSBsb2FkIGZvciBjdXJyZW50IG1hdGNoZXMsIG9yIHRoZSBuZXh0IGxvY2F0aW9uIGlmIHdlJ3JlXG4gICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhIG5hdmlnYXRpb25cbiAgICBsZXQgbmV4dExvY2F0aW9uID0gc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiB8fCBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgaW5pdC5oaXN0b3J5LFxuXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9XG4gICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIlxuICAgICAgICA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBpbml0LmJhc2VuYW1lKVxuICAgICAgICA6IHN0YXRlLm1hdGNoZXM7XG5cbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcblxuICAgIGxldCBsb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBmZXRjaFJlbG9hZElkcy5zZXQoa2V5LCBsb2FkSWQpO1xuXG4gICAgbGV0IGxvYWRGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGRhdGE6IGFjdGlvblJlc3VsdC5kYXRhLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuXG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgaW5pdC5oaXN0b3J5LFxuICAgICAgc3RhdGUsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsXG4gICAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoTG9hZE1hdGNoZXMsXG4gICAgICByb3V0ZXNUb1VzZSxcbiAgICAgIGluaXQuYmFzZW5hbWUsXG4gICAgICB7IFttYXRjaC5yb3V0ZS5pZF06IGFjdGlvblJlc3VsdC5kYXRhIH0sXG4gICAgICB1bmRlZmluZWQgLy8gTm8gbmVlZCB0byBzZW5kIHRocm91Z2ggZXJyb3JzIHNpbmNlIHdlIHNob3J0IGNpcmN1aXQgYWJvdmVcbiAgICApO1xuXG4gICAgLy8gUHV0IGFsbCByZXZhbGlkYXRpbmcgZmV0Y2hlcnMgaW50byB0aGUgbG9hZGluZyBzdGF0ZSwgZXhjZXB0IGZvciB0aGVcbiAgICAvLyBjdXJyZW50IGZldGNoZXIgd2hpY2ggd2Ugd2FudCB0byBrZWVwIGluIGl0J3MgY3VycmVudCBsb2FkaW5nIHN0YXRlIHdoaWNoXG4gICAgLy8gY29udGFpbnMgaXQncyBhY3Rpb24gc3VibWlzc2lvbiBpbmZvICsgYWN0aW9uIGRhdGFcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVyc1xuICAgICAgLmZpbHRlcigocmYpID0+IHJmLmtleSAhPT0ga2V5KVxuICAgICAgLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChzdGFsZUtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgZGF0YTogZXhpc3RpbmdGZXRjaGVyICYmIGV4aXN0aW5nRmV0Y2hlci5kYXRhLFxuICAgICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgIH0pO1xuXG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG5cbiAgICBsZXQgeyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID1cbiAgICAgIGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3RcbiAgICAgICk7XG5cbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyLmtleSkpO1xuXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnMgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKFxuICAgICAgc3RhdGUsXG4gICAgICBzdGF0ZS5tYXRjaGVzLFxuICAgICAgbWF0Y2hlc1RvTG9hZCxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICBkYXRhOiBhY3Rpb25SZXN1bHQuZGF0YSxcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG5cbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcblxuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBuYXZpZ2F0aW9uIGxvYWRpbmcgc3RhdGUgYW5kIHRoaXMgZmV0Y2hlciBpc1xuICAgIC8vIG1vcmUgcmVjZW50IHRoYW4gdGhlIG5hdmlnYXRpb24sIHdlIHdhbnQgdGhlIG5ld2VyIGRhdGEgc28gYWJvcnQgdGhlXG4gICAgLy8gbmF2aWdhdGlvbiBhbmQgY29tcGxldGUgaXQgd2l0aCB0aGUgZmV0Y2hlciBkYXRhXG4gICAgaWYgKFxuICAgICAgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiZcbiAgICAgIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkXG4gICAgKSB7XG4gICAgICBpbnZhcmlhbnQocGVuZGluZ0FjdGlvbiwgXCJFeHBlY3RlZCBwZW5kaW5nIGFjdGlvblwiKTtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcblxuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgdXBkYXRlIHdpdGggdGhlIGZldGNoZXIgZGF0YSwgcHJlc2VydmluZyBhbnkgZXhpc3RpbmdcbiAgICAgIC8vIGxvYWRlckRhdGEgZm9yIGxvYWRlcnMgdGhhdCBkaWQgbm90IG5lZWQgdG8gcmVsb2FkLiAgV2UgaGF2ZSB0b1xuICAgICAgLy8gbWFudWFsbHkgbWVyZ2UgaGVyZSBzaW5jZSB3ZSBhcmVuJ3QgZ29pbmcgdGhyb3VnaCBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgICksXG4gICAgICAgIC4uLihkaWRBYm9ydEZldGNoTG9hZHMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge30pLFxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCB0aGUgbWF0Y2hlZCBsb2FkZXIgZm9yIGZldGNoZXIubG9hZCgpLCBoYW5kbGluZyByZWRpcmVjdHMsIGVycm9ycywgZXRjLlxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyTG9hZGVyKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHJvdXRlSWQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uXG4gICkge1xuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBsb2FkaW5nIHN0YXRlXG4gICAgbGV0IGxvYWRpbmdGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiTG9hZGluZ1wiXSA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciAmJiBleGlzdGluZ0ZldGNoZXIuZGF0YSxcbiAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZGluZ0ZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHsgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgbG9hZGVyIGZvciB0aGlzIGZldGNoZXIgcm91dGUgbWF0Y2hcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG5cbiAgICBsZXQgcmVzdWx0OiBEYXRhUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgXCJsb2FkZXJcIixcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgZGV0ZWN0RXJyb3JCb3VuZGFyeSxcbiAgICAgIHJvdXRlci5iYXNlbmFtZVxuICAgICk7XG5cbiAgICAvLyBEZWZlcnJlZCBpc24ndCBzdXBwb3J0ZWQgZm9yIGZldGNoZXIgbG9hZHMsIGF3YWl0IGV2ZXJ5dGhpbmcgYW5kIHRyZWF0IGl0XG4gICAgLy8gYXMgYSBub3JtYWwgbG9hZC4gIHJlc29sdmVEZWZlcnJlZERhdGEgd2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoaXNcbiAgICAvLyBmZXRjaGVyIGdldHMgYWJvcnRlZCwgc28gd2UganVzdCBsZWF2ZSByZXN1bHQgdW50b3VjaGVkIGFuZCBzaG9ydCBjaXJjdWl0XG4gICAgLy8gYmVsb3cgaWYgdGhhdCBoYXBwZW5zXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID1cbiAgICAgICAgKGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBmZXRjaFJlcXVlc3Quc2lnbmFsLCB0cnVlKSkgfHxcbiAgICAgICAgcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdSBvdXIgb3duIGZldGNoZXJcbiAgICAvLyByZS1sb2FkIHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb2FkZXIgdGhyZXcgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIC8vIFRPRE86IEluIHJlbWl4LCB0aGlzIHdvdWxkIHJlc2V0IHRvIElETEVfTkFWSUdBVElPTiBpZiBpdCB3YXMgYSBjYXRjaCAtXG4gICAgICAvLyBkbyB3ZSBuZWVkIHRvIGJlaGF2ZSBhbnkgZGlmZmVyZW50bHkgd2l0aCBvdXIgbm9uLXJlZGlyZWN0IGVycm9ycz9cbiAgICAgIC8vIFdoYXQgaWYgaXQgd2FzIGEgbm9uLXJlZGlyZWN0IFJlc3BvbnNlP1xuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcblxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIGxldCBkb25lRmV0Y2hlcjogRmV0Y2hlclN0YXRlc1tcIklkbGVcIl0gPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgXCIgX2hhc0ZldGNoZXJEb25lQW55dGhpbmcgXCI6IHRydWUsXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cbiAgICogTm9ybWFsbHksIGEgcmVkaXJlY3QgXCJyZXBsYWNlc1wiIHRoZSBuYXZpZ2F0aW9uIHRoYXQgdHJpZ2dlcmVkIGl0LiAgU28sIGZvclxuICAgKiBleGFtcGxlOlxuICAgKlxuICAgKiAgLSB1c2VyIGlzIG9uIC9hXG4gICAqICAtIHVzZXIgY2xpY2tzIGEgbGluayB0byAvYlxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xuICAgKlxuICAgKiBJbiBhIG5vbi1KUyBhcHAgdGhlIGJyb3dzZXIgd291bGQgdHJhY2sgdGhlIGluLWZsaWdodCBuYXZpZ2F0aW9uIHRvIC9iIGFuZFxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXG4gICAqIHRoZSBlbmQgaXQgd291bGQgb25seSBldmVyIHVwZGF0ZSB0aGUgVVJMIGJhciB3aXRoIC9jLlxuICAgKlxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXG4gICAqIHRoaXMgYmVoYXZpb3IgYW5kIHdlIGFsc28gZG8gbm90IHVwZGF0ZSBoaXN0b3J5IHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gICAqIG5hdmlnYXRpb24gKGluY2x1ZGluZyBwcm9jZXNzZWQgcmVkaXJlY3RzKS4gIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZXZlclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXG4gICAqIHRoZSBoaXN0b3J5IGFjdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uIChQVVNIIG9yIFJFUExBQ0UpLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICAgIHJlZGlyZWN0OiBSZWRpcmVjdFJlc3VsdCxcbiAgICB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIGlzRmV0Y2hBY3Rpb25SZWRpcmVjdCxcbiAgICB9OiB7XG4gICAgICBzdWJtaXNzaW9uPzogU3VibWlzc2lvbjtcbiAgICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgICAgaXNGZXRjaEFjdGlvblJlZGlyZWN0PzogYm9vbGVhbjtcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgaWYgKHJlZGlyZWN0LnJldmFsaWRhdGUpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJlZGlyZWN0LmxvY2F0aW9uLFxuICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHdlIGdldCByaWQgb2YgdXNlVHJhbnNpdGlvbiBpbiBSZW1peCB2MlxuICAgICAge1xuICAgICAgICBfaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgLi4uKGlzRmV0Y2hBY3Rpb25SZWRpcmVjdCA/IHsgX2lzRmV0Y2hBY3Rpb25SZWRpcmVjdDogdHJ1ZSB9IDoge30pLFxuICAgICAgfVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIFwiRXhwZWN0ZWQgYSBsb2NhdGlvbiBvbiB0aGUgcmVkaXJlY3QgbmF2aWdhdGlvblwiXG4gICAgKTtcbiAgICAvLyBDaGVjayBpZiB0aGlzIGFuIGFic29sdXRlIGV4dGVybmFsIHJlZGlyZWN0IHRoYXQgZ29lcyB0byBhIG5ldyBvcmlnaW5cbiAgICBpZiAoXG4gICAgICBBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyZWRpcmVjdC5sb2NhdGlvbikgJiZcbiAgICAgIGlzQnJvd3NlciAmJlxuICAgICAgdHlwZW9mIHdpbmRvdz8ubG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCJcbiAgICApIHtcbiAgICAgIGxldCB1cmwgPSBpbml0Lmhpc3RvcnkuY3JlYXRlVVJMKHJlZGlyZWN0LmxvY2F0aW9uKTtcbiAgICAgIGxldCBpc0RpZmZlcmVudEJhc2VuYW1lID1cbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGluaXQuYmFzZW5hbWUgfHwgXCIvXCIpID09IG51bGw7XG5cbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSB1cmwub3JpZ2luIHx8IGlzRGlmZmVyZW50QmFzZW5hbWUpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBhYm9ydCBvbiByZWRpcmVjdHMsIHNpbmNlIHdlIGRvbid0IGRldGVjdCB0aGVcbiAgICAvLyByZWRpcmVjdCB1bnRpbCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBzZXR0bGVkXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcblxuICAgIGxldCByZWRpcmVjdEhpc3RvcnlBY3Rpb24gPVxuICAgICAgcmVwbGFjZSA9PT0gdHJ1ZSA/IEhpc3RvcnlBY3Rpb24uUmVwbGFjZSA6IEhpc3RvcnlBY3Rpb24uUHVzaDtcblxuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1EYXRhIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmICghc3VibWlzc2lvbiAmJiBmb3JtTWV0aG9kICYmIGZvcm1BY3Rpb24gJiYgZm9ybURhdGEgJiYgZm9ybUVuY1R5cGUpIHtcbiAgICAgIHN1Ym1pc3Npb24gPSB7XG4gICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBpZiAoXG4gICAgICByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMuaGFzKHJlZGlyZWN0LnN0YXR1cykgJiZcbiAgICAgIHN1Ym1pc3Npb24gJiZcbiAgICAgIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKVxuICAgICkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgICAgICBmb3JtQWN0aW9uOiByZWRpcmVjdC5sb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcyBmbGFnIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc0ZldGNoQWN0aW9uUmVkaXJlY3QpIHtcbiAgICAgIC8vIEZvciBhIGZldGNoIGFjdGlvbiByZWRpcmVjdCwgd2Uga2ljayBvZmYgYSBuZXcgbG9hZGluZyBuYXZpZ2F0aW9uXG4gICAgICAvLyB3aXRob3V0IHRoZSBmZXRjaGVyIHN1Ym1pc3Npb24sIGJ1dCB3ZSBzZW5kIGl0IGFsb25nIGZvciBzaG91bGRSZXZhbGlkYXRlXG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjoge1xuICAgICAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgICAgICBsb2NhdGlvbjogcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGtpY2sgb2ZmIGEgbmV3IGxvYWRpbmcgbmF2aWdhdGlvbiwgcHJlc2VydmluZyB0aGVcbiAgICAgIC8vIHN1Ym1pc3Npb24gaW5mbyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgbmF2aWdhdGlvblxuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb246IHtcbiAgICAgICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgbG9jYXRpb246IHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbiA/IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtQWN0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uID8gc3VibWlzc2lvbi5mb3JtRW5jVHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtRGF0YTogc3VibWlzc2lvbiA/IHN1Ym1pc3Npb24uZm9ybURhdGEgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShcbiAgICBjdXJyZW50TWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgICBtYXRjaGVzVG9Mb2FkOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgZmV0Y2hlcnNUb0xvYWQ6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgICByZXF1ZXN0OiBSZXF1ZXN0XG4gICkge1xuICAgIC8vIENhbGwgYWxsIG5hdmlnYXRpb24gbG9hZGVycyBhbmQgcmV2YWxpZGF0aW5nIGZldGNoZXIgbG9hZGVycyBpbiBwYXJhbGxlbCxcbiAgICAvLyB0aGVuIHNsaWNlIG9mZiB0aGUgcmVzdWx0cyBpbnRvIHNlcGFyYXRlIGFycmF5cyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW1cbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgZGV0ZWN0RXJyb3JCb3VuZGFyeSxcbiAgICAgICAgICByb3V0ZXIuYmFzZW5hbWVcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIC4uLmZldGNoZXJzVG9Mb2FkLm1hcCgoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCByZXF1ZXN0LnNpZ25hbCksXG4gICAgICAgICAgICBmLm1hdGNoLFxuICAgICAgICAgICAgZi5tYXRjaGVzLFxuICAgICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgICBkZXRlY3RFcnJvckJvdW5kYXJ5LFxuICAgICAgICAgICAgcm91dGVyLmJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZXJyb3I6IEVycm9yUmVzdWx0ID0ge1xuICAgICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogZi5wYXRoIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICBdKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UobWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhcbiAgICAgICAgY3VycmVudE1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YVxuICAgICAgKSxcbiAgICAgIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gICAgICAgIGN1cnJlbnRNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyc1RvTG9hZC5tYXAoKGYpID0+IGYubWF0Y2gpLFxuICAgICAgICBmZXRjaGVyUmVzdWx0cyxcbiAgICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICAgIHRydWVcbiAgICAgICksXG4gICAgXSk7XG5cbiAgICByZXR1cm4geyByZXN1bHRzLCBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG5cbiAgICAvLyBDYW5jZWwgcGVuZGluZyByb3V0ZS1sZXZlbCBkZWZlcnJlZHMgYW5kIG1hcmsgY2FuY2VsbGVkIHJvdXRlcyBmb3JcbiAgICAvLyByZXZhbGlkYXRpb25cbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcy5wdXNoKC4uLmNhbmNlbEFjdGl2ZURlZmVycmVkcygpKTtcblxuICAgIC8vIEFib3J0IGluLWZsaWdodCBmZXRjaGVyIGxvYWRzXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5wdXNoKGtleSk7XG4gICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleTogc3RyaW5nLCByb3V0ZUlkOiBzdHJpbmcsIGVycm9yOiBhbnkpIHtcbiAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoc3RhdGUubWF0Y2hlcywgcm91dGVJZCk7XG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGVycm9yczoge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yLFxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleTogc3RyaW5nKSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBgRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogJHtrZXl9YCk7XG4gICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXM6IHN0cmluZ1tdKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICBkYXRhOiBmZXRjaGVyLmRhdGEsXG4gICAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBcIiBfaGFzRmV0Y2hlckRvbmVBbnl0aGluZyBcIjogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpOiB2b2lkIHtcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIGBFeHBlY3RlZCBmZXRjaGVyOiAke2tleX1gKTtcbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tlcihrZXk6IHN0cmluZywgZm46IEJsb2NrZXJGdW5jdGlvbikge1xuICAgIGxldCBibG9ja2VyOiBCbG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuZ2V0KGtleSkgIT09IGZuKSB7XG4gICAgICBibG9ja2VyRnVuY3Rpb25zLnNldChrZXksIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUJsb2NrZXIoa2V5OiBzdHJpbmcpIHtcbiAgICBzdGF0ZS5ibG9ja2Vycy5kZWxldGUoa2V5KTtcbiAgICBibG9ja2VyRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5OiBzdHJpbmcsIG5ld0Jsb2NrZXI6IEJsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcblxuICAgIC8vIFBvb3IgbWFucyBzdGF0ZSBtYWNoaW5lIDopXG4gICAgLy8gaHR0cHM6Ly9tZXJtYWlkLmxpdmUvZWRpdCNwYWtvOmVOcVZrYzlPd3pBTXhsOGw4bm5qQVlyRXRESU9IRUJJZ3d2S0pUUmVHeTNfbERwSXFPMjdrNmF3TUcwWGNyTGxuejg3bndkb25FU29nS1hYQnVFNzlycTc1WFpPMy15SGRzMFJKVnV2NzBZclBsVXJDRWUySGZyT1JTM3J1YnFaZnVodHBnNUM5d2s1dFo0VktjUlVxODhxOVo4UlMwLTQ4Y0UxaUhKa0wwdWdiSHVGTHVzOUw2c3BaeThuWDlNUDJDTmRvbVZhcG9zcXUzZkdheVQ4VDgtakpRd2hlcG9fVXRwZ0JRYURFVW9tMDRkWmhBTjFhSkJEbFVLSkJ4RTFjZUIyU21qME1sbi1JQlc1QUZVMmR3VWlrdHRfMlFhcTJkQmZhS2RFdXA4NVVWN1lkLWRLamxua2FibDJQdnIwRFRrVHJlTVxuICAgIGludmFyaWFudChcbiAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB8fFxuICAgICAgICAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikgfHxcbiAgICAgICAgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIpIHx8XG4gICAgICAgIChibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiKSxcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG5cbiAgICBzdGF0ZS5ibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzOiBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgY3VycmVudExvY2F0aW9uLFxuICAgIG5leHRMb2NhdGlvbixcbiAgICBoaXN0b3J5QWN0aW9uLFxuICB9OiB7XG4gICAgY3VycmVudExvY2F0aW9uOiBMb2NhdGlvbjtcbiAgICBuZXh0TG9jYXRpb246IExvY2F0aW9uO1xuICAgIGhpc3RvcnlBY3Rpb246IEhpc3RvcnlBY3Rpb247XG4gIH0pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuXG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG5cbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgLy8gSWYgdGhlIGJsb2NrZXIgaXMgY3VycmVudGx5IHByb2NlZWRpbmcsIHdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2tcbiAgICAgIC8vIGl0IGFuZCBjYW4gbGV0IHRoaXMgbmF2aWdhdGlvbiBjb250aW51ZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHsgY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24sIGhpc3RvcnlBY3Rpb24gfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhcbiAgICBwcmVkaWNhdGU/OiAocm91dGVJZDogc3RyaW5nKSA9PiBib29sZWFuXG4gICk6IHN0cmluZ1tdIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHM6IHN0cmluZ1tdID0gW107XG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRmZCwgcm91dGVJZCkgPT4ge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHJvdXRlSWQpKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVmZXJyZWQgLSBidXQgZG8gbm90IHJlbW92ZSBmcm9tIGFjdGl2ZURlZmVycmVkcyBoZXJlIC1cbiAgICAgICAgLy8gd2UgcmVseSBvbiB0aGUgc3Vic2NyaWJlcnMgdG8gZG8gdGhhdCBzbyBvdXIgdGVzdHMgY2FuIGFzc2VydCBwcm9wZXJcbiAgICAgICAgLy8gY2xlYW51cCB2aWEgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzXG4gICAgICAgIGRmZC5jYW5jZWwoKTtcbiAgICAgICAgY2FuY2VsbGVkUm91dGVJZHMucHVzaChyb3V0ZUlkKTtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsbGVkUm91dGVJZHM7XG4gIH1cblxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKFxuICAgIHBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBnZXRQb3NpdGlvbjogR2V0U2Nyb2xsUG9zaXRpb25GdW5jdGlvbixcbiAgICBnZXRLZXk/OiBHZXRTY3JvbGxSZXN0b3JhdGlvbktleUZ1bmN0aW9uXG4gICkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgKChsb2NhdGlvbikgPT4gbG9jYXRpb24ua2V5KTtcblxuICAgIC8vIFBlcmZvcm0gaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLCBzaW5jZSB3ZSBtaXNzIHRoZSBib2F0IG9uXG4gICAgLy8gdGhlIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBiZWNhdXNlIHdlJ3ZlIG5vdCB5ZXQgcmVuZGVyZWQgPFNjcm9sbFJlc3RvcmF0aW9uLz5cbiAgICAvLyBhbmQgdGhlcmVmb3JlIGhhdmUgbm8gc2F2ZWRTY3JvbGxQb3NpdGlvbnMgYXZhaWxhYmxlXG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKFxuICAgIGxvY2F0aW9uOiBMb2NhdGlvbixcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQgdXNlck1hdGNoZXMgPSBtYXRjaGVzLm1hcCgobSkgPT5cbiAgICAgICAgY3JlYXRlVXNlTWF0Y2hlc01hdGNoKG0sIHN0YXRlLmxvYWRlckRhdGEpXG4gICAgICApO1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uLCB1c2VyTWF0Y2hlcykgfHwgbG9jYXRpb24ua2V5O1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdXG4gICk6IG51bWJlciB8IG51bGwge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IHVzZXJNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG0pID0+XG4gICAgICAgIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKVxuICAgICAgKTtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgdXNlck1hdGNoZXMpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdFtdKSB7XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gbmV3Um91dGVzO1xuICB9XG5cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBpbml0LmJhc2VuYW1lO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2gsXG4gICAgcmV2YWxpZGF0ZSxcbiAgICAvLyBQYXNzdGhyb3VnaCB0byBoaXN0b3J5LWF3YXJlIGNyZWF0ZUhyZWYgdXNlZCBieSB1c2VIcmVmIHNvIHdlIGdldCBwcm9wZXJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXG4gICAgY3JlYXRlSHJlZjogKHRvOiBUbykgPT4gaW5pdC5oaXN0b3J5LmNyZWF0ZUhyZWYodG8pLFxuICAgIGVuY29kZUxvY2F0aW9uOiAodG86IFRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzLFxuICB9O1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVTdGF0aWNIYW5kbGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgY29uc3QgVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCA9IFN5bWJvbChcImRlZmVycmVkXCIpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVN0YXRpY0hhbmRsZXJPcHRpb25zIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGRldGVjdEVycm9yQm91bmRhcnk/OiBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKFxuICByb3V0ZXM6IEFnbm9zdGljUm91dGVPYmplY3RbXSxcbiAgb3B0cz86IENyZWF0ZVN0YXRpY0hhbmRsZXJPcHRpb25zXG4pOiBTdGF0aWNIYW5kbGVyIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG5cbiAgbGV0IG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0ID0ge307XG4gIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID1cbiAgICBvcHRzPy5kZXRlY3RFcnJvckJvdW5kYXJ5IHx8IGRlZmF1bHREZXRlY3RFcnJvckJvdW5kYXJ5O1xuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgcm91dGVzLFxuICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgdW5kZWZpbmVkLFxuICAgIG1hbmlmZXN0XG4gICk7XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuXG4gIC8qKlxuICAgKiBUaGUgcXVlcnkoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGRvY3VtZW50IHJlcXVlc3RzLCBpbiB3aGljaCB3ZSB3YW50IHRvXG4gICAqIGNhbGwgYW4gb3B0aW9uYWwgYWN0aW9uIGFuZCBwb3RlbnRpYWxseSBtdWx0aXBsZSBsb2FkZXJzIGZvciBhbGwgbmVzdGVkXG4gICAqIHJvdXRlcy4gIEl0IHJldHVybnMgYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBvYmplY3QsIHdoaWNoIGlzIHZlcnkgc2ltaWxhclxuICAgKiB0byB0aGUgcm91dGVyIHN0YXRlIChsb2NhdGlvbiwgbG9hZGVyRGF0YSwgYWN0aW9uRGF0YSwgZXJyb3JzLCBldGMuKSBhbmRcbiAgICogYWxzbyBhZGRzIFNTUi1zcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSBzdGF0dXNDb2RlIGFuZCBoZWFkZXJzXG4gICAqIGZyb20gYWN0aW9uL2xvYWRlcnMgUmVzcG9uc2VzLlxuICAgKlxuICAgKiBJdCBfc2hvdWxkXyBuZXZlciB0aHJvdyBhbmQgc2hvdWxkIHJlcG9ydCBhbGwgZXJyb3JzIHRocm91Z2ggdGhlXG4gICAqIHJldHVybmVkIGNvbnRleHQuZXJyb3JzIG9iamVjdCwgcHJvcGVybHkgYXNzb2NpYXRpbmcgZXJyb3JzIHRvIHRoZWlyIGVycm9yXG4gICAqIGJvdW5kYXJ5LiAgQWRkaXRpb25hbGx5LCBpdCB0cmFja3MgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgd2hpY2ggY2FuIGJlXG4gICAqIHVzZWQgdG8gZW11bGF0ZSBSZWFjdCBlcnJvciBib3VuZGFyaWVzIGR1cmluZyBTU3IgYnkgcGVyZm9ybWluZyBhIHNlY29uZFxuICAgKiBwYXNzIG9ubHkgZG93biB0byB0aGUgYm91bmRhcnlJZC5cbiAgICpcbiAgICogVGhlIG9uZSBleGNlcHRpb24gd2hlcmUgd2UgZG8gbm90IHJldHVybiBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IGlzIHdoZW4gYVxuICAgKiByZWRpcmVjdCByZXNwb25zZSBpcyByZXR1cm5lZCBvciB0aHJvd24gZnJvbSBhbnkgYWN0aW9uL2xvYWRlci4gIFdlXG4gICAqIHByb3BhZ2F0ZSB0aGF0IG91dCBhbmQgcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugc28gdGhlIEhUVFAgc2VydmVyIGNhblxuICAgKiByZXR1cm4gaXQgZGlyZWN0bHkuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHsgcmVxdWVzdENvbnRleHQgfTogeyByZXF1ZXN0Q29udGV4dD86IHVua25vd24gfSA9IHt9XG4gICk6IFByb21pc2U8U3RhdGljSGFuZGxlckNvbnRleHQgfCBSZXNwb25zZT4ge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuXG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgICBsZXQgeyBtYXRjaGVzOiBtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3IsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9XG4gICAgICAgIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHJldHVybmluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCwgd2UgcGF0Y2ggYmFjayBpbiB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIHNpbmNlIHdlIG5lZWQgaXQgZm9yIFJlYWN0IENvbnRleHQuICBCdXQgdGhpcyBoZWxwcyBrZWVwIG91ciBzdWJtaXQgYW5kXG4gICAgLy8gbG9hZFJvdXRlRGF0YSBvcGVyYXRpbmcgb24gYSBSZXF1ZXN0IGluc3RlYWQgb2YgYSBMb2NhdGlvblxuICAgIHJldHVybiB7IGxvY2F0aW9uLCBiYXNlbmFtZSwgLi4ucmVzdWx0IH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIHF1ZXJ5Um91dGUoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIHRhcmdldGVkIHJvdXRlIHJlcXVlc3RzLCBlaXRoZXJcbiAgICogZm9yIGZldGNoID9fZGF0YSByZXF1ZXN0cyBvciByZXNvdXJjZSByb3V0ZSByZXF1ZXN0cy4gIEluIHRoaXMgY2FzZSwgd2VcbiAgICogYXJlIG9ubHkgZXZlciBjYWxsaW5nIGEgc2luZ2xlIGFjdGlvbiBvciBsb2FkZXIsIGFuZCB3ZSBhcmUgcmV0dXJuaW5nIHRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBkaXJlY3RseS4gIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSBhIFJlc3BvbnNlIHJldHVybmVkXG4gICAqIGZyb20gdGhlIGFjdGlvbi9sb2FkZXIsIGJ1dCBpdCBtYXkgYmUgYSBwcmltaXRpdmUgb3Igb3RoZXIgdmFsdWUgYXMgd2VsbCAtXG4gICAqIGFuZCBpbiBzdWNoIGNhc2VzIHRoZSBjYWxsaW5nIGNvbnRleHQgc2hvdWxkIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBXZSBkbyByZXNwZWN0IHRoZSB0aHJvdy9yZXR1cm4gZGlmZmVyZW50aWF0aW9uLCBzbyBpZiBhbiBhY3Rpb24vbG9hZGVyXG4gICAqIHRocm93cywgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHRocm93IHRoZSB2YWx1ZS4gIFRoaXMgaXMgaW1wb3J0YW50IHNvIHdlXG4gICAqIGNhbiBkbyBwcm9wZXIgYm91bmRhcnkgaWRlbnRpZmljYXRpb24gaW4gUmVtaXggd2hlcmUgYSB0aHJvd24gUmVzcG9uc2VcbiAgICogbXVzdCBnbyB0byB0aGUgQ2F0Y2ggQm91bmRhcnkgYnV0IGEgcmV0dXJuZWQgUmVzcG9uc2UgaXMgaGFwcHktcGF0aC5cbiAgICpcbiAgICogT25lIHRoaW5nIHRvIG5vdGUgaXMgdGhhdCBhbnkgUm91dGVyLWluaXRpYXRlZCBFcnJvcnMgdGhhdCBtYWtlIHNlbnNlXG4gICAqIHRvIGFzc29jaWF0ZSB3aXRoIGEgc3RhdHVzIGNvZGUgd2lsbCBiZSB0aHJvd24gYXMgYW4gRXJyb3JSZXNwb25zZVxuICAgKiBpbnN0YW5jZSB3aGljaCBpbmNsdWRlIHRoZSByYXcgRXJyb3IsIHN1Y2ggdGhhdCB0aGUgY2FsbGluZyBjb250ZXh0IGNhblxuICAgKiBzZXJpYWxpemUgdGhlIGVycm9yIGFzIHRoZXkgc2VlIGZpdCB3aGlsZSBpbmNsdWRpbmcgdGhlIHByb3BlciByZXNwb25zZVxuICAgKiBjb2RlLiAgRXhhbXBsZXMgaGVyZSBhcmUgNDA0IGFuZCA0MDUgZXJyb3JzIHRoYXQgb2NjdXIgcHJpb3IgdG8gcmVhY2hpbmdcbiAgICogYW55IHVzZXItZGVmaW5lZCBsb2FkZXJzLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShcbiAgICByZXF1ZXN0OiBSZXF1ZXN0LFxuICAgIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICB9OiB7IHJlcXVlc3RDb250ZXh0PzogdW5rbm93bjsgcm91dGVJZD86IHN0cmluZyB9ID0ge31cbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcblxuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIiAmJiBtZXRob2QgIT09IFwiT1BUSU9OU1wiKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwgeyBtZXRob2QgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lIH0pO1xuICAgIH1cblxuICAgIGxldCBtYXRjaCA9IHJvdXRlSWRcbiAgICAgID8gbWF0Y2hlcy5maW5kKChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKVxuICAgICAgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG5cbiAgICBpZiAocm91dGVJZCAmJiAhbWF0Y2gpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAzLCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoaXQgSSBkb24ndCB0aGluaz9cbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgbWF0Y2hcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBiYWNrIHJlc3VsdC5lcnJvcnMsIHRoYXQgbWVhbnMgdGhlIGxvYWRlci9hY3Rpb24gdGhyZXdcbiAgICAgIC8vIF9zb21ldGhpbmdfIHRoYXQgd2Fzbid0IGEgUmVzcG9uc2UsIGJ1dCBpdCdzIG5vdCBndWFyYW50ZWVkL3JlcXVpcmVkXG4gICAgICAvLyB0byBiZSBhbiBgaW5zdGFuY2VvZiBFcnJvcmAgZWl0aGVyLCBzbyB3ZSBoYXZlIHRvIHVzZSB0aHJvdyBoZXJlIHRvXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGUgXCJlcnJvclwiIHN0YXRlIG91dHNpZGUgb2YgcXVlcnlJbXBsLlxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gUGljayBvZmYgdGhlIHJpZ2h0IHN0YXRlIHZhbHVlIHRvIHJldHVyblxuICAgIGlmIChyZXN1bHQuYWN0aW9uRGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmFjdGlvbkRhdGEpWzBdO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgbGV0IGRhdGEgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5sb2FkZXJEYXRhKVswXTtcbiAgICAgIGlmIChyZXN1bHQuYWN0aXZlRGVmZXJyZWRzPy5bbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgIGRhdGFbVU5TQUZFX0RFRkVSUkVEX1NZTUJPTF0gPSByZXN1bHQuYWN0aXZlRGVmZXJyZWRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBxdWVyeUltcGwoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIHJvdXRlTWF0Y2g/OiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoXG4gICk6IFByb21pc2U8T21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiPiB8IFJlc3BvbnNlPiB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCJcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdWJtaXQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLFxuICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgIHJvdXRlTWF0Y2ggIT0gbnVsbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIHJvdXRlTWF0Y2hcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpXG4gICAgICAgID8gcmVzdWx0XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdGhyZXcvcmV0dXJuZWQgYSBSZXNwb25zZSBpbiBjYWxsTG9hZGVyT3JBY3Rpb24sIHdlIHRocm93XG4gICAgICAvLyBpdCB0byBiYWlsIG91dCBhbmQgdGhlbiByZXR1cm4gb3IgdGhyb3cgaGVyZSBiYXNlZCBvbiB3aGV0aGVyIHRoZSB1c2VyXG4gICAgICAvLyByZXR1cm5lZCBvciB0aHJld1xuICAgICAgaWYgKGlzUXVlcnlSb3V0ZVJlc3BvbnNlKGUpKSB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IgJiYgIWlzUmVkaXJlY3RSZXNwb25zZShlLnJlc3BvbnNlKSkge1xuICAgICAgICAgIHRocm93IGUucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxuICAgICAgLy8gYm91bmRhcmllc1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KFxuICAgIHJlcXVlc3Q6IFJlcXVlc3QsXG4gICAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICAgIGFjdGlvbk1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICAgIHJlcXVlc3RDb250ZXh0OiB1bmtub3duLFxuICAgIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuXG4gICk6IFByb21pc2U8T21pdDxTdGF0aWNIYW5kbGVyQ29udGV4dCwgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiPiB8IFJlc3BvbnNlPiB7XG4gICAgbGV0IHJlc3VsdDogRGF0YVJlc3VsdDtcblxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFxuICAgICAgICBcImFjdGlvblwiLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBhY3Rpb25NYXRjaCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIGRldGVjdEVycm9yQm91bmRhcnksXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICB0cnVlLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFVoaGhoIC0gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCB3ZSBzaG91bGQgYWx3YXlzIHRocm93IHRoZXNlIGZyb21cbiAgICAgIC8vIGNhbGxMb2FkZXJPckFjdGlvbiwgYnV0IHRoZSB0eXBlIG5hcnJvd2luZyBoZXJlIGtlZXBzIFRTIGhhcHB5IGFuZCB3ZVxuICAgICAgLy8gY2FuIGdldCBiYWNrIG9uIHRoZSBcInRocm93IGFsbCByZWRpcmVjdCByZXNwb25zZXNcIiB0cmFpbiBoZXJlIHNob3VsZFxuICAgICAgLy8gdGhpcyBldmVyIGhhcHBlbiA6L1xuICAgICAgdGhyb3cgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IHJlc3VsdC5sb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7IHR5cGU6IFwiZGVmZXItYWN0aW9uXCIgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgIC8vIE5vdGU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgbm9uLVJlc3BvbnNlIHZhbHVlcyBpZiB3ZSBnZXQgaGVyZSwgc2luY2VcbiAgICAgIC8vIGlzUm91dGVSZXF1ZXN0IHNob3VsZCB0aHJvdyBhbnkgUmVzcG9uc2UgcmVjZWl2ZWQgaW4gY2FsbExvYWRlck9yQWN0aW9uXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogW2FjdGlvbk1hdGNoXSxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAvLyBOb3RlOiBzdGF0dXNDb2RlICsgaGVhZGVycyBhcmUgdW51c2VkIGhlcmUgc2luY2UgcXVlcnlSb3V0ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIG9yIHZhbHVlXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcilcbiAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGF0dXNcbiAgICAgICAgICA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge1xuICAgICAgICAgIC4uLihyZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgbGV0IGxvYWRlclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0LnVybCwge1xuICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICBzaWduYWw6IHJlcXVlc3Quc2lnbmFsLFxuICAgIH0pO1xuICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShsb2FkZXJSZXF1ZXN0LCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xuICAgICAgLi4uKHJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30pLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YSxcbiAgICAgIH0sXG4gICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgIC4uLihyZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9KSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEoXG4gICAgcmVxdWVzdDogUmVxdWVzdCxcbiAgICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gICAgcmVxdWVzdENvbnRleHQ6IHVua25vd24sXG4gICAgcm91dGVNYXRjaD86IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gICAgcGVuZGluZ0FjdGlvbkVycm9yPzogUm91dGVEYXRhXG4gICk6IFByb21pc2U8XG4gICAgfCBPbWl0PFxuICAgICAgICBTdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgICAgICAgXCJsb2NhdGlvblwiIHwgXCJiYXNlbmFtZVwiIHwgXCJhY3Rpb25EYXRhXCIgfCBcImFjdGlvbkhlYWRlcnNcIlxuICAgICAgPlxuICAgIHwgUmVzcG9uc2VcbiAgPiB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKFxuICAgICAgaXNSb3V0ZVJlcXVlc3QgJiZcbiAgICAgICFyb3V0ZU1hdGNoPy5yb3V0ZS5sb2FkZXIgJiZcbiAgICAgICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5XG4gICAgKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3RNYXRjaGVzID0gcm91dGVNYXRjaFxuICAgICAgPyBbcm91dGVNYXRjaF1cbiAgICAgIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkoXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBPYmplY3Qua2V5cyhwZW5kaW5nQWN0aW9uRXJyb3IgfHwge30pWzBdXG4gICAgICAgICk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5sb2FkZXIgfHwgbS5yb3V0ZS5sYXp5XG4gICAgKTtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFttLnJvdXRlLmlkXTogbnVsbCB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgICAgICBlcnJvcnM6IHBlbmRpbmdBY3Rpb25FcnJvciB8fCBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgLi4ubWF0Y2hlc1RvTG9hZC5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBjYWxsTG9hZGVyT3JBY3Rpb24oXG4gICAgICAgICAgXCJsb2FkZXJcIixcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgZGV0ZWN0RXJyb3JCb3VuZGFyeSxcbiAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIGlzUm91dGVSZXF1ZXN0LFxuICAgICAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgICAgIClcbiAgICAgICksXG4gICAgXSk7XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZGApO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IGFjdGl2ZURlZmVycmVkcyA9IG5ldyBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+KCk7XG4gICAgbGV0IGNvbnRleHQgPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hdGNoZXNUb0xvYWQsXG4gICAgICByZXN1bHRzLFxuICAgICAgcGVuZGluZ0FjdGlvbkVycm9yLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzXG4gICAgKTtcblxuICAgIC8vIEFkZCBhIG51bGwgZm9yIGFueSBub24tbG9hZGVyIG1hdGNoZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0PHN0cmluZz4oXG4gICAgICBtYXRjaGVzVG9Mb2FkLm1hcCgobWF0Y2gpID0+IG1hdGNoLnJvdXRlLmlkKVxuICAgICk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgICAgaWYgKCFleGVjdXRlZExvYWRlcnMuaGFzKG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgICBjb250ZXh0LmxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZURlZmVycmVkczpcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLnNpemUgPiAwXG4gICAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoYWN0aXZlRGVmZXJyZWRzLmVudHJpZXMoKSlcbiAgICAgICAgICA6IG51bGwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlLFxuICB9O1xufVxuXG4vLyNlbmRyZWdpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIZWxwZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXG4gKiBwcm92aWRlIGFuIHVwZGF0ZWQgU3RhdGljSGFuZGxlckNvbnRleHQgc3VpdGFibGUgZm9yIGEgc2Vjb25kIFNTUiByZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IoXG4gIHJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSxcbiAgY29udGV4dDogU3RhdGljSGFuZGxlckNvbnRleHQsXG4gIGVycm9yOiBhbnlcbikge1xuICBsZXQgbmV3Q29udGV4dDogU3RhdGljSGFuZGxlckNvbnRleHQgPSB7XG4gICAgLi4uY29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbY29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB8fCByb3V0ZXNbMF0uaWRdOiBlcnJvcixcbiAgICB9LFxuICB9O1xuICByZXR1cm4gbmV3Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihcbiAgb3B0czogUm91dGVyTmF2aWdhdGVPcHRpb25zXG4pOiBvcHRzIGlzIFN1Ym1pc3Npb25OYXZpZ2F0ZU9wdGlvbnMge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIFwiZm9ybURhdGFcIiBpbiBvcHRzO1xufVxuXG4vLyBOb3JtYWxpemUgbmF2aWdhdGlvbiBvcHRpb25zIGJ5IGNvbnZlcnRpbmcgZm9ybU1ldGhvZD1HRVQgZm9ybURhdGEgb2JqZWN0cyB0b1xuLy8gVVJMU2VhcmNoUGFyYW1zIHNvIHRoZXkgYmVoYXZlIGlkZW50aWNhbGx5IHRvIGxpbmtzIHdpdGggcXVlcnkgcGFyYW1zXG5mdW5jdGlvbiBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoXG4gIHRvOiBUbyxcbiAgZnV0dXJlOiBGdXR1cmVDb25maWcsXG4gIG9wdHM/OiBSb3V0ZXJOYXZpZ2F0ZU9wdGlvbnMsXG4gIGlzRmV0Y2hlciA9IGZhbHNlXG4pOiB7XG4gIHBhdGg6IHN0cmluZztcbiAgc3VibWlzc2lvbj86IFN1Ym1pc3Npb247XG4gIGVycm9yPzogRXJyb3JSZXNwb25zZTtcbn0ge1xuICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG5cbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7IHBhdGggfTtcbiAgfVxuXG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pLFxuICAgIH07XG4gIH1cblxuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHN1Ym1pc3Npb246IFN1Ym1pc3Npb24gfCB1bmRlZmluZWQ7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgbGV0IGZvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgICBzdWJtaXNzaW9uID0ge1xuICAgICAgZm9ybU1ldGhvZDogZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2RcbiAgICAgICAgPyAoZm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIGFzIFY3X0Zvcm1NZXRob2QpXG4gICAgICAgIDogKGZvcm1NZXRob2QudG9Mb3dlckNhc2UoKSBhcyBGb3JtTWV0aG9kKSxcbiAgICAgIGZvcm1BY3Rpb246IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpLFxuICAgICAgZm9ybUVuY1R5cGU6XG4gICAgICAgIChvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUpIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICBmb3JtRGF0YTogb3B0cy5mb3JtRGF0YSxcbiAgICB9O1xuXG4gICAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZsYXR0ZW4gc3VibWlzc2lvbiBvbnRvIFVSTFNlYXJjaFBhcmFtcyBmb3IgR0VUIHN1Ym1pc3Npb25zXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gIC8vIFNpbmNlIGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciAoYXMgb3Bwb3NlZCB0b1xuICAvLyBuYXZpZ2F0aW9uIEdFVCBzdWJtaXNzaW9ucyB3aGljaCBydW4gYWxsIGxvYWRlcnMpLCB3ZSBuZWVkIHRvIHByZXNlcnZlXG4gIC8vIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IGA/JHtzZWFyY2hQYXJhbXN9YDtcblxuICByZXR1cm4geyBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLCBzdWJtaXNzaW9uIH07XG59XG5cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIGJvdW5kYXJ5SWQ/OiBzdHJpbmdcbikge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRhcnlNYXRjaGVzO1xufVxuXG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKFxuICBoaXN0b3J5OiBIaXN0b3J5LFxuICBzdGF0ZTogUm91dGVyU3RhdGUsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgc3VibWlzc2lvbjogU3VibWlzc2lvbiB8IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IExvY2F0aW9uLFxuICBpc1JldmFsaWRhdGlvblJlcXVpcmVkOiBib29sZWFuLFxuICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlczogc3RyaW5nW10sXG4gIGNhbmNlbGxlZEZldGNoZXJMb2Fkczogc3RyaW5nW10sXG4gIGZldGNoTG9hZE1hdGNoZXM6IE1hcDxzdHJpbmcsIEZldGNoTG9hZE1hdGNoPixcbiAgcm91dGVzVG9Vc2U6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0W10sXG4gIGJhc2VuYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHBlbmRpbmdBY3Rpb25EYXRhPzogUm91dGVEYXRhLFxuICBwZW5kaW5nRXJyb3I/OiBSb3V0ZURhdGFcbik6IFtBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sIFJldmFsaWRhdGluZ0ZldGNoZXJbXV0ge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0Vycm9yXG4gICAgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF1cbiAgICA6IHBlbmRpbmdBY3Rpb25EYXRhXG4gICAgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdBY3Rpb25EYXRhKVswXVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGxldCBjdXJyZW50VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RhdGUubG9jYXRpb24pO1xuICBsZXQgbmV4dFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcblxuICBsZXQgZGVmYXVsdFNob3VsZFJldmFsaWRhdGUgPVxuICAgIC8vIEZvcmNlZCByZXZhbGlkYXRpb24gZHVlIHRvIHN1Ym1pc3Npb24sIHVzZVJldmFsaWRhdGUsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHxcbiAgICAvLyBDbGlja2VkIHRoZSBzYW1lIGxpbmssIHJlc3VibWl0dGVkIGEgR0VUIGZvcm1cbiAgICBjdXJyZW50VXJsLnRvU3RyaW5nKCkgPT09IG5leHRVcmwudG9TdHJpbmcoKSB8fFxuICAgIC8vIFNlYXJjaCBwYXJhbXMgYWZmZWN0IGFsbCBsb2FkZXJzXG4gICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoO1xuXG4gIC8vIFBpY2sgbmF2aWdhdGlvbiBtYXRjaGVzIHRoYXQgYXJlIG5ldC1uZXcgb3IgcXVhbGlmeSBmb3IgcmV2YWxpZGF0aW9uXG4gIGxldCBib3VuZGFyeUlkID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LmtleXMocGVuZGluZ0Vycm9yKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpO1xuXG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaC5yb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBsb2FkZXIgb24gbmV3IHJvdXRlIGluc3RhbmNlcyBhbmQgcGVuZGluZyBkZWZlciBjYW5jZWxsYXRpb25zXG4gICAgaWYgKFxuICAgICAgaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSB8fFxuICAgICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMuc29tZSgoaWQpID0+IGlkID09PSBtYXRjaC5yb3V0ZS5pZClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuXG4gICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHtcbiAgICAgIGN1cnJlbnRVcmwsXG4gICAgICBjdXJyZW50UGFyYW1zOiBjdXJyZW50Um91dGVNYXRjaC5wYXJhbXMsXG4gICAgICBuZXh0VXJsLFxuICAgICAgbmV4dFBhcmFtczogbmV4dFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSB8fFxuICAgICAgICBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUGljayBmZXRjaGVyLmxvYWRzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxuICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlcnM6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSA9IFtdO1xuICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKGYsIGtleSkgPT4ge1xuICAgIC8vIERvbid0IHJldmFsaWRhdGUgaWYgZmV0Y2hlciB3b24ndCBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlclxuICAgIGlmICghbWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGZldGNoZXJNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGYucGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGZldGNoZXIgcGF0aCBubyBsb25nZXIgbWF0Y2hlcywgcHVzaCBpdCBpbiB3aXRoIG51bGwgbWF0Y2hlcyBzb1xuICAgIC8vIHdlIGNhbiB0cmlnZ2VyIGEgNDA0IGluIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YVxuICAgIGlmICghZmV0Y2hlck1hdGNoZXMpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goeyBrZXksIC4uLmYsIG1hdGNoZXM6IG51bGwsIG1hdGNoOiBudWxsIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcblxuICAgIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIC4uLmYsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXZhbGlkYXRpbmcgZmV0Y2hlcnMgYXJlIGRlY291cGxlZCBmcm9tIHRoZSByb3V0ZSBtYXRjaGVzIHNpbmNlIHRoZXlcbiAgICAvLyBoaXQgYSBzdGF0aWMgaHJlZiwgc28gdGhleSBfYWx3YXlzXyBjaGVjayBzaG91bGRSZXZhbGlkYXRlIGFuZCB0aGVcbiAgICAvLyBkZWZhdWx0IGlzIHN0cmljdGx5IGlmIGEgcmV2YWxpZGF0aW9uIGlzIGV4cGxpY2l0bHkgcmVxdWlyZWQgKGFjdGlvblxuICAgIC8vIHN1Ym1pc3Npb25zLCB1c2VSZXZhbGlkYXRvciwgWC1SZW1peC1SZXZhbGlkYXRlKS5cbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCB7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1tzdGF0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgIG5leHRVcmwsXG4gICAgICBuZXh0UGFyYW1zOiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgLi4uc3VibWlzc2lvbixcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlLFxuICAgIH0pO1xuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgbWF0Y2g6IGZldGNoZXJNYXRjaCxcbiAgICAgICAgLi4uZixcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuXG5mdW5jdGlvbiBpc05ld0xvYWRlcihcbiAgY3VycmVudExvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgY3VycmVudE1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuKSB7XG4gIGxldCBpc05ldyA9XG4gICAgLy8gW2FdIC0+IFthLCBiXVxuICAgICFjdXJyZW50TWF0Y2ggfHxcbiAgICAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZDtcblxuICAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBoYXZlIGRhdGEgZm9yIGEgcmUtdXNlZCByb3V0ZSwgcG90ZW50aWFsbHlcbiAgLy8gZnJvbSBhIHByaW9yIGVycm9yIG9yIGZyb20gYSBjYW5jZWxsZWQgcGVuZGluZyBkZWZlcnJlZFxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xuXG4gIC8vIEFsd2F5cyBsb2FkIGlmIHRoaXMgaXMgYSBuZXQtbmV3IHJvdXRlIG9yIHdlIGRvbid0IHlldCBoYXZlIGRhdGFcbiAgcmV0dXJuIGlzTmV3IHx8IGlzTWlzc2luZ0RhdGE7XG59XG5cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShcbiAgY3VycmVudE1hdGNoOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoLFxuICBtYXRjaDogQWdub3N0aWNEYXRhUm91dGVNYXRjaFxuKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxuICAgIC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICAoY3VycmVudFBhdGggIT0gbnVsbCAmJlxuICAgICAgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmXG4gICAgICBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihcbiAgbG9hZGVyTWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGFyZzogUGFyYW1ldGVyczxTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24+WzBdXG4pIHtcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgcm91dGVDaG9pY2UgPSBsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKGFyZyk7XG4gICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJnLmRlZmF1bHRTaG91bGRSZXZhbGlkYXRlO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgcm91dGUubGF6eSgpIG1ldGhvZHMgdG8gbGF6aWx5IGxvYWQgcm91dGUgbW9kdWxlcyAobG9hZGVyLCBhY3Rpb24sXG4gKiBzaG91bGRSZXZhbGlkYXRlKSBhbmQgdXBkYXRlIHRoZSByb3V0ZU1hbmlmZXN0IGluIHBsYWNlIHdoaWNoIHNoYXJlcyBvYmplY3RzXG4gKiB3aXRoIGRhdGFSb3V0ZXMgc28gdGhvc2UgZ2V0IHVwZGF0ZWQgYXMgd2VsbC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZExhenlSb3V0ZU1vZHVsZShcbiAgcm91dGU6IEFnbm9zdGljRGF0YVJvdXRlT2JqZWN0LFxuICBkZXRlY3RFcnJvckJvdW5kYXJ5OiBEZXRlY3RFcnJvckJvdW5kYXJ5RnVuY3Rpb24sXG4gIG1hbmlmZXN0OiBSb3V0ZU1hbmlmZXN0XG4pIHtcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcblxuICAvLyBJZiB0aGUgbGF6eSByb3V0ZSBmdW5jdGlvbiB3YXMgZXhlY3V0ZWQgYW5kIHJlbW92ZWQgYnkgYW5vdGhlciBwYXJhbGxlbFxuICAvLyBjYWxsIHRoZW4gd2UgY2FuIHJldHVybiAtIGZpcnN0IGxhenkoKSB0byBmaW5pc2ggd2lucyBiZWNhdXNlIHRoZSByZXR1cm5cbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XG4gIGludmFyaWFudChyb3V0ZVRvVXBkYXRlLCBcIk5vIHJvdXRlIGZvdW5kIGluIG1hbmlmZXN0XCIpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgcm91dGUgaW4gcGxhY2UuICBUaGlzIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgLy8gd2UgY291bGQgeWV0IGJlIHNpdHRpbmcgb24gdGhpcyByb3V0ZSBhcyB3ZSBjYW4ndCBnZXQgdGhlcmUgd2l0aG91dFxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxuICAvL1xuICAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBITVIgXCJ1cGRhdGVcIiB1c2UtY2FzZSB3aGVyZSB3ZSBtYXkgYWN0aXZlbHkgYmVcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcbiAgLy8gbXV0YXRpb24gYWZmZWN0IGFueSBvbmdvaW5nIG5hdmlnYXRpb25zIG9yIGFueSBjdXJyZW50IHN0YXRlLm1hdGNoZXNcbiAgLy8gdmFsdWVzP1wiLiAgSWYgbm90LCBpdCBzaG91bGQgYmUgc2FmZSB0byB1cGRhdGUgaW4gcGxhY2UuXG4gIGxldCByb3V0ZVVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPVxuICAgICAgcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2Ygcm91dGVUb1VwZGF0ZV07XG5cbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID1cbiAgICAgIHN0YXRpY1JvdXRlVmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgICAgbGF6eVJvdXRlUHJvcGVydHkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuXG4gICAgd2FybmluZyhcbiAgICAgICFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsXG4gICAgICBgUm91dGUgXCIke3JvdXRlVG9VcGRhdGUuaWR9XCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiBgICtcbiAgICAgICAgYGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIGAgK1xuICAgICAgICBgVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIHdpbGwgYmUgaWdub3JlZC5gXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgICFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiZcbiAgICAgICFpbW11dGFibGVSb3V0ZUtleXMuaGFzKGxhenlSb3V0ZVByb3BlcnR5IGFzIEltbXV0YWJsZVJvdXRlS2V5KVxuICAgICkge1xuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9XG4gICAgICAgIGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eSBhcyBrZXlvZiB0eXBlb2YgbGF6eVJvdXRlXTtcbiAgICB9XG4gIH1cblxuICAvLyBNdXRhdGUgdGhlIHJvdXRlIHdpdGggdGhlIHByb3ZpZGVkIHVwZGF0ZXMuICBEbyB0aGlzIGZpcnN0IHNvIHdlIHBhc3NcbiAgLy8gdGhlIHVwZGF0ZWQgdmVyc2lvbiB0byBkZXRlY3RFcnJvckJvdW5kYXJ5XG4gIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgcm91dGVVcGRhdGVzKTtcblxuICAvLyBNdXRhdGUgdGhlIGBoYXNFcnJvckJvdW5kYXJ5YCBwcm9wZXJ0eSBvbiB0aGUgcm91dGUgYmFzZWQgb24gdGhlIHJvdXRlXG4gIC8vIHVwZGF0ZXMgYW5kIHJlbW92ZSB0aGUgYGxhenlgIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc29sdmUgdGhlIGxhenlcbiAgLy8gcm91dGUgYWdhaW4uXG4gIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwge1xuICAgIC8vIFRvIGtlZXAgdGhpbmdzIGZyYW1ld29yayBhZ25vc3RpYywgd2UgdXNlIHRoZSBwcm92aWRlZFxuICAgIC8vIGBkZXRlY3RFcnJvckJvdW5kYXJ5YCBmdW5jdGlvbiB0byBzZXQgdGhlIGBoYXNFcnJvckJvdW5kYXJ5YCByb3V0ZVxuICAgIC8vIHByb3BlcnR5IHNpbmNlIHRoZSBsb2dpYyB3aWxsIGRpZmZlciBiZXR3ZWVuIGZyYW1ld29ya3MuXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogZGV0ZWN0RXJyb3JCb3VuZGFyeSh7IC4uLnJvdXRlVG9VcGRhdGUgfSksXG4gICAgbGF6eTogdW5kZWZpbmVkLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKFxuICB0eXBlOiBcImxvYWRlclwiIHwgXCJhY3Rpb25cIixcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgbWFuaWZlc3Q6IFJvdXRlTWFuaWZlc3QsXG4gIGRldGVjdEVycm9yQm91bmRhcnk6IERldGVjdEVycm9yQm91bmRhcnlGdW5jdGlvbixcbiAgYmFzZW5hbWUgPSBcIi9cIixcbiAgaXNTdGF0aWNSZXF1ZXN0OiBib29sZWFuID0gZmFsc2UsXG4gIGlzUm91dGVSZXF1ZXN0OiBib29sZWFuID0gZmFsc2UsXG4gIHJlcXVlc3RDb250ZXh0PzogdW5rbm93blxuKTogUHJvbWlzZTxEYXRhUmVzdWx0PiB7XG4gIGxldCByZXN1bHRUeXBlO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICBsZXQgcnVuSGFuZGxlciA9IChoYW5kbGVyOiBBY3Rpb25GdW5jdGlvbiB8IExvYWRlckZ1bmN0aW9uKSA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0OiAoKSA9PiB2b2lkO1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gKHJlamVjdCA9IHIpKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICBoYW5kbGVyKHsgcmVxdWVzdCwgcGFyYW1zOiBtYXRjaC5wYXJhbXMsIGNvbnRleHQ6IHJlcXVlc3RDb250ZXh0IH0pLFxuICAgICAgYWJvcnRQcm9taXNlLFxuICAgIF0pO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgbGV0IGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcblxuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcbiAgICAgICAgbGV0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBydW5IYW5kbGVyKGhhbmRsZXIpLFxuICAgICAgICAgIGxvYWRMYXp5Um91dGVNb2R1bGUobWF0Y2gucm91dGUsIGRldGVjdEVycm9yQm91bmRhcnksIG1hbmlmZXN0KSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExvYWQgbGF6eSByb3V0ZSBtb2R1bGUsIHRoZW4gcnVuIGFueSByZXR1cm5lZCBoYW5kbGVyXG4gICAgICAgIGF3YWl0IGxvYWRMYXp5Um91dGVNb2R1bGUobWF0Y2gucm91dGUsIGRldGVjdEVycm9yQm91bmRhcnksIG1hbmlmZXN0KTtcblxuICAgICAgICBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgLy8gSGFuZGxlciBzdGlsbCBydW4gZXZlbiBpZiB3ZSBnb3QgaW50ZXJydXB0ZWQgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcbiAgICAgICAgICAvLyB3aXRoIHVuLWFib3J0YWJsZSBiZWhhdmlvciBvZiBoYW5kbGVyIGV4ZWN1dGlvbiBvbiBub24tbGF6eSBvclxuICAgICAgICAgIC8vIHByZXZpb3VzbHktbGF6eS1sb2FkZWQgcm91dGVzXG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImFjdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXp5KCkgcm91dGUgaGFzIG5vIGxvYWRlciB0byBydW4uICBTaG9ydCBjaXJjdWl0IGhlcmUgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoaXQgdGhlIGludmFyaWFudCBiZWxvdyB0aGF0IGVycm9ycyBvbiByZXR1cm5pbmcgdW5kZWZpbmVkLlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFJlc3VsdFR5cGUuZGF0YSwgZGF0YTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50PEZ1bmN0aW9uPihcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIHRoZSAke3R5cGV9IHRvIHJ1biBvbiB0aGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIHJvdXRlYFxuICAgICAgKTtcblxuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXN1bHQgIT09IHVuZGVmaW5lZCxcbiAgICAgIGBZb3UgZGVmaW5lZCAke3R5cGUgPT09IFwiYWN0aW9uXCIgPyBcImFuIGFjdGlvblwiIDogXCJhIGxvYWRlclwifSBmb3Igcm91dGUgYCArXG4gICAgICAgIGBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZnJvbSB5b3VyIFxcYCR7dHlwZX1cXGAgYCArXG4gICAgICAgIGBmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG5cbiAgICAvLyBQcm9jZXNzIHJlZGlyZWN0c1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXMpKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIFwiUmVkaXJlY3RzIHJldHVybmVkL3Rocm93biBmcm9tIGxvYWRlcnMvYWN0aW9ucyBtdXN0IGhhdmUgYSBMb2NhdGlvbiBoZWFkZXJcIlxuICAgICAgKTtcblxuICAgICAgLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuICAgICAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgbGV0IGFjdGl2ZU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuaW5kZXhPZihtYXRjaCkgKyAxKTtcbiAgICAgICAgbGV0IHJvdXRlUGF0aG5hbWVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMoYWN0aXZlTWF0Y2hlcykubWFwKFxuICAgICAgICAgIChtYXRjaCkgPT4gbWF0Y2gucGF0aG5hbWVCYXNlXG4gICAgICAgICk7XG4gICAgICAgIGxldCByZXNvbHZlZExvY2F0aW9uID0gcmVzb2x2ZVRvKFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIHJvdXRlUGF0aG5hbWVzLFxuICAgICAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lXG4gICAgICAgICk7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBjcmVhdGVQYXRoKHJlc29sdmVkTG9jYXRpb24pLFxuICAgICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSByZWRpcmVjdCBsb2NhdGlvbjogJHtsb2NhdGlvbn1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUHJlcGVuZCB0aGUgYmFzZW5hbWUgdG8gdGhlIHJlZGlyZWN0IGxvY2F0aW9uIGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGlmIChiYXNlbmFtZSkge1xuICAgICAgICAgIGxldCBwYXRoID0gcmVzb2x2ZWRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICByZXNvbHZlZExvY2F0aW9uLnBhdGhuYW1lID1cbiAgICAgICAgICAgIHBhdGggPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhdGlvbiA9IGNyZWF0ZVBhdGgocmVzb2x2ZWRMb2NhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCFpc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIilcbiAgICAgICAgICA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIGxvY2F0aW9uKVxuICAgICAgICAgIDogbmV3IFVSTChsb2NhdGlvbik7XG4gICAgICAgIGxldCBpc1NhbWVCYXNlbmFtZSA9IHN0cmlwQmFzZW5hbWUodXJsLnBhdGhuYW1lLCBiYXNlbmFtZSkgIT0gbnVsbDtcbiAgICAgICAgaWYgKHVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIGlzU2FtZUJhc2VuYW1lKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChpc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgcmVzdWx0LmhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgbG9jYXRpb24pO1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGU6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSAhPT0gbnVsbCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRm9yIFNTUiBzaW5nbGUtcm91dGUgcmVxdWVzdHMsIHdlIHdhbnQgdG8gaGFuZCBSZXNwb25zZXMgYmFjayBkaXJlY3RseVxuICAgIC8vIHdpdGhvdXQgdW53cmFwcGluZy4gIFdlIGRvIHRoaXMgd2l0aCB0aGUgUXVlcnlSb3V0ZVJlc3BvbnNlIHdyYXBwZXJcbiAgICAvLyBpbnRlcmZhY2Ugc28gd2UgY2FuIGtub3cgd2hldGhlciBpdCB3YXMgcmV0dXJuZWQgb3IgdGhyb3duXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICAgICAgdGhyb3cge1xuICAgICAgICB0eXBlOiByZXN1bHRUeXBlIHx8IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGRhdGE6IGFueTtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgLy8gQ2hlY2sgYmV0d2VlbiB3b3JkIGJvdW5kYXJpZXMgaW5zdGVhZCBvZiBzdGFydHNXaXRoKCkgZHVlIHRvIHRoZSBsYXN0XG4gICAgLy8gcGFyYWdyYXBoIG9mIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjZmllbGQuY29udGVudC10eXBlXG4gICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC50ZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHJlc3VsdFR5cGUsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZShzdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBkYXRhKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICBkYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgIHJldHVybiB7IHR5cGU6IHJlc3VsdFR5cGUsIGVycm9yOiByZXN1bHQgfTtcbiAgfVxuXG4gIGlmIChpc0RlZmVycmVkRGF0YShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGVmZXJyZWQsXG4gICAgICBkZWZlcnJlZERhdGE6IHJlc3VsdCxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5pbml0Py5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaW5pdD8uaGVhZGVycyAmJiBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogUmVzdWx0VHlwZS5kYXRhLCBkYXRhOiByZXN1bHQgfTtcbn1cblxuLy8gVXRpbGl0eSBtZXRob2QgZm9yIGNyZWF0aW5nIHRoZSBSZXF1ZXN0IGluc3RhbmNlcyBmb3IgbG9hZGVycy9hY3Rpb25zIGR1cmluZ1xuLy8gY2xpZW50LXNpZGUgbmF2aWdhdGlvbnMgYW5kIGZldGNoZXMuICBEdXJpbmcgU1NSIHdlIHdpbGwgYWx3YXlzIGhhdmUgYVxuLy8gUmVxdWVzdCBpbnN0YW5jZSBmcm9tIHRoZSBzdGF0aWMgaGFuZGxlciAocXVlcnkvcXVlcnlSb3V0ZSlcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICBoaXN0b3J5OiBIaXN0b3J5LFxuICBsb2NhdGlvbjogc3RyaW5nIHwgTG9jYXRpb24sXG4gIHNpZ25hbDogQWJvcnRTaWduYWwsXG4gIHN1Ym1pc3Npb24/OiBTdWJtaXNzaW9uXG4pOiBSZXF1ZXN0IHtcbiAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKHN0cmlwSGFzaEZyb21QYXRoKGxvY2F0aW9uKSkudG9TdHJpbmcoKTtcbiAgbGV0IGluaXQ6IFJlcXVlc3RJbml0ID0geyBzaWduYWwgfTtcblxuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQgeyBmb3JtTWV0aG9kLCBmb3JtRW5jVHlwZSwgZm9ybURhdGEgfSA9IHN1Ym1pc3Npb247XG4gICAgLy8gRGlkbid0IHRoaW5rIHdlIG5lZWRlZCB0aGlzIGJ1dCBpdCB0dXJucyBvdXQgdW5saWtlIG90aGVyIG1ldGhvZHMsIHBhdGNoXG4gICAgLy8gd29uJ3QgYmUgcHJvcGVybHkgbm9ybWFsaXplZCB0byB1cHBlcmNhc2UgYW5kIHJlc3VsdHMgaW4gYSA0MDUgZXJyb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2RcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpbml0LmJvZHkgPVxuICAgICAgZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAgICAgICAgPyBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSlcbiAgICAgICAgOiBmb3JtRGF0YTtcbiAgfVxuXG4gIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGE6IEZvcm1EYXRhKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY29udmVydGluZy1hbi1lbnRyeS1saXN0LXRvLWEtbGlzdC1vZi1uYW1lLXZhbHVlLXBhaXJzXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlIGluc3RhbmNlb2YgRmlsZSA/IHZhbHVlLm5hbWUgOiB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZCxcbiAgYWN0aXZlRGVmZXJyZWRzOiBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+XG4pOiB7XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgZXJyb3JzOiBSb3V0ZXJTdGF0ZVtcImVycm9yc1wiXSB8IG51bGw7XG4gIHN0YXR1c0NvZGU6IG51bWJlcjtcbiAgbG9hZGVySGVhZGVyczogUmVjb3JkPHN0cmluZywgSGVhZGVycz47XG59IHtcbiAgLy8gRmlsbCBpbiBsb2FkZXJEYXRhL2Vycm9ycyBmcm9tIG91ciBsb2FkZXJzXG4gIGxldCBsb2FkZXJEYXRhOiBSb3V0ZXJTdGF0ZVtcImxvYWRlckRhdGFcIl0gPSB7fTtcbiAgbGV0IGVycm9yczogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl0gfCBudWxsID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgbGV0IGZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGxvYWRlckhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIEhlYWRlcnM+ID0ge307XG5cbiAgLy8gUHJvY2VzcyBsb2FkZXIgcmVzdWx0cyBpbnRvIHN0YXRlLmxvYWRlckRhdGEvc3RhdGUuZXJyb3JzXG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgIGxldCBpZCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdLnJvdXRlLmlkO1xuICAgIGludmFyaWFudChcbiAgICAgICFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksXG4gICAgICBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiXG4gICAgKTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBMb29rIHVwd2FyZHMgZnJvbSB0aGUgbWF0Y2hlZCByb3V0ZSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5LCBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgaWQpO1xuICAgICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBlbmRpbmcgYWN0aW9uIGVycm9yLCB3ZSByZXBvcnQgaXQgYXQgdGhlIGhpZ2hlc3Qtcm91dGVcbiAgICAgIC8vIHRoYXQgdGhyb3dzIGEgbG9hZGVyIGVycm9yLCBhbmQgdGhlbiBjbGVhciBpdCBvdXQgdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgLy8gaXQgd2FzIGNvbnN1bWVkXG4gICAgICBpZiAocGVuZGluZ0Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gT2JqZWN0LnZhbHVlcyhwZW5kaW5nRXJyb3IpWzBdO1xuICAgICAgICBwZW5kaW5nRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcblxuICAgICAgLy8gUHJlZmVyIGhpZ2hlciBlcnJvciB2YWx1ZXMgaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxuICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9IGVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBvdXIgYW55IHByaW9yIGxvYWRlckRhdGEgZm9yIHRoZSB0aHJvd2luZyByb3V0ZVxuICAgICAgbG9hZGVyRGF0YVtpZF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIE9uY2Ugd2UgZmluZCBvdXIgZmlyc3QgKGhpZ2hlc3QpIGVycm9yLCB3ZSBzZXQgdGhlIHN0YXR1cyBjb2RlIGFuZFxuICAgICAgLy8gcHJldmVudCBkZWVwZXIgc3RhdHVzIGNvZGVzIGZyb20gb3ZlcnJpZGluZ1xuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKVxuICAgICAgICAgID8gcmVzdWx0LmVycm9yLnN0YXR1c1xuICAgICAgICAgIDogNTAwO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLnNldChpZCwgcmVzdWx0LmRlZmVycmVkRGF0YSk7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgLy8gbG9hZGVycyBhcmUgc3VjY2Vzc2Z1bCB3ZSB0YWtlIHRoZSBkZWVwZXN0IHN0YXR1cyBjb2RlLlxuICAgICAgaWYgKFxuICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsICYmXG4gICAgICAgIHJlc3VsdC5zdGF0dXNDb2RlICE9PSAyMDAgJiZcbiAgICAgICAgIWZvdW5kRXJyb3JcbiAgICAgICkge1xuICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIGRpZG4ndCBjb25zdW1lIHRoZSBwZW5kaW5nIGFjdGlvbiBlcnJvciAoaS5lLiwgYWxsIGxvYWRlcnNcbiAgLy8gcmVzb2x2ZWQpLCB0aGVuIGNvbnN1bWUgaXQgaGVyZS4gIEFsc28gY2xlYXIgb3V0IGFueSBsb2FkZXJEYXRhIGZvciB0aGVcbiAgLy8gdGhyb3dpbmcgcm91dGVcbiAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgIGVycm9ycyA9IHBlbmRpbmdFcnJvcjtcbiAgICBsb2FkZXJEYXRhW09iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF1dID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9ycyxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcbiAgICBsb2FkZXJIZWFkZXJzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzTG9hZGVyRGF0YShcbiAgc3RhdGU6IFJvdXRlclN0YXRlLFxuICBtYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBwZW5kaW5nRXJyb3I6IFJvdXRlRGF0YSB8IHVuZGVmaW5lZCxcbiAgcmV2YWxpZGF0aW5nRmV0Y2hlcnM6IFJldmFsaWRhdGluZ0ZldGNoZXJbXSxcbiAgZmV0Y2hlclJlc3VsdHM6IERhdGFSZXN1bHRbXSxcbiAgYWN0aXZlRGVmZXJyZWRzOiBNYXA8c3RyaW5nLCBEZWZlcnJlZERhdGE+XG4pOiB7XG4gIGxvYWRlckRhdGE6IFJvdXRlclN0YXRlW1wibG9hZGVyRGF0YVwiXTtcbiAgZXJyb3JzPzogUm91dGVyU3RhdGVbXCJlcnJvcnNcIl07XG59IHtcbiAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKFxuICAgIG1hdGNoZXMsXG4gICAgbWF0Y2hlc1RvTG9hZCxcbiAgICByZXN1bHRzLFxuICAgIHBlbmRpbmdFcnJvcixcbiAgICBhY3RpdmVEZWZlcnJlZHNcbiAgKTtcblxuICAvLyBQcm9jZXNzIHJlc3VsdHMgZnJvbSBvdXIgcmV2YWxpZGF0aW5nIGZldGNoZXJzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgeyBrZXksIG1hdGNoIH0gPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tpbmRleF07XG4gICAgaW52YXJpYW50KFxuICAgICAgZmV0Y2hlclJlc3VsdHMgIT09IHVuZGVmaW5lZCAmJiBmZXRjaGVyUmVzdWx0c1tpbmRleF0gIT09IHVuZGVmaW5lZCxcbiAgICAgIFwiRGlkIG5vdCBmaW5kIGNvcnJlc3BvbmRpbmcgZmV0Y2hlciByZXN1bHRcIlxuICAgICk7XG4gICAgbGV0IHJlc3VsdCA9IGZldGNoZXJSZXN1bHRzW2luZGV4XTtcblxuICAgIC8vIFByb2Nlc3MgZmV0Y2hlciBub24tcmVkaXJlY3QgZXJyb3JzXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoPy5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSB7XG4gICAgICAgICAgLi4uZXJyb3JzLFxuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcbiAgICAgIC8vIGtlZXAgdGhpcyB0byB0eXBlIG5hcnJvdyB0byBhIHN1Y2Nlc3MgcmVzdWx0IGluIHRoZSBlbHNlXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyOiBGZXRjaGVyU3RhdGVzW1wiSWRsZVwiXSA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIFwiIF9oYXNGZXRjaGVyRG9uZUFueXRoaW5nIFwiOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBsb2FkZXJEYXRhLCBlcnJvcnMgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VMb2FkZXJEYXRhKFxuICBsb2FkZXJEYXRhOiBSb3V0ZURhdGEsXG4gIG5ld0xvYWRlckRhdGE6IFJvdXRlRGF0YSxcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBlcnJvcnM6IFJvdXRlRGF0YSB8IG51bGwgfCB1bmRlZmluZWRcbik6IFJvdXRlRGF0YSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0geyAuLi5uZXdMb2FkZXJEYXRhIH07XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAobmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGlmIChuZXdMb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbmV3TG9hZGVyRGF0YVtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOby1vcCAtIHRoaXMgaXMgc28gd2UgaWdub3JlIGV4aXN0aW5nIGRhdGEgaWYgd2UgaGF2ZSBhIGtleSBpbiB0aGVcbiAgICAgICAgLy8gaW5jb21pbmcgb2JqZWN0IHdpdGggYW4gdW5kZWZpbmVkIHZhbHVlLCB3aGljaCBpcyBob3cgd2UgdW5zZXQgYSBwcmlvclxuICAgICAgICAvLyBsb2FkZXJEYXRhIGlmIHdlIGVuY291bnRlciBhIGxvYWRlciBlcnJvclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCAmJiBtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIC8vIFByZXNlcnZlIGV4aXN0aW5nIGtleXMgbm90IGluY2x1ZGVkIGluIG5ld0xvYWRlckRhdGEgYW5kIHdoZXJlIGEgbG9hZGVyXG4gICAgICAvLyB3YXNuJ3QgcmVtb3ZlZCBieSBITVJcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAvLyBEb24ndCBrZWVwIGFueSBsb2FkZXIgZGF0YSBiZWxvdyB0aGUgYm91bmRhcnlcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cblxuLy8gRmluZCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSwgbG9va2luZyB1cHdhcmRzIGZyb20gdGhlIGxlYWYgcm91dGUgKG9yIHRoZVxuLy8gcm91dGUgc3BlY2lmaWVkIGJ5IHJvdXRlSWQpIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBlcnJvciBib3VuZGFyeSxcbi8vIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkoXG4gIG1hdGNoZXM6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2hbXSxcbiAgcm91dGVJZD86IHN0cmluZ1xuKTogQWdub3N0aWNEYXRhUm91dGVNYXRjaCB7XG4gIGxldCBlbGlnaWJsZU1hdGNoZXMgPSByb3V0ZUlkXG4gICAgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSArIDEpXG4gICAgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiAoXG4gICAgZWxpZ2libGVNYXRjaGVzLnJldmVyc2UoKS5maW5kKChtKSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8XG4gICAgbWF0Y2hlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlczogQWdub3N0aWNEYXRhUm91dGVPYmplY3RbXSk6IHtcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdO1xuICByb3V0ZTogQWdub3N0aWNEYXRhUm91dGVPYmplY3Q7XG59IHtcbiAgLy8gUHJlZmVyIGEgcm9vdCBsYXlvdXQgcm91dGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHNoaW0gaW4gYSByb3V0ZSBvYmplY3RcbiAgbGV0IHJvdXRlID0gcm91dGVzLmZpbmQoKHIpID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IGBfX3NoaW0tZXJyb3Itcm91dGVfX2AsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbXG4gICAgICB7XG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICAgIHJvdXRlLFxuICAgICAgfSxcbiAgICBdLFxuICAgIHJvdXRlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKFxuICBzdGF0dXM6IG51bWJlcixcbiAge1xuICAgIHBhdGhuYW1lLFxuICAgIHJvdXRlSWQsXG4gICAgbWV0aG9kLFxuICAgIHR5cGUsXG4gIH06IHtcbiAgICBwYXRobmFtZT86IHN0cmluZztcbiAgICByb3V0ZUlkPzogc3RyaW5nO1xuICAgIG1ldGhvZD86IHN0cmluZztcbiAgICB0eXBlPzogXCJkZWZlci1hY3Rpb25cIjtcbiAgfSA9IHt9XG4pIHtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcblxuICBpZiAoc3RhdHVzID09PSA0MDApIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJCYWQgUmVxdWVzdFwiO1xuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgYFlvdSBtYWRlIGEgJHttZXRob2R9IHJlcXVlc3QgdG8gXCIke3BhdGhuYW1lfVwiIGJ1dCBgICtcbiAgICAgICAgYGRpZCBub3QgcHJvdmlkZSBhIFxcYGxvYWRlclxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIGAgK1xuICAgICAgICBgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkZWZlci1hY3Rpb25cIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJkZWZlcigpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWN0aW9uc1wiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgIHN0YXR1c1RleHQgPSBcIkZvcmJpZGRlblwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIHN0YXR1c1RleHQgPSBcIk5vdCBGb3VuZFwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBgWW91IG1hZGUgYSAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgYCArXG4gICAgICAgIGBkaWQgbm90IHByb3ZpZGUgYW4gXFxgYWN0aW9uXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgYCArXG4gICAgICAgIGBzbyB0aGVyZSBpcyBubyB3YXkgdG8gaGFuZGxlIHRoZSByZXF1ZXN0LmA7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHttZXRob2QudG9VcHBlckNhc2UoKX1cImA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlKFxuICAgIHN0YXR1cyB8fCA1MDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSxcbiAgICB0cnVlXG4gICk7XG59XG5cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QocmVzdWx0czogRGF0YVJlc3VsdFtdKTogUmVkaXJlY3RSZXN1bHQgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwSGFzaEZyb21QYXRoKHBhdGg6IFRvKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aCh7IC4uLnBhcnNlZFBhdGgsIGhhc2g6IFwiXCIgfSk7XG59XG5cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYTogTG9jYXRpb24sIGI6IExvY2F0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoICE9PSBiLmhhc2hcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQ6IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgRGVmZXJyZWRSZXN1bHQge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0OiBEYXRhUmVzdWx0KTogcmVzdWx0IGlzIEVycm9yUmVzdWx0IHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdD86IERhdGFSZXN1bHQpOiByZXN1bHQgaXMgUmVkaXJlY3RSZXN1bHQge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGVmZXJyZWREYXRhIHtcbiAgbGV0IGRlZmVycmVkOiBEZWZlcnJlZERhdGEgPSB2YWx1ZTtcbiAgcmV0dXJuIChcbiAgICBkZWZlcnJlZCAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiBkZWZlcnJlZC5kYXRhID09PSBcIm9iamVjdFwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGRlZmVycmVkLnJlc29sdmVEYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVzcG9uc2Uge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiZcbiAgICB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQ6IGFueSk6IHJlc3VsdCBpcyBSZXNwb25zZSB7XG4gIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICByZXR1cm4gc3RhdHVzID49IDMwMCAmJiBzdGF0dXMgPD0gMzk5ICYmIGxvY2F0aW9uICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iajogYW55KTogb2JqIGlzIFF1ZXJ5Um91dGVSZXNwb25zZSB7XG4gIHJldHVybiAoXG4gICAgb2JqICYmXG4gICAgaXNSZXNwb25zZShvYmoucmVzcG9uc2UpICYmXG4gICAgKG9iai50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgUmVzdWx0VHlwZS5lcnJvcilcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2Q6IHN0cmluZyk6IG1ldGhvZCBpcyBGb3JtTWV0aG9kIHwgVjdfRm9ybU1ldGhvZCB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSBhcyBGb3JtTWV0aG9kKTtcbn1cblxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChcbiAgbWV0aG9kOiBzdHJpbmdcbik6IG1ldGhvZCBpcyBNdXRhdGlvbkZvcm1NZXRob2QgfCBWN19NdXRhdGlvbkZvcm1NZXRob2Qge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZC50b0xvd2VyQ2FzZSgpIGFzIE11dGF0aW9uRm9ybU1ldGhvZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZFJlc3VsdHMoXG4gIGN1cnJlbnRNYXRjaGVzOiBBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoW10sXG4gIG1hdGNoZXNUb0xvYWQ6IChBZ25vc3RpY0RhdGFSb3V0ZU1hdGNoIHwgbnVsbClbXSxcbiAgcmVzdWx0czogRGF0YVJlc3VsdFtdLFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICBpc0ZldGNoZXI6IGJvb2xlYW4sXG4gIGN1cnJlbnRMb2FkZXJEYXRhPzogUm91dGVEYXRhXG4pIHtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJlc3VsdHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaW5kZXhdO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdO1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBtYXRjaCwgdGhlbiB3ZSBjYW4gaGF2ZSBhIGRlZmVycmVkIHJlc3VsdCB0byBkb1xuICAgIC8vIGFueXRoaW5nIHdpdGguICBUaGlzIGlzIGZvciByZXZhbGlkYXRpbmcgZmV0Y2hlcnMgd2hlcmUgdGhlIHJvdXRlIHdhc1xuICAgIC8vIHJlbW92ZWQgZHVyaW5nIEhNUlxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50TWF0Y2ggPSBjdXJyZW50TWF0Y2hlcy5maW5kKFxuICAgICAgKG0pID0+IG0ucm91dGUuaWQgPT09IG1hdGNoIS5yb3V0ZS5pZFxuICAgICk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID1cbiAgICAgIGN1cnJlbnRNYXRjaCAhPSBudWxsICYmXG4gICAgICAhaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpICYmXG4gICAgICAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSAmJiAoaXNGZXRjaGVyIHx8IGlzUmV2YWxpZGF0aW5nTG9hZGVyKSkge1xuICAgICAgLy8gTm90ZTogd2UgZG8gbm90IGhhdmUgdG8gdG91Y2ggYWN0aXZlRGVmZXJyZWRzIGhlcmUgc2luY2Ugd2UgcmFjZSB0aGVtXG4gICAgICAvLyBhZ2FpbnN0IHRoZSBzaWduYWwgaW4gcmVzb2x2ZURlZmVycmVkRGF0YSBhbmQgdGhleSdsbCBnZXQgYWJvcnRlZFxuICAgICAgLy8gdGhlcmUgaWYgbmVlZGVkXG4gICAgICBhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCBpc0ZldGNoZXIpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQgfHwgcmVzdWx0c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKFxuICByZXN1bHQ6IERlZmVycmVkUmVzdWx0LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuICB1bndyYXAgPSBmYWxzZVxuKTogUHJvbWlzZTxTdWNjZXNzUmVzdWx0IHwgRXJyb3JSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHVud3JhcCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEudW53cmFwcGVkRGF0YSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGEsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpLmdldEFsbChcImluZGV4XCIpLnNvbWUoKHYpID0+IHYgPT09IFwiXCIpO1xufVxuXG4vLyBOb3RlOiBUaGlzIHNob3VsZCBtYXRjaCB0aGUgZm9ybWF0IGV4cG9ydGVkIGJ5IHVzZU1hdGNoZXMsIHNvIGlmIHlvdSBjaGFuZ2Vcbi8vIHRoaXMgcGxlYXNlIGFsc28gY2hhbmdlIHRoYXQgOikgIEV2ZW50dWFsbHkgd2UnbGwgRFJZIHRoaXMgdXBcbmZ1bmN0aW9uIGNyZWF0ZVVzZU1hdGNoZXNNYXRjaChcbiAgbWF0Y2g6IEFnbm9zdGljRGF0YVJvdXRlTWF0Y2gsXG4gIGxvYWRlckRhdGE6IFJvdXRlRGF0YVxuKTogVXNlTWF0Y2hlc01hdGNoIHtcbiAgbGV0IHsgcm91dGUsIHBhdGhuYW1lLCBwYXJhbXMgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0gYXMgdW5rbm93bixcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSBhcyB1bmtub3duLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChcbiAgbWF0Y2hlczogQWdub3N0aWNEYXRhUm91dGVNYXRjaFtdLFxuICBsb2NhdGlvbjogTG9jYXRpb24gfCBzdHJpbmdcbikge1xuICBsZXQgc2VhcmNoID1cbiAgICB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKFxuICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJlxuICAgIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2ggfHwgXCJcIilcbiAgKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBsZWFmIGluZGV4IHJvdXRlIHdoZW4gaW5kZXggaXMgcHJlc2VudFxuICAgIHJldHVybiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIGdyYWIgdGhlIGRlZXBlc3QgXCJwYXRoIGNvbnRyaWJ1dGluZ1wiIG1hdGNoIChpZ25vcmluZyBpbmRleCBhbmRcbiAgLy8gcGF0aGxlc3MgbGF5b3V0IHJvdXRlcylcbiAgbGV0IHBhdGhNYXRjaGVzID0gZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcyk7XG4gIHJldHVybiBwYXRoTWF0Y2hlc1twYXRoTWF0Y2hlcy5sZW5ndGggLSAxXTtcbn1cbi8vI2VuZHJlZ2lvblxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ1lBLE9BQUEsQ0FBQUMsTUFBQTtBQXdCWjtBQUNBO0FBQ0E7O1dBMUJZQSxNQUFBO0VBQUFBLE1BQUE7RUFBQUEsTUFBQTtFQUFBQSxNQUFBO0FBQUEsR0FBQUQsT0FBQSxDQUFBQyxNQUFBLEtBQUFELE9BQUEsQ0FBQUMsTUFBQTtBQXdMWixNQUFNQyxpQkFBaUIsR0FBRyxVQUExQjtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxtQkFBVEEsQ0FDTEMsT0FESyxFQUVVO0VBQUEsSUFEZkEsT0FDZTtJQURmQSxPQUNlLEdBRGlCLEVBQ2pCO0VBQUE7RUFDZixJQUFJO0lBQUVDLGNBQWMsR0FBRyxDQUFDLEdBQUQsQ0FBbkI7SUFBMEJDLFlBQTFCO0lBQXdDQyxRQUFRLEdBQUc7RUFBbkQsSUFBNkRILE9BQWpFO0VBQ0EsSUFBSUksT0FBSixDQUZlOztFQUdmQSxPQUFPLEdBQUdILGNBQWMsQ0FBQ0ksR0FBZixDQUFtQixDQUFDQyxLQUFELEVBQVFDLEtBQVIsS0FDM0JDLG9CQUFvQixDQUNsQkYsS0FEa0IsRUFFbEIsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixHQUE0QixJQUE1QixHQUFtQ0EsS0FBSyxDQUFDRyxL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