e5471d671e99a37a274052961110c194
// Axios v1.3.4 Copyright (c) 2023 Matt Zabriskie and contributors
'use strict';

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {
  toString
} = Object.prototype;
const {
  getPrototypeOf
} = Object;
const kindOf = (cache => thing => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
const kindOfTest = type => {
  type = type.toLowerCase();
  return thing => kindOf(thing) === type;
};
const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {
  isArray
} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = thing => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = val => {
  if (kindOf(val) !== 'object') {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = val => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = thing => {
  const pattern = '[object FormData]';
  return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {
  allOwnKeys = false
} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }
  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }
  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();
const isContextDefined = context => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge( /* obj1, obj2, obj3, ... */
) {
  const {
    caseless
  } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {
  allOwnKeys
} = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {
    allOwnKeys
  });
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = content => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};

/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = thing => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');
const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({
  hasOwnProperty
}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');
const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = obj => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = arr => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
const DIGIT = '0123456789';
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {
    length
  } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}
const toJSONObject = obj => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {
  value: true
});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }
  function convertValue(value) {
    if (value === null) return '';
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
          // eslint-disable-next-line no-nested-ternary
          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }
    stack.push(value);
    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }
  build(obj);
  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function (value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager$1 = InterceptorManager;
var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;
var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;
var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && ((product = navigator.product) === 'ReactNative' || product === 'NativeScript' || product === 'NS')) {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== 'undefined' &&
  // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();
var platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function (value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ['xhr', 'http'],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData = utils.isFormData(data);
    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }
    let isFileList;
    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(isFileList ? {
          'files[]': data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol('internals');
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value)) return;
  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }
  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);
  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function (arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }
      const key = utils.findKey(self, lHeader);
      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
        self[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self, _header);
        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self[header];
      }
      self[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach(target => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
var cookies = platform.isStandardBrowserEnv ?
// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      const cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));
      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }
      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }
      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }
      if (secure === true) {
        cookie.push('secure');
      }
      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :
// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var isURLSameOrigin = platform.isStandardBrowserEnv ?
// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement('a');
  let originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    let href = url;
    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :
// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };
    data[isDownloadStream ? 'download' : 'upload'] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }
    if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false); // Let the browser set it
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }
    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (platform.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {
        value
      });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {
      value
    });
  }
});
var adapters = {
  getAdapter: adapters => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];
    const {
      length
    } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`, 'ERR_NOT_SUPPORT');
      }
      throw new Error(utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }
    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(config, config.transformRequest);
  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = thing => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({
        caseless
      }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.3.4";
const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const {
      transitional,
      paramsSerializer,
      headers
    } = config;
    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer !== undefined) {
      validator.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();
    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(headers.common, headers[config.method]);
    contextHeaders && utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
      delete headers[method];
    });
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios$1.prototype, context, {
    allOwnKeys: true
  });

  // Copy context to instance
  utils.extend(instance, context, null, {
    allOwnKeys: true
  });

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
module.exports = axios;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJiaW5kIiwiZm4iLCJ0aGlzQXJnIiwid3JhcCIsImFwcGx5IiwiYXJndW1lbnRzIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsImtpbmRPZiIsImNhY2hlIiwidGhpbmciLCJzdHIiLCJjYWxsIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsImNyZWF0ZSIsImtpbmRPZlRlc3QiLCJ0eXBlIiwidHlwZU9mVGVzdCIsImlzQXJyYXkiLCJBcnJheSIsImlzVW5kZWZpbmVkIiwiaXNCdWZmZXIiLCJ2YWwiLCJjb25zdHJ1Y3RvciIsImlzRnVuY3Rpb24iLCJpc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc09iamVjdCIsImlzQm9vbGVhbiIsImlzUGxhaW5PYmplY3QiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIml0ZXJhdG9yIiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGaWxlTGlzdCIsImlzU3RyZWFtIiwicGlwZSIsImlzRm9ybURhdGEiLCJwYXR0ZXJuIiwiRm9ybURhdGEiLCJpc1VSTFNlYXJjaFBhcmFtcyIsInRyaW0iLCJyZXBsYWNlIiwiZm9yRWFjaCIsIm9iaiIsImFsbE93bktleXMiLCJpIiwibCIsImxlbmd0aCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibGVuIiwia2V5IiwiZmluZEtleSIsIl9rZXkiLCJfZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJpc0NvbnRleHREZWZpbmVkIiwiY29udGV4dCIsIm1lcmdlIiwiY2FzZWxlc3MiLCJhc3NpZ25WYWx1ZSIsInRhcmdldEtleSIsImV4dGVuZCIsImEiLCJiIiwic3RyaXBCT00iLCJjb250ZW50IiwiY2hhckNvZGVBdCIsImluaGVyaXRzIiwic3VwZXJDb25zdHJ1Y3RvciIsInByb3BzIiwiZGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiYXNzaWduIiwidG9GbGF0T2JqZWN0Iiwic291cmNlT2JqIiwiZGVzdE9iaiIsImZpbHRlciIsInByb3BGaWx0ZXIiLCJwcm9wIiwibWVyZ2VkIiwiZW5kc1dpdGgiLCJzZWFyY2hTdHJpbmciLCJwb3NpdGlvbiIsIlN0cmluZyIsInVuZGVmaW5lZCIsImxhc3RJbmRleCIsImluZGV4T2YiLCJ0b0FycmF5IiwiYXJyIiwiaXNUeXBlZEFycmF5IiwiVHlwZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJmb3JFYWNoRW50cnkiLCJnZW5lcmF0b3IiLCJuZXh0IiwiZG9uZSIsInBhaXIiLCJtYXRjaEFsbCIsInJlZ0V4cCIsIm1hdGNoZXMiLCJleGVjIiwicHVzaCIsImlzSFRNTEZvcm0iLCJ0b0NhbWVsQ2FzZSIsInJlcGxhY2VyIiwibSIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsImhhc093blByb3BlcnR5IiwiaXNSZWdFeHAiLCJyZWR1Y2VEZXNjcmlwdG9ycyIsInJlZHVjZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwicmVkdWNlZERlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZnJlZXplTWV0aG9kcyIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInNldCIsIkVycm9yIiwidG9PYmplY3RTZXQiLCJhcnJheU9yU3RyaW5nIiwiZGVsaW1pdGVyIiwiZGVmaW5lIiwic3BsaXQiLCJub29wIiwidG9GaW5pdGVOdW1iZXIiLCJkZWZhdWx0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkFMUEhBIiwiRElHSVQiLCJBTFBIQUJFVCIsIkFMUEhBX0RJR0lUIiwiZ2VuZXJhdGVTdHJpbmciLCJzaXplIiwiYWxwaGFiZXQiLCJNYXRoIiwicmFuZG9tIiwiaXNTcGVjQ29tcGxpYW50Rm9ybSIsImFwcGVuZCIsInRvSlNPTk9iamVjdCIsInN0YWNrIiwidmlzaXQiLCJzb3VyY2UiLCJ0YXJnZXQiLCJyZWR1Y2VkVmFsdWUiLCJ1dGlscyIsImhhc093blByb3AiLCJBeGlvc0Vycm9yIiwibWVzc2FnZSIsImNvZGUiLCJjb25maWciLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInRvSlNPTiIsImRlc2NyaXB0aW9uIiwibnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwic3RhdHVzIiwicHJvdG90eXBlJDEiLCJmcm9tIiwiZXJyb3IiLCJjdXN0b21Qcm9wcyIsImF4aW9zRXJyb3IiLCJjYXVzZSIsImh0dHBBZGFwdGVyIiwiaXNWaXNpdGFibGUiLCJyZW1vdmVCcmFja2V0cyIsInJlbmRlcktleSIsInBhdGgiLCJkb3RzIiwiY29uY2F0IiwibWFwIiwiZWFjaCIsInRva2VuIiwiam9pbiIsImlzRmxhdEFycmF5Iiwic29tZSIsInByZWRpY2F0ZXMiLCJ0ZXN0IiwidG9Gb3JtRGF0YSIsImZvcm1EYXRhIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsIm1ldGFUb2tlbnMiLCJpbmRleGVzIiwiZGVmaW5lZCIsIm9wdGlvbiIsInZpc2l0b3IiLCJkZWZhdWx0VmlzaXRvciIsIl9CbG9iIiwiQmxvYiIsInVzZUJsb2IiLCJjb252ZXJ0VmFsdWUiLCJ0b0lTT1N0cmluZyIsIkJ1ZmZlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJlbCIsImluZGV4IiwiZXhwb3NlZEhlbHBlcnMiLCJidWlsZCIsInBvcCIsImVuY29kZSQxIiwiZW5jb2RlIiwiY2hhck1hcCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1hdGNoIiwiQXhpb3NVUkxTZWFyY2hQYXJhbXMiLCJwYXJhbXMiLCJfcGFpcnMiLCJlbmNvZGVyIiwiX2VuY29kZSIsImJ1aWxkVVJMIiwidXJsIiwic2VyaWFsaXplRm4iLCJzZXJpYWxpemUiLCJzZXJpYWxpemVkUGFyYW1zIiwiaGFzaG1hcmtJbmRleCIsIkludGVyY2VwdG9yTWFuYWdlciIsImhhbmRsZXJzIiwidXNlIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJzeW5jaHJvbm91cyIsInJ1bldoZW4iLCJlamVjdCIsImlkIiwiY2xlYXIiLCJmb3JFYWNoSGFuZGxlciIsImgiLCJJbnRlcmNlcHRvck1hbmFnZXIkMSIsInRyYW5zaXRpb25hbERlZmF1bHRzIiwic2lsZW50SlNPTlBhcnNpbmciLCJmb3JjZWRKU09OUGFyc2luZyIsImNsYXJpZnlUaW1lb3V0RXJyb3IiLCJVUkxTZWFyY2hQYXJhbXMkMSIsIlVSTFNlYXJjaFBhcmFtcyIsIkZvcm1EYXRhJDEiLCJCbG9iJDEiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsInByb2R1Y3QiLCJuYXZpZ2F0b3IiLCJkb2N1bWVudCIsImlzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52IiwiV29ya2VyR2xvYmFsU2NvcGUiLCJpbXBvcnRTY3JpcHRzIiwicGxhdGZvcm0iLCJpc0Jyb3dzZXIiLCJjbGFzc2VzIiwicHJvdG9jb2xzIiwidG9VUkxFbmNvZGVkRm9ybSIsImRhdGEiLCJoZWxwZXJzIiwiaXNOb2RlIiwicGFyc2VQcm9wUGF0aCIsImFycmF5VG9PYmplY3QiLCJmb3JtRGF0YVRvSlNPTiIsImJ1aWxkUGF0aCIsImlzTnVtZXJpY0tleSIsImlzTGFzdCIsImVudHJpZXMiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInN0cmluZ2lmeVNhZmVseSIsInJhd1ZhbHVlIiwicGFyc2VyIiwicGFyc2UiLCJlIiwiZGVmYXVsdHMiLCJ0cmFuc2l0aW9uYWwiLCJhZGFwdGVyIiwidHJhbnNmb3JtUmVxdWVzdCIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsImdldENvbnRlbnRUeXBlIiwiaGFzSlNPTkNvbnRlbnRUeXBlIiwiaXNPYmplY3RQYXlsb2FkIiwic2V0Q29udGVudFR5cGUiLCJmb3JtU2VyaWFsaXplciIsIl9Gb3JtRGF0YSIsImVudiIsInRyYW5zZm9ybVJlc3BvbnNlIiwiSlNPTlJlcXVlc3RlZCIsInJlc3BvbnNlVHlwZSIsInN0cmljdEpTT05QYXJzaW5nIiwiRVJSX0JBRF9SRVNQT05TRSIsInRpbWVvdXQiLCJ4c3JmQ29va2llTmFtZSIsInhzcmZIZWFkZXJOYW1lIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsImNvbW1vbiIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJtZXRob2QiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJkZWZhdWx0cyQxIiwiaWdub3JlRHVwbGljYXRlT2YiLCJwYXJzZUhlYWRlcnMiLCJyYXdIZWFkZXJzIiwicGFyc2VkIiwibGluZSIsInN1YnN0cmluZyIsIiRpbnRlcm5hbHMiLCJub3JtYWxpemVIZWFkZXIiLCJoZWFkZXIiLCJub3JtYWxpemVWYWx1ZSIsInBhcnNlVG9rZW5zIiwidG9rZW5zIiwidG9rZW5zUkUiLCJpc1ZhbGlkSGVhZGVyTmFtZSIsIm1hdGNoSGVhZGVyVmFsdWUiLCJpc0hlYWRlck5hbWVGaWx0ZXIiLCJmb3JtYXRIZWFkZXIiLCJ3IiwiY2hhciIsImJ1aWxkQWNjZXNzb3JzIiwiYWNjZXNzb3JOYW1lIiwibWV0aG9kTmFtZSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImNvbmZpZ3VyYWJsZSIsIkF4aW9zSGVhZGVycyIsInZhbHVlT3JSZXdyaXRlIiwicmV3cml0ZSIsInNldEhlYWRlciIsIl92YWx1ZSIsIl9oZWFkZXIiLCJfcmV3cml0ZSIsImxIZWFkZXIiLCJzZXRIZWFkZXJzIiwiZ2V0IiwiaGFzIiwibWF0Y2hlciIsImRlbGV0ZSIsImRlbGV0ZWQiLCJkZWxldGVIZWFkZXIiLCJub3JtYWxpemUiLCJmb3JtYXQiLCJub3JtYWxpemVkIiwidGFyZ2V0cyIsImFzU3RyaW5ncyIsImZpcnN0IiwiY29tcHV0ZWQiLCJhY2Nlc3NvciIsImludGVybmFscyIsImFjY2Vzc29ycyIsImRlZmluZUFjY2Vzc29yIiwiQXhpb3NIZWFkZXJzJDEiLCJ0cmFuc2Zvcm1EYXRhIiwiZm5zIiwidHJhbnNmb3JtIiwiaXNDYW5jZWwiLCJfX0NBTkNFTF9fIiwiQ2FuY2VsZWRFcnJvciIsIkVSUl9DQU5DRUxFRCIsInNldHRsZSIsInJlc29sdmUiLCJyZWplY3QiLCJFUlJfQkFEX1JFUVVFU1QiLCJmbG9vciIsImNvb2tpZXMiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJyZWFkIiwiUmVnRXhwIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVtb3ZlIiwibm93Iiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiYmFzZVVSTCIsInJlbGF0aXZlVVJMIiwiYnVpbGRGdWxsUGF0aCIsInJlcXVlc3RlZFVSTCIsImlzVVJMU2FtZU9yaWdpbiIsIm1zaWUiLCJ1c2VyQWdlbnQiLCJ1cmxQYXJzaW5nTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaHJlZiIsInNldEF0dHJpYnV0ZSIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhhc2giLCJob3N0bmFtZSIsInBvcnQiLCJwYXRobmFtZSIsImNoYXJBdCIsImxvY2F0aW9uIiwicmVxdWVzdFVSTCIsInBhcnNlUHJvdG9jb2wiLCJzcGVlZG9tZXRlciIsInNhbXBsZXNDb3VudCIsIm1pbiIsImJ5dGVzIiwidGltZXN0YW1wcyIsImhlYWQiLCJ0YWlsIiwiZmlyc3RTYW1wbGVUUyIsImNodW5rTGVuZ3RoIiwic3RhcnRlZEF0IiwiYnl0ZXNDb3VudCIsInBhc3NlZCIsInJvdW5kIiwicHJvZ3Jlc3NFdmVudFJlZHVjZXIiLCJsaXN0ZW5lciIsImlzRG93bmxvYWRTdHJlYW0iLCJieXRlc05vdGlmaWVkIiwiX3NwZWVkb21ldGVyIiwibG9hZGVkIiwidG90YWwiLCJsZW5ndGhDb21wdXRhYmxlIiwicHJvZ3Jlc3NCeXRlcyIsInJhdGUiLCJpblJhbmdlIiwicHJvZ3Jlc3MiLCJlc3RpbWF0ZWQiLCJldmVudCIsImlzWEhSQWRhcHRlclN1cHBvcnRlZCIsIlhNTEh0dHBSZXF1ZXN0IiwieGhyQWRhcHRlciIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwib25DYW5jZWxlZCIsImNhbmNlbFRva2VuIiwidW5zdWJzY3JpYmUiLCJzaWduYWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1bmVzY2FwZSIsImJ0b2EiLCJmdWxsUGF0aCIsIm9wZW4iLCJwYXJhbXNTZXJpYWxpemVyIiwib25sb2FkZW5kIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VEYXRhIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsIl9yZXNvbHZlIiwiX3JlamVjdCIsImVyciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJzZXRUaW1lb3V0Iiwib25hYm9ydCIsImhhbmRsZUFib3J0IiwiRUNPTk5BQk9SVEVEIiwib25lcnJvciIsImhhbmRsZUVycm9yIiwiRVJSX05FVFdPUksiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwidGltZW91dEVycm9yTWVzc2FnZSIsIkVUSU1FRE9VVCIsInhzcmZWYWx1ZSIsIndpdGhDcmVkZW50aWFscyIsInNldFJlcXVlc3RIZWFkZXIiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJhZGRFdmVudExpc3RlbmVyIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbCIsImFib3J0Iiwic3Vic2NyaWJlIiwiYWJvcnRlZCIsInNlbmQiLCJrbm93bkFkYXB0ZXJzIiwiaHR0cCIsInhociIsImFkYXB0ZXJzIiwiZ2V0QWRhcHRlciIsIm5hbWVPckFkYXB0ZXIiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImRpc3BhdGNoUmVxdWVzdCIsInRoZW4iLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwib25BZGFwdGVyUmVqZWN0aW9uIiwicmVhc29uIiwiaGVhZGVyc1RvT2JqZWN0IiwibWVyZ2VDb25maWciLCJjb25maWcxIiwiY29uZmlnMiIsImdldE1lcmdlZFZhbHVlIiwibWVyZ2VEZWVwUHJvcGVydGllcyIsInZhbHVlRnJvbUNvbmZpZzIiLCJkZWZhdWx0VG9Db25maWcyIiwibWVyZ2VEaXJlY3RLZXlzIiwibWVyZ2VNYXAiLCJ0aW1lb3V0TWVzc2FnZSIsImRlY29tcHJlc3MiLCJiZWZvcmVSZWRpcmVjdCIsInRyYW5zcG9ydCIsImh0dHBBZ2VudCIsImh0dHBzQWdlbnQiLCJzb2NrZXRQYXRoIiwicmVzcG9uc2VFbmNvZGluZyIsImNvbXB1dGVDb25maWdWYWx1ZSIsImNvbmZpZ1ZhbHVlIiwiVkVSU0lPTiIsInZhbGlkYXRvcnMkMSIsInZhbGlkYXRvciIsImRlcHJlY2F0ZWRXYXJuaW5ncyIsInZlcnNpb24iLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsIm9wdHMiLCJFUlJfREVQUkVDQVRFRCIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0T3B0aW9ucyIsInNjaGVtYSIsImFsbG93VW5rbm93biIsIkVSUl9CQURfT1BUSU9OX1ZBTFVFIiwiRVJSX0JBRF9PUFRJT04iLCJ2YWxpZGF0b3JzIiwiQXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsImludGVyY2VwdG9ycyIsImNvbmZpZ09yVXJsIiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiY29udGV4dEhlYWRlcnMiLCJyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiIsInN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJ1bnNoaWZ0IiwicmVzcG9uc2VJbnRlcmNlcHRvckNoYWluIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwicHJvbWlzZSIsImNoYWluIiwibmV3Q29uZmlnIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiZ2V0VXJpIiwiZ2VuZXJhdGVIVFRQTWV0aG9kIiwiaXNGb3JtIiwiaHR0cE1ldGhvZCIsIkF4aW9zJDEiLCJDYW5jZWxUb2tlbiIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJfbGlzdGVuZXJzIiwib25mdWxmaWxsZWQiLCJzcGxpY2UiLCJjIiwiQ2FuY2VsVG9rZW4kMSIsInNwcmVhZCIsImNhbGxiYWNrIiwiaXNBeGlvc0Vycm9yIiwicGF5bG9hZCIsIkh0dHBTdGF0dXNDb2RlIiwiQ29udGludWUiLCJTd2l0Y2hpbmdQcm90b2NvbHMiLCJQcm9jZXNzaW5nIiwiRWFybHlIaW50cyIsIk9rIiwiQ3JlYXRlZCIsIkFjY2VwdGVkIiwiTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uIiwiTm9Db250ZW50IiwiUmVzZXRDb250ZW50IiwiUGFydGlhbENvbnRlbnQiLCJNdWx0aVN0YXR1cyIsIkFscmVhZHlSZXBvcnRlZCIsIkltVXNlZCIsIk11bHRpcGxlQ2hvaWNlcyIsIk1vdmVkUGVybWFuZW50bHkiLCJGb3VuZCIsIlNlZU90aGVyIiwiTm90TW9kaWZpZWQiLCJVc2VQcm94eSIsIlVudXNlZCIsIlRlbXBvcmFyeVJlZGlyZWN0IiwiUGVybWFuZW50UmVkaXJlY3QiLCJCYWRSZXF1ZXN0IiwiVW5hdXRob3JpemVkIiwiUGF5bWVudFJlcXVpcmVkIiwiRm9yYmlkZGVuIiwiTm90Rm91bmQiLCJNZXRob2ROb3RBbGxvd2VkIiwiTm90QWNjZXB0YWJsZSIsIlByb3h5QXV0aGVudGljYXRpb25SZXF1aXJlZCIsIlJlcXVlc3RUaW1lb3V0IiwiQ29uZmxpY3QiLCJHb25lIiwiTGVuZ3RoUmVxdWlyZWQiLCJQcmVjb25kaXRpb25GYWlsZWQiLCJQYXlsb2FkVG9vTGFyZ2UiLCJVcmlUb29Mb25nIiwiVW5zdXBwb3J0ZWRNZWRpYVR5cGUiLCJSYW5nZU5vdFNhdGlzZmlhYmxlIiwiRXhwZWN0YXRpb25GYWlsZWQiLCJJbUFUZWFwb3QiLCJNaXNkaXJlY3RlZFJlcXVlc3QiLCJVbnByb2Nlc3NhYmxlRW50aXR5IiwiTG9ja2VkIiwiRmFpbGVkRGVwZW5kZW5jeSIsIlRvb0Vhcmx5IiwiVXBncmFkZVJlcXVpcmVkIiwiUHJlY29uZGl0aW9uUmVxdWlyZWQiLCJUb29NYW55UmVxdWVzdHMiLCJSZXF1ZXN0SGVhZGVyRmllbGRzVG9vTGFyZ2UiLCJVbmF2YWlsYWJsZUZvckxlZ2FsUmVhc29ucyIsIkludGVybmFsU2VydmVyRXJyb3IiLCJOb3RJbXBsZW1lbnRlZCIsIkJhZEdhdGV3YXkiLCJTZXJ2aWNlVW5hdmFpbGFibGUiLCJHYXRld2F5VGltZW91dCIsIkh0dHBWZXJzaW9uTm90U3VwcG9ydGVkIiwiVmFyaWFudEFsc29OZWdvdGlhdGVzIiwiSW5zdWZmaWNpZW50U3RvcmFnZSIsIkxvb3BEZXRlY3RlZCIsIk5vdEV4dGVuZGVkIiwiTmV0d29ya0F1dGhlbnRpY2F0aW9uUmVxdWlyZWQiLCJIdHRwU3RhdHVzQ29kZSQxIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiaW5zdGFuY2UiLCJheGlvcyIsIkNhbmNlbCIsImFsbCIsInByb21pc2VzIiwiZm9ybVRvSlNPTiIsImRlZmF1bHQiXSwic291cmNlcyI6WyIuLi8uLi9saWIvaGVscGVycy9iaW5kLmpzIiwiLi4vLi4vbGliL3V0aWxzLmpzIiwiLi4vLi4vbGliL2NvcmUvQXhpb3NFcnJvci5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL251bGwuanMiLCIuLi8uLi9saWIvaGVscGVycy90b0Zvcm1EYXRhLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMiLCIuLi8uLi9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIi4uLy4uL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIi4uLy4uL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMiLCIuLi8uLi9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcyIsIi4uLy4uL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvRm9ybURhdGEuanMiLCIuLi8uLi9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Jsb2IuanMiLCIuLi8uLi9saWIvcGxhdGZvcm0vYnJvd3Nlci9pbmRleC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMiLCIuLi8uLi9saWIvaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyIsIi4uLy4uL2xpYi9kZWZhdWx0cy9pbmRleC5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIi4uLy4uL2xpYi9jb3JlL0F4aW9zSGVhZGVycy5qcyIsIi4uLy4uL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCIuLi8uLi9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiLi4vLi4vbGliL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzIiwiLi4vLi4vbGliL2NvcmUvc2V0dGxlLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvY29va2llcy5qcyIsIi4uLy4uL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCIuLi8uLi9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIi4uLy4uL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCIuLi8uLi9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCIuLi8uLi9saWIvaGVscGVycy9wYXJzZVByb3RvY29sLmpzIiwiLi4vLi4vbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMiLCIuLi8uLi9saWIvYWRhcHRlcnMveGhyLmpzIiwiLi4vLi4vbGliL2FkYXB0ZXJzL2FkYXB0ZXJzLmpzIiwiLi4vLi4vbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwiLi4vLi4vbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCIuLi8uLi9saWIvZW52L2RhdGEuanMiLCIuLi8uLi9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCIuLi8uLi9saWIvY29yZS9BeGlvcy5qcyIsIi4uLy4uL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCIuLi8uLi9saWIvaGVscGVycy9zcHJlYWQuanMiLCIuLi8uLi9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCIuLi8uLi9saWIvaGVscGVycy9IdHRwU3RhdHVzQ29kZS5qcyIsIi4uLy4uL2xpYi9heGlvcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuXG5jb25zdCBraW5kT2YgPSAoY2FjaGUgPT4gdGhpbmcgPT4ge1xuICAgIGNvbnN0IHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuICh0aGluZykgPT4ga2luZE9mKHRoaW5nKSA9PT0gdHlwZVxufVxuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24odmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKSAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Z1bmN0aW9uID0gdHlwZU9mVGVzdCgnZnVuY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc051bWJlciA9IHR5cGVPZlRlc3QoJ251bWJlcicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jvb2xlYW4gPSB0aGluZyA9PiB0aGluZyA9PT0gdHJ1ZSB8fCB0aGluZyA9PT0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xuICBjb25zdCBwYXR0ZXJuID0gJ1tvYmplY3QgRm9ybURhdGFdJztcbiAgcmV0dXJuIHRoaW5nICYmIChcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8XG4gICAgdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IHBhdHRlcm4gfHxcbiAgICAoaXNGdW5jdGlvbih0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gcGF0dGVybilcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IGFsbE93bktleXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopIDogT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kS2V5KG9iaiwga2V5KSB7XG4gIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IF9rZXk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgX2tleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSA9PT0gX2tleS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gX2tleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xuICAvKmVzbGludCBuby11bmRlZjowKi9cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcbn0pKCk7XG5cbmNvbnN0IGlzQ29udGV4dERlZmluZWQgPSAoY29udGV4dCkgPT4gIWlzVW5kZWZpbmVkKGNvbnRleHQpICYmIGNvbnRleHQgIT09IF9nbG9iYWw7XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgY29uc3Qge2Nhc2VsZXNzfSA9IGlzQ29udGV4dERlZmluZWQodGhpcykgJiYgdGhpcyB8fCB7fTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGFzc2lnblZhbHVlID0gKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gY2FzZWxlc3MgJiYgZmluZEtleShyZXN1bHQsIGtleSkgfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2UocmVzdWx0W3RhcmdldEtleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXSAmJiBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzXVxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5jb25zdCBleHRlbmQgPSAoYSwgYiwgdGhpc0FyZywge2FsbE93bktleXN9PSB7fSkgPT4ge1xuICBmb3JFYWNoKGIsICh2YWwsIGtleSkgPT4ge1xuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7YWxsT3duS2V5c30pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuY29uc3Qgc3RyaXBCT00gPSAoY29udGVudCkgPT4ge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGVzdE9ial1cbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wRmlsdGVyXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IHRvRmxhdE9iamVjdCA9IChzb3VyY2VPYmosIGRlc3RPYmosIGZpbHRlciwgcHJvcEZpbHRlcikgPT4ge1xuICBsZXQgcHJvcHM7XG4gIGxldCBpO1xuICBsZXQgcHJvcDtcbiAgY29uc3QgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICBpZiAoc291cmNlT2JqID09IG51bGwpIHJldHVybiBkZXN0T2JqO1xuXG4gIGRvIHtcbiAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZU9iaik7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKCghcHJvcEZpbHRlciB8fCBwcm9wRmlsdGVyKHByb3AsIHNvdXJjZU9iaiwgZGVzdE9iaikpICYmICFtZXJnZWRbcHJvcF0pIHtcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcbiAgICAgICAgbWVyZ2VkW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlT2JqID0gZmlsdGVyICE9PSBmYWxzZSAmJiBnZXRQcm90b3R5cGVPZihzb3VyY2VPYmopO1xuICB9IHdoaWxlIChzb3VyY2VPYmogJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNvdXJjZU9iaiwgZGVzdE9iaikpICYmIHNvdXJjZU9iaiAhPT0gT2JqZWN0LnByb3RvdHlwZSk7XG5cbiAgcmV0dXJuIGRlc3RPYmo7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uPSAwXVxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBlbmRzV2l0aCA9IChzdHIsIHNlYXJjaFN0cmluZywgcG9zaXRpb24pID0+IHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID4gc3RyLmxlbmd0aCkge1xuICAgIHBvc2l0aW9uID0gc3RyLmxlbmd0aDtcbiAgfVxuICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDaGVja2luZyBpZiB0aGUgVWludDhBcnJheSBleGlzdHMgYW5kIGlmIGl0IGRvZXMsIGl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XG4gKlxuICogQHBhcmFtIHtUeXBlZEFycmF5fVxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbmNvbnN0IGlzVHlwZWRBcnJheSA9IChUeXBlZEFycmF5ID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIHRoaW5nID0+IHtcbiAgICByZXR1cm4gVHlwZWRBcnJheSAmJiB0aGluZyBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG4gIH07XG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xuXG4vKipcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmNvbnN0IGZvckVhY2hFbnRyeSA9IChvYmosIGZuKSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9IG9iaiAmJiBvYmpbU3ltYm9sLml0ZXJhdG9yXTtcblxuICBjb25zdCBpdGVyYXRvciA9IGdlbmVyYXRvci5jYWxsKG9iaik7XG5cbiAgbGV0IHJlc3VsdDtcblxuICB3aGlsZSAoKHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKSkgJiYgIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcbiAgICBmbi5jYWxsKG9iaiwgcGFpclswXSwgcGFpclsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qIENoZWNraW5nIGlmIHRoZSBraW5kT2ZUZXN0IGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB3aGVuIHBhc3NlZCBhbiBIVE1MRm9ybUVsZW1lbnQuICovXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XG5cbmNvbnN0IHRvQ2FtZWxDYXNlID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gICAgZnVuY3Rpb24gcmVwbGFjZXIobSwgcDEsIHAyKSB7XG4gICAgICByZXR1cm4gcDEudG9VcHBlckNhc2UoKSArIHAyO1xuICAgIH1cbiAgKTtcbn07XG5cbi8qIENyZWF0aW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNoZWNrIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gKCh7aGFzT3duUHJvcGVydHl9KSA9PiAob2JqLCBwcm9wKSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpKE9iamVjdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNSZWdFeHAgPSBraW5kT2ZUZXN0KCdSZWdFeHAnKTtcblxuY29uc3QgcmVkdWNlRGVzY3JpcHRvcnMgPSAob2JqLCByZWR1Y2VyKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKTtcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XG5cbiAgZm9yRWFjaChkZXNjcmlwdG9ycywgKGRlc2NyaXB0b3IsIG5hbWUpID0+IHtcbiAgICBpZiAocmVkdWNlcihkZXNjcmlwdG9yLCBuYW1lLCBvYmopICE9PSBmYWxzZSkge1xuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn1cblxuLyoqXG4gKiBNYWtlcyBhbGwgbWV0aG9kcyByZWFkLW9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5jb25zdCBmcmVlemVNZXRob2RzID0gKG9iaikgPT4ge1xuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgLy8gc2tpcCByZXN0cmljdGVkIHByb3BzIGluIHN0cmljdCBtb2RlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xuICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgXFwnJyArIG5hbWUgKyAnXFwnJyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBpc0FycmF5KGFycmF5T3JTdHJpbmcpID8gZGVmaW5lKGFycmF5T3JTdHJpbmcpIDogZGVmaW5lKFN0cmluZyhhcnJheU9yU3RyaW5nKS5zcGxpdChkZWxpbWl0ZXIpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxuY29uc3QgQUxQSEEgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXG5cbmNvbnN0IERJR0lUID0gJzAxMjM0NTY3ODknO1xuXG5jb25zdCBBTFBIQUJFVCA9IHtcbiAgRElHSVQsXG4gIEFMUEhBLFxuICBBTFBIQV9ESUdJVDogQUxQSEEgKyBBTFBIQS50b1VwcGVyQ2FzZSgpICsgRElHSVRcbn1cblxuY29uc3QgZ2VuZXJhdGVTdHJpbmcgPSAoc2l6ZSA9IDE2LCBhbHBoYWJldCA9IEFMUEhBQkVULkFMUEhBX0RJR0lUKSA9PiB7XG4gIGxldCBzdHIgPSAnJztcbiAgY29uc3Qge2xlbmd0aH0gPSBhbHBoYWJldDtcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIHN0ciArPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogbGVuZ3RofDBdXG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIElmIHRoZSB0aGluZyBpcyBhIEZvcm1EYXRhIG9iamVjdCwgcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB0aGluZyAtIFRoZSB0aGluZyB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGVjQ29tcGxpYW50Rm9ybSh0aGluZykge1xuICByZXR1cm4gISEodGhpbmcgJiYgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIHRoaW5nW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YScgJiYgdGhpbmdbU3ltYm9sLml0ZXJhdG9yXSk7XG59XG5cbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgQXJyYXkoMTApO1xuXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xuXG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCEoJ3RvSlNPTicgaW4gc291cmNlKSkge1xuICAgICAgICBzdGFja1tpXSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzb3VyY2UpID8gW10gOiB7fTtcblxuICAgICAgICBmb3JFYWNoKHNvdXJjZSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VkVmFsdWUgPSB2aXNpdCh2YWx1ZSwgaSArIDEpO1xuICAgICAgICAgICFpc1VuZGVmaW5lZChyZWR1Y2VkVmFsdWUpICYmICh0YXJnZXRba2V5XSA9IHJlZHVjZWRWYWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0YWNrW2ldID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB2aXNpdChvYmosIDApO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBBTFBIQUJFVCxcbiAgZ2VuZXJhdGVTdHJpbmcsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICByZXNwb25zZSAmJiAodGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc3RyaWN0XG5leHBvcnQgZGVmYXVsdCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbi8vIHRlbXBvcmFyeSBob3RmaXggdG8gYXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyB1bnRpbCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBpcyByZWZhY3RvcmVkXG5pbXBvcnQgUGxhdGZvcm1Gb3JtRGF0YSBmcm9tICcuLi9wbGF0Zm9ybS9ub2RlL2NsYXNzZXMvRm9ybURhdGEuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgdmlzaXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcbiAgcmV0dXJuIHV0aWxzLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzLmlzQXJyYXkodGhpbmcpO1xufVxuXG4vKipcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSB3aXRob3V0IHRoZSBicmFja2V0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XG4gIHJldHVybiB1dGlscy5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhdGgsIGEga2V5LCBhbmQgYSBib29sZWFuLCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgb2JqZWN0IGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90cyAtIElmIHRydWUsIHRoZSBrZXkgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGRvdHMgaW5zdGVhZCBvZiBicmFja2V0cy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4ga2V5O1xuICByZXR1cm4gcGF0aC5jb25jYXQoa2V5KS5tYXAoZnVuY3Rpb24gZWFjaCh0b2tlbiwgaSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHRva2VuID0gcmVtb3ZlQnJhY2tldHModG9rZW4pO1xuICAgIHJldHVybiAhZG90cyAmJiBpID8gJ1snICsgdG9rZW4gKyAnXScgOiB0b2tlbjtcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xufVxuXG4vKipcbiAqIElmIHRoZSBhcnJheSBpcyBhbiBhcnJheSBhbmQgbm9uZSBvZiBpdHMgZWxlbWVudHMgYXJlIHZpc2l0YWJsZSwgdGhlbiBpdCdzIGEgZmxhdCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZsYXRBcnJheShhcnIpIHtcbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMudG9GbGF0T2JqZWN0KHV0aWxzLCB7fSwgbnVsbCwgZnVuY3Rpb24gZmlsdGVyKHByb3ApIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7P09iamVjdH0gW2Zvcm1EYXRhXVxuICogQHBhcmFtIHs/T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1ldGFUb2tlbnMgPSB0cnVlXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb3RzID0gZmFsc2VdXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqKi9cblxuLyoqXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0IHRvIGZvcm0gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdG9Gb3JtRGF0YShvYmosIGZvcm1EYXRhLCBvcHRpb25zKSB7XG4gIGlmICghdXRpbHMuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChQbGF0Zm9ybUZvcm1EYXRhIHx8IEZvcm1EYXRhKSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBvcHRpb25zID0gdXRpbHMudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscy5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICBjb25zdCB2aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yIHx8IGRlZmF1bHRWaXNpdG9yO1xuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xuICBjb25zdCBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICBjb25zdCBfQmxvYiA9IG9wdGlvbnMuQmxvYiB8fCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgQmxvYjtcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzLmlzU3BlY0NvbXBsaWFudEZvcm0oZm9ybURhdGEpO1xuXG4gIGlmICghdXRpbHMuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZUJsb2IgJiYgdXRpbHMuaXNCbG9iKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ0Jsb2IgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGEgQnVmZmVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmlzaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZ3xOdW1iZXI+fSBwYXRoXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHRvIHZpc2l0IHRoZSBlYWNoIHByb3Agb2YgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0VmlzaXRvcih2YWx1ZSwga2V5LCBwYXRoKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICYmICFwYXRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh1dGlscy5lbmRzV2l0aChrZXksICd7fScpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKHV0aWxzLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscy5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscy5lbmRzV2l0aChrZXksICdbXScpKSAmJiAoYXJyID0gdXRpbHMudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBpbmRleGVzID09PSB0cnVlID8gcmVuZGVyS2V5KFtrZXldLCBpbmRleCwgZG90cykgOiAoaW5kZXhlcyA9PT0gbnVsbCA/IGtleSA6IGtleSArICdbXScpLFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzVmlzaXRhYmxlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9ybURhdGEuYXBwZW5kKHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpLCBjb252ZXJ0VmFsdWUodmFsdWUpKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcbiAgICBkZWZhdWx0VmlzaXRvcixcbiAgICBjb252ZXJ0VmFsdWUsXG4gICAgaXNWaXNpdGFibGVcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gICAgfVxuXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiB2aXNpdG9yLmNhbGwoXG4gICAgICAgIGZvcm1EYXRhLCBlbCwgdXRpbHMuaXNTdHJpbmcoa2V5KSA/IGtleS50cmltKCkgOiBrZXksIHBhdGgsIGV4cG9zZWRIZWxwZXJzXG4gICAgICApO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgIGJ1aWxkKGVsLCBwYXRoID8gcGF0aC5jb25jYXQoa2V5KSA6IFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi4vaGVscGVycy9BeGlvc1VSTFNlYXJjaFBhcmFtcy5qcyc7XG5cbi8qKlxuICogSXQgcmVwbGFjZXMgYWxsIGluc3RhbmNlcyBvZiB0aGUgY2hhcmFjdGVycyBgOmAsIGAkYCwgYCxgLCBgK2AsIGBbYCwgYW5kIGBdYCB3aXRoIHRoZWlyXG4gKiBVUkkgZW5jb2RlZCBjb3VudGVycGFydHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsIFRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/b2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGNvbnN0IHNlcmlhbGl6ZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZTtcblxuICBsZXQgc2VyaWFsaXplZFBhcmFtcztcblxuICBpZiAoc2VyaWFsaXplRm4pIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gc2VyaWFsaXplRm4ocGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSA/XG4gICAgICBwYXJhbXMudG9TdHJpbmcoKSA6XG4gICAgICBuZXcgQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKS50b1N0cmluZyhfZW5jb2RlKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgY29uc3QgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcblxuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgICBmbihoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uLy4uLy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgPyBVUkxTZWFyY2hQYXJhbXMgOiBBeGlvc1VSTFNlYXJjaFBhcmFtcztcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyA/IEZvcm1EYXRhIDogbnVsbDtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbFxuIiwiaW1wb3J0IFVSTFNlYXJjaFBhcmFtcyBmcm9tICcuL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzJ1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJy4vY2xhc3Nlcy9Gb3JtRGF0YS5qcydcbmltcG9ydCBCbG9iIGZyb20gJy4vY2xhc3Nlcy9CbG9iLmpzJ1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNTdGFuZGFyZEJyb3dzZXJFbnYgPSAoKCkgPT4ge1xuICBsZXQgcHJvZHVjdDtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICAocHJvZHVjdCA9IG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgIHByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgcHJvZHVjdCA9PT0gJ05TJylcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59KSgpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG4gY29uc3QgaXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNCcm93c2VyOiB0cnVlLFxuICBjbGFzc2VzOiB7XG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIEZvcm1EYXRhLFxuICAgIEJsb2JcbiAgfSxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGlzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2Jsb2InLCAndXJsJywgJ2RhdGEnXVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRvRm9ybURhdGEoZGF0YSwgbmV3IHBsYXRmb3JtLmNsYXNzZXMuVVJMU2VhcmNoUGFyYW1zKCksIE9iamVjdC5hc3NpZ24oe1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5kZWZhdWx0VmlzaXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwgb3B0aW9ucykpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscy5tYXRjaEFsbCgvXFx3K3xcXFsoXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XG4gICAgcmV0dXJuIG1hdGNoWzBdID09PSAnW10nID8gJycgOiBtYXRjaFsxXSB8fCBtYXRjaFswXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY29udmVydCB0byBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzIGFzIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcnIpO1xuICBsZXQgaTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgb2JqW2tleV0gPSBhcnJba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgRm9ybURhdGEgb2JqZWN0IGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgVGhlIEZvcm1EYXRhIG9iamVjdCB0byBjb252ZXJ0IHRvIEpTT04uXG4gKlxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZm9ybURhdGFUb0pTT04oZm9ybURhdGEpIHtcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XG4gICAgbGV0IG5hbWUgPSBwYXRoW2luZGV4KytdO1xuICAgIGNvbnN0IGlzTnVtZXJpY0tleSA9IE51bWJlci5pc0Zpbml0ZSgrbmFtZSk7XG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XG4gICAgbmFtZSA9ICFuYW1lICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xuXG4gICAgaWYgKGlzTGFzdCkge1xuICAgICAgaWYgKHV0aWxzLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzLmlzT2JqZWN0KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGJ1aWxkUGF0aChwYXRoLCB2YWx1ZSwgdGFyZ2V0W25hbWVdLCBpbmRleCk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gYXJyYXlUb09iamVjdCh0YXJnZXRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiAhaXNOdW1lcmljS2V5O1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzLmlzRnVuY3Rpb24oZm9ybURhdGEuZW50cmllcykpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcblxuICAgIHV0aWxzLmZvckVhY2hFbnRyeShmb3JtRGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBidWlsZFBhdGgocGFyc2VQcm9wUGF0aChuYW1lKSwgdmFsdWUsIG9iaiwgMCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1EYXRhVG9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHRvVVJMRW5jb2RlZEZvcm0gZnJvbSAnLi4vaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcblxuICBhZGFwdGVyOiBbJ3hocicsICdodHRwJ10sXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXRDb250ZW50VHlwZSgpIHx8ICcnO1xuICAgIGNvbnN0IGhhc0pTT05Db250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xO1xuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscy5pc0hUTUxGb3JtKGRhdGEpKSB7XG4gICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRm9ybURhdGEgPSB1dGlscy5pc0Zvcm1EYXRhKGRhdGEpO1xuXG4gICAgaWYgKGlzRm9ybURhdGEpIHtcbiAgICAgIGlmICghaGFzSlNPTkNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgICB9XG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBwYXJzZUhlYWRlcnMgZnJvbSAnLi4vaGVscGVycy9wYXJzZUhlYWRlcnMuanMnO1xuXG5jb25zdCAkaW50ZXJuYWxzID0gU3ltYm9sKCdpbnRlcm5hbHMnKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyICYmIFN0cmluZyhoZWFkZXIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAobm9ybWFsaXplVmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb2tlbnMoc3RyKSB7XG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHRva2Vuc1JFID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IG1hdGNoO1xuXG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbnNSRS5leGVjKHN0cikpKSB7XG4gICAgdG9rZW5zW21hdGNoWzFdXSA9IG1hdGNoWzJdO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEhlYWRlck5hbWUoc3RyKSB7XG4gIHJldHVybiAvXlstX2EtekEtWl0rJC8udGVzdChzdHIudHJpbSgpKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbnV0aWxzLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSk7XG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICBjb25zdCBjb250ZXh0ID0gcmVzcG9uc2UgfHwgY29uZmlnO1xuICBjb25zdCBoZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29udGV4dC5oZWFkZXJzKTtcbiAgbGV0IGRhdGEgPSBjb250ZXh0LmRhdGE7XG5cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q9fSByZXF1ZXN0IFRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsZWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9BeGlvc0Vycm9yLmpzJztcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5pc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgcGxhdGZvcm0uaXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4vLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3Rcbi8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIGNvbnN0IG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGNvbnN0IHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxldCBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgbGV0IGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XG4gIGNvbnN0IG1hdGNoID0gL14oWy0rXFx3XXsxLDI1fSkoOj9cXC9cXC98OikvLmV4ZWModXJsKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlc0NvdW50PSAxMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPSAxMDAwXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcGVlZG9tZXRlcihzYW1wbGVzQ291bnQsIG1pbikge1xuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgbGV0IGhlYWQgPSAwO1xuICBsZXQgdGFpbCA9IDA7XG4gIGxldCBmaXJzdFNhbXBsZVRTO1xuXG4gIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogMTAwMDtcblxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xuXG4gICAgaWYgKCFmaXJzdFNhbXBsZVRTKSB7XG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xuICAgIH1cblxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XG4gICAgdGltZXN0YW1wc1toZWFkXSA9IG5vdztcblxuICAgIGxldCBpID0gdGFpbDtcbiAgICBsZXQgYnl0ZXNDb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xuICAgICAgYnl0ZXNDb3VudCArPSBieXRlc1tpKytdO1xuICAgICAgaSA9IGkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaGVhZCA9IChoZWFkICsgMSkgJSBzYW1wbGVzQ291bnQ7XG5cbiAgICBpZiAoaGVhZCA9PT0gdGFpbCkge1xuICAgICAgdGFpbCA9ICh0YWlsICsgMSkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIGZpcnN0U2FtcGxlVFMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xuXG4gICAgcmV0dXJuIHBhc3NlZCA/IE1hdGgucm91bmQoYnl0ZXNDb3VudCAqIDEwMDAgLyBwYXNzZWQpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzcGVlZG9tZXRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHNldHRsZSBmcm9tICcuLy4uL2NvcmUvc2V0dGxlLmpzJztcbmltcG9ydCBjb29raWVzIGZyb20gJy4vLi4vaGVscGVycy9jb29raWVzLmpzJztcbmltcG9ydCBidWlsZFVSTCBmcm9tICcuLy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSAnLi4vY29yZS9idWlsZEZ1bGxQYXRoLmpzJztcbmltcG9ydCBpc1VSTFNhbWVPcmlnaW4gZnJvbSAnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyc7XG5pbXBvcnQgdHJhbnNpdGlvbmFsRGVmYXVsdHMgZnJvbSAnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgcGFyc2VQcm90b2NvbCBmcm9tICcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IHNwZWVkb21ldGVyIGZyb20gJy4uL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMnO1xuXG5mdW5jdGlvbiBwcm9ncmVzc0V2ZW50UmVkdWNlcihsaXN0ZW5lciwgaXNEb3dubG9hZFN0cmVhbSkge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiBlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlXG4gICAgfTtcblxuICAgIGRhdGFbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ10gPSB0cnVlO1xuXG4gICAgbGlzdGVuZXIoZGF0YSk7XG4gIH07XG59XG5cbmNvbnN0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShjb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG4gICAgY29uc3QgcmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkgJiYgKHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyRW52IHx8IHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSkge1xuICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0Q29udGVudFR5cGUoZmFsc2UpOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIGNvbnN0IHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dCA/ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsIHx8IHRyYW5zaXRpb25hbERlZmF1bHRzO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHBsYXRmb3JtLmlzU3RhbmRhcmRCcm93c2VyRW52KSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIGNvbnN0IHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpXG4gICAgICAgICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKTtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVycy5zZXQoY29uZmlnLnhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihjb25maWcub25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IGh0dHBBZGFwdGVyIGZyb20gJy4vaHR0cC5qcyc7XG5pbXBvcnQgeGhyQWRhcHRlciBmcm9tICcuL3hoci5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tIFwiLi4vY29yZS9BeGlvc0Vycm9yLmpzXCI7XG5cbmNvbnN0IGtub3duQWRhcHRlcnMgPSB7XG4gIGh0dHA6IGh0dHBBZGFwdGVyLFxuICB4aHI6IHhockFkYXB0ZXJcbn1cblxudXRpbHMuZm9yRWFjaChrbm93bkFkYXB0ZXJzLCAoZm4sIHZhbHVlKSA9PiB7XG4gIGlmKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7dmFsdWV9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7dmFsdWV9KTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lT3JBZGFwdGVyID0gYWRhcHRlcnNbaV07XG4gICAgICBpZigoYWRhcHRlciA9IHV0aWxzLmlzU3RyaW5nKG5hbWVPckFkYXB0ZXIpID8ga25vd25BZGFwdGVyc1tuYW1lT3JBZGFwdGVyLnRvTG93ZXJDYXNlKCldIDogbmFtZU9yQWRhcHRlcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICBpZiAoYWRhcHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgICAgYEFkYXB0ZXIgJHtuYW1lT3JBZGFwdGVyfSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudGAsXG4gICAgICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB1dGlscy5oYXNPd25Qcm9wKGtub3duQWRhcHRlcnMsIG5hbWVPckFkYXB0ZXIpID9cbiAgICAgICAgICBgQWRhcHRlciAnJHtuYW1lT3JBZGFwdGVyfScgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGRgIDpcbiAgICAgICAgICBgVW5rbm93biBhZGFwdGVyICcke25hbWVPckFkYXB0ZXJ9J2BcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhZGFwdGVyIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0cmFuc2Zvcm1EYXRhIGZyb20gJy4vdHJhbnNmb3JtRGF0YS5qcyc7XG5pbXBvcnQgaXNDYW5jZWwgZnJvbSAnLi4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBhZGFwdGVycyBmcm9tIFwiLi4vYWRhcHRlcnMvYWRhcHRlcnMuanNcIjtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIGlmIChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10uaW5kZXhPZihjb25maWcubWV0aG9kKSAhPT0gLTEpIHtcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcik7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICByZXNwb25zZVxuICAgICk7XG5cbiAgICByZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB0aGluZy50b0pTT04oKSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlLmNhbGwoe2Nhc2VsZXNzfSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIGNhc2VsZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIGNhc2VsZXNzKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSwgY2FzZWxlc3MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKGEsIGIpIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMoYSwgYiwgcHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVyZ2VNYXAgPSB7XG4gICAgdXJsOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIG1ldGhvZDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBkYXRhOiB2YWx1ZUZyb21Db25maWcyLFxuICAgIGJhc2VVUkw6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBwYXJhbXNTZXJpYWxpemVyOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdGltZW91dE1lc3NhZ2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VUeXBlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZDb29raWVOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Q29udGVudExlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhCb2R5TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zcG9ydDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBjYW5jZWxUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBzb2NrZXRQYXRoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdmFsaWRhdGVTdGF0dXM6IG1lcmdlRGlyZWN0S2V5cyxcbiAgICBoZWFkZXJzOiAoYSwgYikgPT4gbWVyZ2VEZWVwUHJvcGVydGllcyhoZWFkZXJzVG9PYmplY3QoYSksIGhlYWRlcnNUb09iamVjdChiKSwgdHJ1ZSlcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKGNvbmZpZzEpLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBtZXJnZU1hcFtwcm9wXSB8fCBtZXJnZURlZXBQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNvbmZpZ1ZhbHVlID0gbWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSwgcHJvcCk7XG4gICAgKHV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZ1ZhbHVlKSAmJiBtZXJnZSAhPT0gbWVyZ2VEaXJlY3RLZXlzKSB8fCAoY29uZmlnW3Byb3BdID0gY29uZmlnVmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufVxuIiwiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuMy40XCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4uL2Vudi9kYXRhLmpzJztcbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG5jb25zdCBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb24gLSBkZXByZWNhdGVkIHZlcnNpb24gLyByZW1vdmVkIHNpbmNlIHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xudmFsaWRhdG9ycy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBjb25zdCBvcHQgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXJ0T3B0aW9ucyxcbiAgdmFsaWRhdG9yc1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IGJ1aWxkVVJMIGZyb20gJy4uL2hlbHBlcnMvYnVpbGRVUkwuanMnO1xuaW1wb3J0IEludGVyY2VwdG9yTWFuYWdlciBmcm9tICcuL0ludGVyY2VwdG9yTWFuYWdlci5qcyc7XG5pbXBvcnQgZGlzcGF0Y2hSZXF1ZXN0IGZyb20gJy4vZGlzcGF0Y2hSZXF1ZXN0LmpzJztcbmltcG9ydCBtZXJnZUNvbmZpZyBmcm9tICcuL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4vYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgdmFsaWRhdG9yIGZyb20gJy4uL2hlbHBlcnMvdmFsaWRhdG9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi9BeGlvc0hlYWRlcnMuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmNsYXNzIEF4aW9zIHtcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyhwYXJhbXNTZXJpYWxpemVyLCB7XG4gICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBjb250ZXh0SGVhZGVycztcblxuICAgIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICAgIGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBjb250ZXh0SGVhZGVycyAmJiB1dGlscy5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICBsZXQgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICAgIH0pO1xuXG4gICAgbGV0IHByb21pc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBsZW47XG5cbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LmJpbmQodGhpcyksIHVuZGVmaW5lZF07XG4gICAgICBjaGFpbi51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBjaGFpbi5wdXNoLmFwcGx5KGNoYWluLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBvbkZ1bGZpbGxlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBvblJlamVjdGVkLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdC5jYWxsKHRoaXMsIG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgbGVuID0gcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBnZXRVcmkoY29uZmlnKSB7XG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kLFxuICAgICAgdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSFRUUE1ldGhvZChpc0Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YVxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2QgKyAnRm9ybSddID0gZ2VuZXJhdGVIVFRQTWV0aG9kKHRydWUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn1cbiIsImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuaW1wb3J0IEF4aW9zIGZyb20gJy4vY29yZS9BeGlvcy5qcyc7XG5pbXBvcnQgbWVyZ2VDb25maWcgZnJvbSAnLi9jb3JlL21lcmdlQ29uZmlnLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBmb3JtRGF0YVRvSlNPTiBmcm9tICcuL2hlbHBlcnMvZm9ybURhdGFUb0pTT04uanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi9jYW5jZWwvQ2FuY2VsZWRFcnJvci5qcyc7XG5pbXBvcnQgQ2FuY2VsVG9rZW4gZnJvbSAnLi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMnO1xuaW1wb3J0IGlzQ2FuY2VsIGZyb20gJy4vY2FuY2VsL2lzQ2FuY2VsLmpzJztcbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgc3ByZWFkIGZyb20gJy4vaGVscGVycy9zcHJlYWQuanMnO1xuaW1wb3J0IGlzQXhpb3NFcnJvciBmcm9tICcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vY29yZS9BeGlvc0hlYWRlcnMuanNcIjtcbmltcG9ydCBIdHRwU3RhdHVzQ29kZSBmcm9tICcuL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCwgbnVsbCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG5jb25zdCBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSBDYW5jZWxlZEVycm9yO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5heGlvcy5WRVJTSU9OID0gVkVSU0lPTjtcbmF4aW9zLnRvRm9ybURhdGEgPSB0b0Zvcm1EYXRhO1xuXG4vLyBFeHBvc2UgQXhpb3NFcnJvciBjbGFzc1xuYXhpb3MuQXhpb3NFcnJvciA9IEF4aW9zRXJyb3I7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XG5cbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcblxuLy8gRXhwb3NlIG1lcmdlQ29uZmlnXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xuXG5heGlvcy5BeGlvc0hlYWRlcnMgPSBBeGlvc0hlYWRlcnM7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscy5pc0hUTUxGb3JtKHRoaW5nKSA/IG5ldyBGb3JtRGF0YSh0aGluZykgOiB0aGluZyk7XG5cbmF4aW9zLkh0dHBTdGF0dXNDb2RlID0gSHR0cFN0YXR1c0NvZGU7XG5cbmF4aW9zLmRlZmF1bHQgPSBheGlvcztcblxuLy8gdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0XG5leHBvcnQgZGVmYXVsdCBheGlvc1xuIl0sIm1hcHBpbmdzIjoiOzs7QUFFZSxTQUFTQSxJQUFJQSxDQUFDQyxFQUFFLEVBQUVDLE9BQU8sRUFBRTtFQUN4QyxPQUFPLFNBQVNDLElBQUlBLENBQUEsRUFBRztJQUNyQixPQUFPRixFQUFFLENBQUNHLEtBQUssQ0FBQ0YsT0FBTyxFQUFFRyxTQUFTLENBQUM7RUFDdkMsQ0FBRztBQUNIOztBQ0ZBOztBQUVBLE1BQU07RUFBQ0M7QUFBUSxDQUFDLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUztBQUNuQyxNQUFNO0VBQUNDO0FBQWMsQ0FBQyxHQUFHRixNQUFNO0FBRS9CLE1BQU1HLE1BQU0sR0FBRyxDQUFDQyxLQUFLLElBQUlDLEtBQUssSUFBSTtFQUM5QixNQUFNQyxHQUFHLEdBQUdQLFFBQVEsQ0FBQ1EsSUFBSSxDQUFDRixLQUFLLENBQUM7RUFDaEMsT0FBT0QsS0FBSyxDQUFDRSxHQUFHLENBQUMsS0FBS0YsS0FBSyxDQUFDRSxHQUFHLENBQUMsR0FBR0EsR0FBRyxDQUFDRSxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUNDLFdBQVcsRUFBRSxDQUFDO0FBQ3RFLENBQUMsRUFBRVQsTUFBTSxDQUFDVSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFdkIsTUFBTUMsVUFBVSxHQUFJQyxJQUFJLElBQUs7RUFDM0JBLElBQUksR0FBR0EsSUFBSSxDQUFDSCxXQUFXLEVBQUU7RUFDekIsT0FBUUosS0FBSyxJQUFLRixNQUFNLENBQUNFLEtBQUssQ0FBQyxLQUFLTyxJQUFJO0FBQzFDO0FBRUEsTUFBTUMsVUFBVSxHQUFHRCxJQUFJLElBQUlQLEtBQUssSUFBSSxPQUFPQSxLQUFLLEtBQUtPLElBQUk7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtFQUFDRTtBQUFPLENBQUMsR0FBR0MsS0FBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxXQUFXLEdBQUdILFVBQVUsQ0FBQyxXQUFXLENBQUM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0ksUUFBUUEsQ0FBQ0MsR0FBRyxFQUFFO0VBQ3JCLE9BQU9BLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDRSxHQUFHLENBQUMsSUFBSUEsR0FBRyxDQUFDQyxXQUFXLEtBQUssSUFBSSxJQUFJLENBQUNILFdBQVcsQ0FBQ0UsR0FBRyxDQUFDQyxXQUFXLENBQUMsSUFDaEdDLFVBQVUsQ0FBQ0YsR0FBRyxDQUFDQyxXQUFXLENBQUNGLFFBQVEsQ0FBQyxJQUFJQyxHQUFHLENBQUNDLFdBQVcsQ0FBQ0YsUUFBUSxDQUFDQyxHQUFHLENBQUM7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNRyxhQUFhLEdBQUdWLFVBQVUsQ0FBQyxhQUFhLENBQUM7O0FBRy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU1csaUJBQWlCQSxDQUFDSixHQUFHLEVBQUU7RUFDOUIsSUFBSUssTUFBTTtFQUNWLElBQUssT0FBT0MsV0FBVyxLQUFLLFdBQVcsSUFBTUEsV0FBVyxDQUFDQyxNQUFPLEVBQUU7SUFDaEVGLE1BQU0sR0FBR0MsV0FBVyxDQUFDQyxNQUFNLENBQUNQLEdBQUcsQ0FBQztFQUNwQyxDQUFHLE1BQU07SUFDTEssTUFBTSxHQUFJTCxHQUFHLElBQU1BLEdBQUcsQ0FBQ1EsTUFBTyxJQUFLTCxhQUFhLENBQUNILEdBQUcsQ0FBQ1EsTUFBTSxDQUFFO0VBQ2pFO0VBQ0UsT0FBT0gsTUFBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUksUUFBUSxHQUFHZCxVQUFVLENBQUMsUUFBUSxDQUFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNTyxVQUFVLEdBQUdQLFVBQVUsQ0FBQyxVQUFVLENBQUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWUsUUFBUSxHQUFHZixVQUFVLENBQUMsUUFBUSxDQUFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1nQixRQUFRLEdBQUl4QixLQUFLLElBQUtBLEtBQUssS0FBSyxJQUFJLElBQUksT0FBT0EsS0FBSyxLQUFLLFFBQVE7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU15QixTQUFTLEdBQUd6QixLQUFLLElBQUlBLEtBQUssS0FBSyxJQUFJLElBQUlBLEtBQUssS0FBSyxLQUFLOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0wQixhQUFhLEdBQUliLEdBQUcsSUFBSztFQUM3QixJQUFJZixNQUFNLENBQUNlLEdBQUcsQ0FBQyxLQUFLLFFBQVEsRUFBRTtJQUM1QixPQUFPLEtBQUs7RUFDaEI7RUFFRSxNQUFNakIsU0FBUyxHQUFHQyxjQUFjLENBQUNnQixHQUFHLENBQUM7RUFDckMsT0FBTyxDQUFDakIsU0FBUyxLQUFLLElBQUksSUFBSUEsU0FBUyxLQUFLRCxNQUFNLENBQUNDLFNBQVMsSUFBSUQsTUFBTSxDQUFDRSxjQUFjLENBQUNELFNBQVMsQ0FBQyxLQUFLLElBQUksS0FBSyxFQUFFK0IsTUFBTSxDQUFDQyxXQUFXLElBQUlmLEdBQUcsQ0FBQyxJQUFJLEVBQUVjLE1BQU0sQ0FBQ0UsUUFBUSxJQUFJaEIsR0FBRyxDQUFDO0FBQ3pLOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTWlCLE1BQU0sR0FBR3hCLFVBQVUsQ0FBQyxNQUFNLENBQUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTXlCLE1BQU0sR0FBR3pCLFVBQVUsQ0FBQyxNQUFNLENBQUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTBCLE1BQU0sR0FBRzFCLFVBQVUsQ0FBQyxNQUFNLENBQUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTJCLFVBQVUsR0FBRzNCLFVBQVUsQ0FBQyxVQUFVLENBQUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTRCLFFBQVEsR0FBSXJCLEdBQUcsSUFBS1csUUFBUSxDQUFDWCxHQUFHLENBQUMsSUFBSUUsVUFBVSxDQUFDRixHQUFHLENBQUNzQixJQUFJLENBQUM7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsVUFBVSxHQUFJcEMsS0FBSyxJQUFLO0VBQzVCLE1BQU1xQyxPQUFPLEdBQUcsbUJBQW1CO0VBQ25DLE9BQU9yQyxLQUFLLEtBQ1QsT0FBT3NDLFFBQVEsS0FBSyxVQUFVLElBQUl0QyxLQUFLLFlBQVlzQyxRQUFRLElBQzVENUMsUUFBUSxDQUFDUSxJQUFJLENBQUNGLEtBQUssQ0FBQyxLQUFLcUMsT0FBTyxJQUMvQnRCLFVBQVUsQ0FBQ2YsS0FBSyxDQUFDTixRQUFRLENBQUMsSUFBSU0sS0FBSyxDQUFDTixRQUFRLEVBQUUsS0FBSzJDLE9BQVEsQ0FDN0Q7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLGlCQUFpQixHQUFHakMsVUFBVSxDQUFDLGlCQUFpQixDQUFDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1rQyxJQUFJLEdBQUl2QyxHQUFHLElBQUtBLEdBQUcsQ0FBQ3VDLElBQUksR0FDNUJ2QyxHQUFHLENBQUN1QyxJQUFJLEVBQUUsR0FBR3ZDLEdBQUcsQ0FBQ3dDLE9BQU8sQ0FBQyxvQ0FBb0MsRUFBRSxFQUFFLENBQUM7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLE9BQU9BLENBQUNDLEdBQUcsRUFBRXRELEVBQUUsRUFBRTtFQUFDdUQsVUFBVSxHQUFHO0FBQUssQ0FBQyxHQUFHLEVBQUUsRUFBRTtFQUNyRDtFQUNFLElBQUlELEdBQUcsS0FBSyxJQUFJLElBQUksT0FBT0EsR0FBRyxLQUFLLFdBQVcsRUFBRTtJQUM5QztFQUNKO0VBRUUsSUFBSUUsQ0FBQztFQUNMLElBQUlDLENBQUM7O0VBRVA7RUFDRSxJQUFJLE9BQU9ILEdBQUcsS0FBSyxRQUFRLEVBQUU7SUFDL0I7SUFDSUEsR0FBRyxHQUFHLENBQUNBLEdBQUcsQ0FBQztFQUNmO0VBRUUsSUFBSWxDLE9BQU8sQ0FBQ2tDLEdBQUcsQ0FBQyxFQUFFO0lBQ3BCO0lBQ0ksS0FBS0UsQ0FBQyxHQUFHLENBQUMsRUFBRUMsQ0FBQyxHQUFHSCxHQUFHLENBQUNJLE1BQU0sRUFBRUYsQ0FBQyxHQUFHQyxDQUFDLEVBQUVELENBQUMsRUFBRSxFQUFFO01BQ3RDeEQsRUFBRSxDQUFDYSxJQUFJLENBQUMsSUFBSSxFQUFFeUMsR0FBRyxDQUFDRSxDQUFDLENBQUMsRUFBRUEsQ0FBQyxFQUFFRixHQUFHLENBQUM7SUFDbkM7RUFDQSxDQUFHLE1BQU07SUFDVDtJQUNJLE1BQU1LLElBQUksR0FBR0osVUFBVSxHQUFHakQsTUFBTSxDQUFDc0QsbUJBQW1CLENBQUNOLEdBQUcsQ0FBQyxHQUFHaEQsTUFBTSxDQUFDcUQsSUFBSSxDQUFDTCxHQUFHLENBQUM7SUFDNUUsTUFBTU8sR0FBRyxHQUFHRixJQUFJLENBQUNELE1BQU07SUFDdkIsSUFBSUksR0FBRztJQUVQLEtBQUtOLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0ssR0FBRyxFQUFFTCxDQUFDLEVBQUUsRUFBRTtNQUN4Qk0sR0FBRyxHQUFHSCxJQUFJLENBQUNILENBQUMsQ0FBQztNQUNieEQsRUFBRSxDQUFDYSxJQUFJLENBQUMsSUFBSSxFQUFFeUMsR0FBRyxDQUFDUSxHQUFHLENBQUMsRUFBRUEsR0FBRyxFQUFFUixHQUFHLENBQUM7SUFDdkM7RUFDQTtBQUNBO0FBRUEsU0FBU1MsT0FBT0EsQ0FBQ1QsR0FBRyxFQUFFUSxHQUFHLEVBQUU7RUFDekJBLEdBQUcsR0FBR0EsR0FBRyxDQUFDL0MsV0FBVyxFQUFFO0VBQ3ZCLE1BQU00QyxJQUFJLEdBQUdyRCxNQUFNLENBQUNxRCxJQUFJLENBQUNMLEdBQUcsQ0FBQztFQUM3QixJQUFJRSxDQUFDLEdBQUdHLElBQUksQ0FBQ0QsTUFBTTtFQUNuQixJQUFJTSxJQUFJO0VBQ1IsT0FBT1IsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO0lBQ2RRLElBQUksR0FBR0wsSUFBSSxDQUFDSCxDQUFDLENBQUM7SUFDZCxJQUFJTSxHQUFHLEtBQUtFLElBQUksQ0FBQ2pELFdBQVcsRUFBRSxFQUFFO01BQzlCLE9BQU9pRCxJQUFJO0lBQ2pCO0VBQ0E7RUFDRSxPQUFPLElBQUk7QUFDYjtBQUVBLE1BQU1DLE9BQU8sR0FBRyxDQUFDLE1BQU07RUFDdkI7RUFDRSxJQUFJLE9BQU9DLFVBQVUsS0FBSyxXQUFXLEVBQUUsT0FBT0EsVUFBVTtFQUN4RCxPQUFPLE9BQU9DLElBQUksS0FBSyxXQUFXLEdBQUdBLElBQUksR0FBSSxPQUFPQyxNQUFNLEtBQUssV0FBVyxHQUFHQSxNQUFNLEdBQUdDLE1BQU87QUFDL0YsQ0FBQyxHQUFHO0FBRUosTUFBTUMsZ0JBQWdCLEdBQUlDLE9BQU8sSUFBSyxDQUFDakQsV0FBVyxDQUFDaUQsT0FBTyxDQUFDLElBQUlBLE9BQU8sS0FBS04sT0FBTzs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU08sS0FBS0EsQ0FBQTtBQUFBLEVBQThCO0VBQzFDLE1BQU07SUFBQ0M7RUFBUSxDQUFDLEdBQUdILGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFO0VBQ3ZELE1BQU16QyxNQUFNLEdBQUcsRUFBRTtFQUNqQixNQUFNNkMsV0FBVyxHQUFHQSxDQUFDbEQsR0FBRyxFQUFFc0MsR0FBRyxLQUFLO0lBQ2hDLE1BQU1hLFNBQVMsR0FBR0YsUUFBUSxJQUFJVixPQUFPLENBQUNsQyxNQUFNLEVBQUVpQyxHQUFHLENBQUMsSUFBSUEsR0FBRztJQUN6RCxJQUFJekIsYUFBYSxDQUFDUixNQUFNLENBQUM4QyxTQUFTLENBQUMsQ0FBQyxJQUFJdEMsYUFBYSxDQUFDYixHQUFHLENBQUMsRUFBRTtNQUMxREssTUFBTSxDQUFDOEMsU0FBUyxDQUFDLEdBQUdILEtBQUssQ0FBQzNDLE1BQU0sQ0FBQzhDLFNBQVMsQ0FBQyxFQUFFbkQsR0FBRyxDQUFDO0lBQ3ZELENBQUssTUFBTSxJQUFJYSxhQUFhLENBQUNiLEdBQUcsQ0FBQyxFQUFFO01BQzdCSyxNQUFNLENBQUM4QyxTQUFTLENBQUMsR0FBR0gsS0FBSyxDQUFDLEVBQUUsRUFBRWhELEdBQUcsQ0FBQztJQUN4QyxDQUFLLE1BQU0sSUFBSUosT0FBTyxDQUFDSSxHQUFHLENBQUMsRUFBRTtNQUN2QkssTUFBTSxDQUFDOEMsU0FBUyxDQUFDLEdBQUduRCxHQUFHLENBQUNWLEtBQUssRUFBRTtJQUNyQyxDQUFLLE1BQU07TUFDTGUsTUFBTSxDQUFDOEMsU0FBUyxDQUFDLEdBQUduRCxHQUFHO0lBQzdCO0VBQ0E7RUFFRSxLQUFLLElBQUlnQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQyxDQUFDLEdBQUdyRCxTQUFTLENBQUNzRCxNQUFNLEVBQUVGLENBQUMsR0FBR0MsQ0FBQyxFQUFFRCxDQUFDLEVBQUUsRUFBRTtJQUNoRHBELFNBQVMsQ0FBQ29ELENBQUMsQ0FBQyxJQUFJSCxPQUFPLENBQUNqRCxTQUFTLENBQUNvRCxDQUFDLENBQUMsRUFBRWtCLFdBQVcsQ0FBQztFQUN0RDtFQUNFLE9BQU83QyxNQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNK0MsTUFBTSxHQUFHQSxDQUFDQyxDQUFDLEVBQUVDLENBQUMsRUFBRTdFLE9BQU8sRUFBRTtFQUFDc0Q7QUFBVSxDQUFDLEdBQUUsRUFBRSxLQUFLO0VBQ2xERixPQUFPLENBQUN5QixDQUFDLEVBQUUsQ0FBQ3RELEdBQUcsRUFBRXNDLEdBQUcsS0FBSztJQUN2QixJQUFJN0QsT0FBTyxJQUFJeUIsVUFBVSxDQUFDRixHQUFHLENBQUMsRUFBRTtNQUM5QnFELENBQUMsQ0FBQ2YsR0FBRyxDQUFDLEdBQUcvRCxJQUFJLENBQUN5QixHQUFHLEVBQUV2QixPQUFPLENBQUM7SUFDakMsQ0FBSyxNQUFNO01BQ0w0RSxDQUFDLENBQUNmLEdBQUcsQ0FBQyxHQUFHdEMsR0FBRztJQUNsQjtFQUNBLENBQUcsRUFBRTtJQUFDK0I7RUFBVSxDQUFDLENBQUM7RUFDaEIsT0FBT3NCLENBQUM7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLFFBQVEsR0FBSUMsT0FBTyxJQUFLO0VBQzVCLElBQUlBLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLENBQUMsQ0FBQyxLQUFLLE1BQU0sRUFBRTtJQUNwQ0QsT0FBTyxHQUFHQSxPQUFPLENBQUNsRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzlCO0VBQ0UsT0FBT2tFLE9BQU87QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsUUFBUSxHQUFHQSxDQUFDekQsV0FBVyxFQUFFMEQsZ0JBQWdCLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxLQUFLO0VBQ3RFNUQsV0FBVyxDQUFDbEIsU0FBUyxHQUFHRCxNQUFNLENBQUNVLE1BQU0sQ0FBQ21FLGdCQUFnQixDQUFDNUUsU0FBUyxFQUFFOEUsV0FBVyxDQUFDO0VBQzlFNUQsV0FBVyxDQUFDbEIsU0FBUyxDQUFDa0IsV0FBVyxHQUFHQSxXQUFXO0VBQy9DbkIsTUFBTSxDQUFDZ0YsY0FBYyxDQUFDN0QsV0FBVyxFQUFFLE9BQU8sRUFBRTtJQUMxQzhELEtBQUssRUFBRUosZ0JBQWdCLENBQUM1RTtFQUM1QixDQUFHLENBQUM7RUFDRjZFLEtBQUssSUFBSTlFLE1BQU0sQ0FBQ2tGLE1BQU0sQ0FBQy9ELFdBQVcsQ0FBQ2xCLFNBQVMsRUFBRTZFLEtBQUssQ0FBQztBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNSyxZQUFZLEdBQUdBLENBQUNDLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsS0FBSztFQUMvRCxJQUFJVCxLQUFLO0VBQ1QsSUFBSTVCLENBQUM7RUFDTCxJQUFJc0MsSUFBSTtFQUNSLE1BQU1DLE1BQU0sR0FBRyxFQUFFO0VBRWpCSixPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFFO0VBQ3pCO0VBQ0UsSUFBSUQsU0FBUyxJQUFJLElBQUksRUFBRSxPQUFPQyxPQUFPO0VBRXJDLEdBQUc7SUFDRFAsS0FBSyxHQUFHOUUsTUFBTSxDQUFDc0QsbUJBQW1CLENBQUM4QixTQUFTLENBQUM7SUFDN0NsQyxDQUFDLEdBQUc0QixLQUFLLENBQUMxQixNQUFNO0lBQ2hCLE9BQU9GLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtNQUNkc0MsSUFBSSxHQUFHVixLQUFLLENBQUM1QixDQUFDLENBQUM7TUFDZixJQUFJLENBQUMsQ0FBQ3FDLFVBQVUsSUFBSUEsVUFBVSxDQUFDQyxJQUFJLEVBQUVKLFNBQVMsRUFBRUMsT0FBTyxDQUFDLEtBQUssQ0FBQ0ksTUFBTSxDQUFDRCxJQUFJLENBQUMsRUFBRTtRQUMxRUgsT0FBTyxDQUFDRyxJQUFJLENBQUMsR0FBR0osU0FBUyxDQUFDSSxJQUFJLENBQUM7UUFDL0JDLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLEdBQUcsSUFBSTtNQUMzQjtJQUNBO0lBQ0lKLFNBQVMsR0FBR0UsTUFBTSxLQUFLLEtBQUssSUFBSXBGLGNBQWMsQ0FBQ2tGLFNBQVMsQ0FBQztFQUM3RCxDQUFHLFFBQVFBLFNBQVMsS0FBSyxDQUFDRSxNQUFNLElBQUlBLE1BQU0sQ0FBQ0YsU0FBUyxFQUFFQyxPQUFPLENBQUMsQ0FBQyxJQUFJRCxTQUFTLEtBQUtwRixNQUFNLENBQUNDLFNBQVM7RUFFL0YsT0FBT29GLE9BQU87QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUssUUFBUSxHQUFHQSxDQUFDcEYsR0FBRyxFQUFFcUYsWUFBWSxFQUFFQyxRQUFRLEtBQUs7RUFDaER0RixHQUFHLEdBQUd1RixNQUFNLENBQUN2RixHQUFHLENBQUM7RUFDakIsSUFBSXNGLFFBQVEsS0FBS0UsU0FBUyxJQUFJRixRQUFRLEdBQUd0RixHQUFHLENBQUM4QyxNQUFNLEVBQUU7SUFDbkR3QyxRQUFRLEdBQUd0RixHQUFHLENBQUM4QyxNQUFNO0VBQ3pCO0VBQ0V3QyxRQUFRLElBQUlELFlBQVksQ0FBQ3ZDLE1BQU07RUFDL0IsTUFBTTJDLFNBQVMsR0FBR3pGLEdBQUcsQ0FBQzBGLE9BQU8sQ0FBQ0wsWUFBWSxFQUFFQyxRQUFRLENBQUM7RUFDckQsT0FBT0csU0FBUyxLQUFLLENBQUMsQ0FBQyxJQUFJQSxTQUFTLEtBQUtILFFBQVE7QUFDbkQ7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNSyxPQUFPLEdBQUk1RixLQUFLLElBQUs7RUFDekIsSUFBSSxDQUFDQSxLQUFLLEVBQUUsT0FBTyxJQUFJO0VBQ3ZCLElBQUlTLE9BQU8sQ0FBQ1QsS0FBSyxDQUFDLEVBQUUsT0FBT0EsS0FBSztFQUNoQyxJQUFJNkMsQ0FBQyxHQUFHN0MsS0FBSyxDQUFDK0MsTUFBTTtFQUNwQixJQUFJLENBQUN4QixRQUFRLENBQUNzQixDQUFDLENBQUMsRUFBRSxPQUFPLElBQUk7RUFDN0IsTUFBTWdELEdBQUcsR0FBRyxJQUFJbkYsS0FBSyxDQUFDbUMsQ0FBQyxDQUFDO0VBQ3hCLE9BQU9BLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtJQUNkZ0QsR0FBRyxDQUFDaEQsQ0FBQyxDQUFDLEdBQUc3QyxLQUFLLENBQUM2QyxDQUFDLENBQUM7RUFDckI7RUFDRSxPQUFPZ0QsR0FBRztBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFlBQVksR0FBRyxDQUFDQyxVQUFVLElBQUk7RUFDcEM7RUFDRSxPQUFPL0YsS0FBSyxJQUFJO0lBQ2QsT0FBTytGLFVBQVUsSUFBSS9GLEtBQUssWUFBWStGLFVBQVU7RUFDcEQsQ0FBRztBQUNILENBQUMsRUFBRSxPQUFPQyxVQUFVLEtBQUssV0FBVyxJQUFJbkcsY0FBYyxDQUFDbUcsVUFBVSxDQUFDLENBQUM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxZQUFZLEdBQUdBLENBQUN0RCxHQUFHLEVBQUV0RCxFQUFFLEtBQUs7RUFDaEMsTUFBTTZHLFNBQVMsR0FBR3ZELEdBQUcsSUFBSUEsR0FBRyxDQUFDaEIsTUFBTSxDQUFDRSxRQUFRLENBQUM7RUFFN0MsTUFBTUEsUUFBUSxHQUFHcUUsU0FBUyxDQUFDaEcsSUFBSSxDQUFDeUMsR0FBRyxDQUFDO0VBRXBDLElBQUl6QixNQUFNO0VBRVYsT0FBTyxDQUFDQSxNQUFNLEdBQUdXLFFBQVEsQ0FBQ3NFLElBQUksRUFBRSxLQUFLLENBQUNqRixNQUFNLENBQUNrRixJQUFJLEVBQUU7SUFDakQsTUFBTUMsSUFBSSxHQUFHbkYsTUFBTSxDQUFDMEQsS0FBSztJQUN6QnZGLEVBQUUsQ0FBQ2EsSUFBSSxDQUFDeUMsR0FBRyxFQUFFMEQsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFQSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsUUFBUSxHQUFHQSxDQUFDQyxNQUFNLEVBQUV0RyxHQUFHLEtBQUs7RUFDaEMsSUFBSXVHLE9BQU87RUFDWCxNQUFNWCxHQUFHLEdBQUcsRUFBRTtFQUVkLE9BQU8sQ0FBQ1csT0FBTyxHQUFHRCxNQUFNLENBQUNFLElBQUksQ0FBQ3hHLEdBQUcsQ0FBQyxNQUFNLElBQUksRUFBRTtJQUM1QzRGLEdBQUcsQ0FBQ2EsSUFBSSxDQUFDRixPQUFPLENBQUM7RUFDckI7RUFFRSxPQUFPWCxHQUFHO0FBQ1o7O0FBRUE7QUFDQSxNQUFNYyxVQUFVLEdBQUdyRyxVQUFVLENBQUMsaUJBQWlCLENBQUM7QUFFaEQsTUFBTXNHLFdBQVcsR0FBRzNHLEdBQUcsSUFBSTtFQUN6QixPQUFPQSxHQUFHLENBQUNHLFdBQVcsRUFBRSxDQUFDcUMsT0FBTyxDQUFDLHVCQUF1QixFQUN0RCxTQUFTb0UsUUFBUUEsQ0FBQ0MsQ0FBQyxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUMzQixPQUFPRCxFQUFFLENBQUNFLFdBQVcsRUFBRSxHQUFHRCxFQUFFO0VBQ2xDLENBQUssQ0FDRjtBQUNILENBQUM7O0FBRUQ7QUFDQSxNQUFNRSxjQUFjLEdBQUcsQ0FBQyxDQUFDO0VBQUNBO0FBQWMsQ0FBQyxLQUFLLENBQUN2RSxHQUFHLEVBQUV3QyxJQUFJLEtBQUsrQixjQUFjLENBQUNoSCxJQUFJLENBQUN5QyxHQUFHLEVBQUV3QyxJQUFJLENBQUMsRUFBRXhGLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDOztBQUU5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU11SCxRQUFRLEdBQUc3RyxVQUFVLENBQUMsUUFBUSxDQUFDO0FBRXJDLE1BQU04RyxpQkFBaUIsR0FBR0EsQ0FBQ3pFLEdBQUcsRUFBRTBFLE9BQU8sS0FBSztFQUMxQyxNQUFNM0MsV0FBVyxHQUFHL0UsTUFBTSxDQUFDMkgseUJBQXlCLENBQUMzRSxHQUFHLENBQUM7RUFDekQsTUFBTTRFLGtCQUFrQixHQUFHLEVBQUU7RUFFN0I3RSxPQUFPLENBQUNnQyxXQUFXLEVBQUUsQ0FBQzhDLFVBQVUsRUFBRUMsSUFBSSxLQUFLO0lBQ3pDLElBQUlKLE9BQU8sQ0FBQ0csVUFBVSxFQUFFQyxJQUFJLEVBQUU5RSxHQUFHLENBQUMsS0FBSyxLQUFLLEVBQUU7TUFDNUM0RSxrQkFBa0IsQ0FBQ0UsSUFBSSxDQUFDLEdBQUdELFVBQVU7SUFDM0M7RUFDQSxDQUFHLENBQUM7RUFFRjdILE1BQU0sQ0FBQytILGdCQUFnQixDQUFDL0UsR0FBRyxFQUFFNEUsa0JBQWtCLENBQUM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUksYUFBYSxHQUFJaEYsR0FBRyxJQUFLO0VBQzdCeUUsaUJBQWlCLENBQUN6RSxHQUFHLEVBQUUsQ0FBQzZFLFVBQVUsRUFBRUMsSUFBSSxLQUFLO0lBQy9DO0lBQ0ksSUFBSTFHLFVBQVUsQ0FBQzRCLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQ2dELE9BQU8sQ0FBQzhCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO01BQzdFLE9BQU8sS0FBSztJQUNsQjtJQUVJLE1BQU03QyxLQUFLLEdBQUdqQyxHQUFHLENBQUM4RSxJQUFJLENBQUM7SUFFdkIsSUFBSSxDQUFDMUcsVUFBVSxDQUFDNkQsS0FBSyxDQUFDLEVBQUU7SUFFeEI0QyxVQUFVLENBQUNJLFVBQVUsR0FBRyxLQUFLO0lBRTdCLElBQUksVUFBVSxJQUFJSixVQUFVLEVBQUU7TUFDNUJBLFVBQVUsQ0FBQ0ssUUFBUSxHQUFHLEtBQUs7TUFDM0I7SUFDTjtJQUVJLElBQUksQ0FBQ0wsVUFBVSxDQUFDTSxHQUFHLEVBQUU7TUFDbkJOLFVBQVUsQ0FBQ00sR0FBRyxHQUFHLE1BQU07UUFDckIsTUFBTUMsS0FBSyxDQUFDLHFDQUFxQyxHQUFHTixJQUFJLEdBQUcsSUFBSSxDQUFDO01BQ3hFLENBQU87SUFDUDtFQUNBLENBQUcsQ0FBQztBQUNKO0FBRUEsTUFBTU8sV0FBVyxHQUFHQSxDQUFDQyxhQUFhLEVBQUVDLFNBQVMsS0FBSztFQUNoRCxNQUFNdkYsR0FBRyxHQUFHLEVBQUU7RUFFZCxNQUFNd0YsTUFBTSxHQUFJdEMsR0FBRyxJQUFLO0lBQ3RCQSxHQUFHLENBQUNuRCxPQUFPLENBQUNrQyxLQUFLLElBQUk7TUFDbkJqQyxHQUFHLENBQUNpQyxLQUFLLENBQUMsR0FBRyxJQUFJO0lBQ3ZCLENBQUssQ0FBQztFQUNOO0VBRUVuRSxPQUFPLENBQUN3SCxhQUFhLENBQUMsR0FBR0UsTUFBTSxDQUFDRixhQUFhLENBQUMsR0FBR0UsTUFBTSxDQUFDM0MsTUFBTSxDQUFDeUMsYUFBYSxDQUFDLENBQUNHLEtBQUssQ0FBQ0YsU0FBUyxDQUFDLENBQUM7RUFFL0YsT0FBT3ZGLEdBQUc7QUFDWjtBQUVBLE1BQU0wRixJQUFJLEdBQUdBLENBQUEsS0FBTTtBQUVuQixNQUFNQyxjQUFjLEdBQUdBLENBQUMxRCxLQUFLLEVBQUUyRCxZQUFZLEtBQUs7RUFDOUMzRCxLQUFLLEdBQUcsQ0FBQ0EsS0FBSztFQUNkLE9BQU80RCxNQUFNLENBQUNDLFFBQVEsQ0FBQzdELEtBQUssQ0FBQyxHQUFHQSxLQUFLLEdBQUcyRCxZQUFZO0FBQ3REO0FBRUEsTUFBTUcsS0FBSyxHQUFHO0FBRWQsTUFBTUMsS0FBSyxHQUFHLFlBQVk7QUFFMUIsTUFBTUMsUUFBUSxHQUFHO0VBQ2ZELEtBQUs7RUFDTEQsS0FBSztFQUNMRyxXQUFXLEVBQUVILEtBQUssR0FBR0EsS0FBSyxDQUFDekIsV0FBVyxFQUFFLEdBQUcwQjtBQUM3QztBQUVBLE1BQU1HLGNBQWMsR0FBR0EsQ0FBQ0MsSUFBSSxHQUFHLEVBQUUsRUFBRUMsUUFBUSxHQUFHSixRQUFRLENBQUNDLFdBQVcsS0FBSztFQUNyRSxJQUFJNUksR0FBRyxHQUFHLEVBQUU7RUFDWixNQUFNO0lBQUM4QztFQUFNLENBQUMsR0FBR2lHLFFBQVE7RUFDekIsT0FBT0QsSUFBSSxFQUFFLEVBQUU7SUFDYjlJLEdBQUcsSUFBSStJLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUUsR0FBR25HLE1BQU0sR0FBQyxDQUFDO0VBQzVDO0VBRUUsT0FBTzlDLEdBQUc7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNrSixtQkFBbUJBLENBQUNuSixLQUFLLEVBQUU7RUFDbEMsT0FBTyxDQUFDLEVBQUVBLEtBQUssSUFBSWUsVUFBVSxDQUFDZixLQUFLLENBQUNvSixNQUFNLENBQUMsSUFBSXBKLEtBQUssQ0FBQzJCLE1BQU0sQ0FBQ0MsV0FBVyxDQUFDLEtBQUssVUFBVSxJQUFJNUIsS0FBSyxDQUFDMkIsTUFBTSxDQUFDRSxRQUFRLENBQUMsQ0FBQztBQUNwSDtBQUVBLE1BQU13SCxZQUFZLEdBQUkxRyxHQUFHLElBQUs7RUFDNUIsTUFBTTJHLEtBQUssR0FBRyxJQUFJNUksS0FBSyxDQUFDLEVBQUUsQ0FBQztFQUUzQixNQUFNNkksS0FBSyxHQUFHQSxDQUFDQyxNQUFNLEVBQUUzRyxDQUFDLEtBQUs7SUFFM0IsSUFBSXJCLFFBQVEsQ0FBQ2dJLE1BQU0sQ0FBQyxFQUFFO01BQ3BCLElBQUlGLEtBQUssQ0FBQzNELE9BQU8sQ0FBQzZELE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUM5QjtNQUNSO01BRU0sSUFBRyxFQUFFLFFBQVEsSUFBSUEsTUFBTSxDQUFDLEVBQUU7UUFDeEJGLEtBQUssQ0FBQ3pHLENBQUMsQ0FBQyxHQUFHMkcsTUFBTTtRQUNqQixNQUFNQyxNQUFNLEdBQUdoSixPQUFPLENBQUMrSSxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRTtRQUV4QzlHLE9BQU8sQ0FBQzhHLE1BQU0sRUFBRSxDQUFDNUUsS0FBSyxFQUFFekIsR0FBRyxLQUFLO1VBQzlCLE1BQU11RyxZQUFZLEdBQUdILEtBQUssQ0FBQzNFLEtBQUssRUFBRS9CLENBQUMsR0FBRyxDQUFDLENBQUM7VUFDeEMsQ0FBQ2xDLFdBQVcsQ0FBQytJLFlBQVksQ0FBQyxLQUFLRCxNQUFNLENBQUN0RyxHQUFHLENBQUMsR0FBR3VHLFlBQVksQ0FBQztRQUNwRSxDQUFTLENBQUM7UUFFRkosS0FBSyxDQUFDekcsQ0FBQyxDQUFDLEdBQUc0QyxTQUFTO1FBRXBCLE9BQU9nRSxNQUFNO01BQ3JCO0lBQ0E7SUFFSSxPQUFPRCxNQUFNO0VBQ2pCO0VBRUUsT0FBT0QsS0FBSyxDQUFDNUcsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUN0QjtBQUVBLElBQUFnSCxLQUFBLEdBQWU7RUFDYmxKLE9BQU87RUFDUE8sYUFBYTtFQUNiSixRQUFRO0VBQ1J3QixVQUFVO0VBQ1ZuQixpQkFBaUI7RUFDakJLLFFBQVE7RUFDUkMsUUFBUTtFQUNSRSxTQUFTO0VBQ1RELFFBQVE7RUFDUkUsYUFBYTtFQUNiZixXQUFXO0VBQ1htQixNQUFNO0VBQ05DLE1BQU07RUFDTkMsTUFBTTtFQUNObUYsUUFBUTtFQUNScEcsVUFBVTtFQUNWbUIsUUFBUTtFQUNSSyxpQkFBaUI7RUFDakJ1RCxZQUFZO0VBQ1o3RCxVQUFVO0VBQ1ZTLE9BQU87RUFDUG1CLEtBQUs7RUFDTEksTUFBTTtFQUNOekIsSUFBSTtFQUNKNEIsUUFBUTtFQUNSRyxRQUFRO0VBQ1JPLFlBQVk7RUFDWmhGLE1BQU07RUFDTlEsVUFBVTtFQUNWK0UsUUFBUTtFQUNSTyxPQUFPO0VBQ1BLLFlBQVk7RUFDWkssUUFBUTtFQUNSSyxVQUFVO0VBQ1ZPLGNBQWM7RUFDZDBDLFVBQVUsRUFBRTFDLGNBQWM7RUFBQTtFQUMxQkUsaUJBQWlCO0VBQ2pCTyxhQUFhO0VBQ2JLLFdBQVc7RUFDWHBCLFdBQVc7RUFDWHlCLElBQUk7RUFDSkMsY0FBYztFQUNkbEYsT0FBTztFQUNQTSxNQUFNLEVBQUVKLE9BQU87RUFDZkssZ0JBQWdCO0VBQ2hCaUYsUUFBUTtFQUNSRSxjQUFjO0VBQ2RLLG1CQUFtQjtFQUNuQkU7QUFDRixDQUFDOztBQ2xzQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNRLFVBQVVBLENBQUNDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFO0VBQzVEbkMsS0FBSyxDQUFDN0gsSUFBSSxDQUFDLElBQUksQ0FBQztFQUVoQixJQUFJNkgsS0FBSyxDQUFDb0MsaUJBQWlCLEVBQUU7SUFDM0JwQyxLQUFLLENBQUNvQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDckosV0FBVyxDQUFDO0VBQ25ELENBQUcsTUFBTTtJQUNMLElBQUksQ0FBQ3dJLEtBQUssR0FBSSxJQUFJdkIsS0FBSyxFQUFFLENBQUV1QixLQUFLO0VBQ3BDO0VBRUUsSUFBSSxDQUFDUSxPQUFPLEdBQUdBLE9BQU87RUFDdEIsSUFBSSxDQUFDckMsSUFBSSxHQUFHLFlBQVk7RUFDeEJzQyxJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJLEdBQUdBLElBQUksQ0FBQztFQUMxQkMsTUFBTSxLQUFLLElBQUksQ0FBQ0EsTUFBTSxHQUFHQSxNQUFNLENBQUM7RUFDaENDLE9BQU8sS0FBSyxJQUFJLENBQUNBLE9BQU8sR0FBR0EsT0FBTyxDQUFDO0VBQ25DQyxRQUFRLEtBQUssSUFBSSxDQUFDQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQztBQUN4QztBQUVBUCxLQUFLLENBQUNwRixRQUFRLENBQUNzRixVQUFVLEVBQUU5QixLQUFLLEVBQUU7RUFDaENxQyxNQUFNLEVBQUUsU0FBU0EsTUFBTUEsQ0FBQSxFQUFHO0lBQ3hCLE9BQU87TUFDWDtNQUNNTixPQUFPLEVBQUUsSUFBSSxDQUFDQSxPQUFPO01BQ3JCckMsSUFBSSxFQUFFLElBQUksQ0FBQ0EsSUFBSTtNQUNyQjtNQUNNNEMsV0FBVyxFQUFFLElBQUksQ0FBQ0EsV0FBVztNQUM3QkMsTUFBTSxFQUFFLElBQUksQ0FBQ0EsTUFBTTtNQUN6QjtNQUNNQyxRQUFRLEVBQUUsSUFBSSxDQUFDQSxRQUFRO01BQ3ZCQyxVQUFVLEVBQUUsSUFBSSxDQUFDQSxVQUFVO01BQzNCQyxZQUFZLEVBQUUsSUFBSSxDQUFDQSxZQUFZO01BQy9CbkIsS0FBSyxFQUFFLElBQUksQ0FBQ0EsS0FBSztNQUN2QjtNQUNNVSxNQUFNLEVBQUVMLEtBQUssQ0FBQ04sWUFBWSxDQUFDLElBQUksQ0FBQ1csTUFBTSxDQUFDO01BQ3ZDRCxJQUFJLEVBQUUsSUFBSSxDQUFDQSxJQUFJO01BQ2ZXLE1BQU0sRUFBRSxJQUFJLENBQUNSLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsQ0FBQ1EsTUFBTSxHQUFHLElBQUksQ0FBQ1IsUUFBUSxDQUFDUSxNQUFNLEdBQUc7SUFDN0UsQ0FBSztFQUNMO0FBQ0EsQ0FBQyxDQUFDO0FBRUYsTUFBTUMsV0FBUyxHQUFHZCxVQUFVLENBQUNqSyxTQUFTO0FBQ3RDLE1BQU04RSxXQUFXLEdBQUcsRUFBRTtBQUV0QixDQUNFLHNCQUFzQixFQUN0QixnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLFdBQVcsRUFDWCxhQUFhLEVBQ2IsMkJBQTJCLEVBQzNCLGdCQUFnQixFQUNoQixrQkFBa0IsRUFDbEIsaUJBQWlCLEVBQ2pCLGNBQWMsRUFDZCxpQkFBaUIsRUFDakI7QUFDRjtBQUFBLENBQ0MsQ0FBQ2hDLE9BQU8sQ0FBQ3FILElBQUksSUFBSTtFQUNoQnJGLFdBQVcsQ0FBQ3FGLElBQUksQ0FBQyxHQUFHO0lBQUNuRixLQUFLLEVBQUVtRjtFQUFJLENBQUM7QUFDbkMsQ0FBQyxDQUFDO0FBRUZwSyxNQUFNLENBQUMrSCxnQkFBZ0IsQ0FBQ21DLFVBQVUsRUFBRW5GLFdBQVcsQ0FBQztBQUNoRC9FLE1BQU0sQ0FBQ2dGLGNBQWMsQ0FBQ2dHLFdBQVMsRUFBRSxjQUFjLEVBQUU7RUFBQy9GLEtBQUssRUFBRTtBQUFJLENBQUMsQ0FBQzs7QUFFL0Q7QUFDQWlGLFVBQVUsQ0FBQ2UsSUFBSSxHQUFHLENBQUNDLEtBQUssRUFBRWQsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFWSxXQUFXLEtBQUs7RUFDekUsTUFBTUMsVUFBVSxHQUFHcEwsTUFBTSxDQUFDVSxNQUFNLENBQUNzSyxXQUFTLENBQUM7RUFFM0NoQixLQUFLLENBQUM3RSxZQUFZLENBQUMrRixLQUFLLEVBQUVFLFVBQVUsRUFBRSxTQUFTOUYsTUFBTUEsQ0FBQ3RDLEdBQUcsRUFBRTtJQUN6RCxPQUFPQSxHQUFHLEtBQUtvRixLQUFLLENBQUNuSSxTQUFTO0VBQ2xDLENBQUcsRUFBRXVGLElBQUksSUFBSTtJQUNULE9BQU9BLElBQUksS0FBSyxjQUFjO0VBQ2xDLENBQUcsQ0FBQztFQUVGMEUsVUFBVSxDQUFDM0osSUFBSSxDQUFDNkssVUFBVSxFQUFFRixLQUFLLENBQUNmLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxDQUFDO0VBRTNFYSxVQUFVLENBQUNDLEtBQUssR0FBR0gsS0FBSztFQUV4QkUsVUFBVSxDQUFDdEQsSUFBSSxHQUFHb0QsS0FBSyxDQUFDcEQsSUFBSTtFQUU1QnFELFdBQVcsSUFBSW5MLE1BQU0sQ0FBQ2tGLE1BQU0sQ0FBQ2tHLFVBQVUsRUFBRUQsV0FBVyxDQUFDO0VBRXJELE9BQU9DLFVBQVU7QUFDbkIsQ0FBQzs7QUNqR0Q7QUFDQSxJQUFBRSxXQUFBLEdBQWUsSUFBSTs7QUNNbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxXQUFXQSxDQUFDbEwsS0FBSyxFQUFFO0VBQzFCLE9BQU8ySixLQUFLLENBQUNqSSxhQUFhLENBQUMxQixLQUFLLENBQUMsSUFBSTJKLEtBQUssQ0FBQ2xKLE9BQU8sQ0FBQ1QsS0FBSyxDQUFDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU21MLGNBQWNBLENBQUNoSSxHQUFHLEVBQUU7RUFDM0IsT0FBT3dHLEtBQUssQ0FBQ3RFLFFBQVEsQ0FBQ2xDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBR0EsR0FBRyxDQUFDaEQsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHZ0QsR0FBRztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaUksU0FBU0EsQ0FBQ0MsSUFBSSxFQUFFbEksR0FBRyxFQUFFbUksSUFBSSxFQUFFO0VBQ2xDLElBQUksQ0FBQ0QsSUFBSSxFQUFFLE9BQU9sSSxHQUFHO0VBQ3JCLE9BQU9rSSxJQUFJLENBQUNFLE1BQU0sQ0FBQ3BJLEdBQUcsQ0FBQyxDQUFDcUksR0FBRyxDQUFDLFNBQVNDLElBQUlBLENBQUNDLEtBQUssRUFBRTdJLENBQUMsRUFBRTtJQUN0RDtJQUNJNkksS0FBSyxHQUFHUCxjQUFjLENBQUNPLEtBQUssQ0FBQztJQUM3QixPQUFPLENBQUNKLElBQUksSUFBSXpJLENBQUMsR0FBRyxHQUFHLEdBQUc2SSxLQUFLLEdBQUcsR0FBRyxHQUFHQSxLQUFLO0VBQ2pELENBQUcsQ0FBQyxDQUFDQyxJQUFJLENBQUNMLElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU00sV0FBV0EsQ0FBQy9GLEdBQUcsRUFBRTtFQUN4QixPQUFPOEQsS0FBSyxDQUFDbEosT0FBTyxDQUFDb0YsR0FBRyxDQUFDLElBQUksQ0FBQ0EsR0FBRyxDQUFDZ0csSUFBSSxDQUFDWCxXQUFXLENBQUM7QUFDckQ7QUFFQSxNQUFNWSxVQUFVLEdBQUduQyxLQUFLLENBQUM3RSxZQUFZLENBQUM2RSxLQUFLLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTMUUsTUFBTUEsQ0FBQ0UsSUFBSSxFQUFFO0VBQzNFLE9BQU8sVUFBVSxDQUFDNEcsSUFBSSxDQUFDNUcsSUFBSSxDQUFDO0FBQzlCLENBQUMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTNkcsVUFBVUEsQ0FBQ3JKLEdBQUcsRUFBRXNKLFFBQVEsRUFBRUMsT0FBTyxFQUFFO0VBQzFDLElBQUksQ0FBQ3ZDLEtBQUssQ0FBQ25JLFFBQVEsQ0FBQ21CLEdBQUcsQ0FBQyxFQUFFO0lBQ3hCLE1BQU0sSUFBSXdKLFNBQVMsQ0FBQywwQkFBMEIsQ0FBQztFQUNuRDs7RUFFQTtFQUNFRixRQUFRLEdBQUdBLFFBQVEsSUFBSSxJQUF5QjNKLFFBQVEsRUFBRzs7RUFFN0Q7RUFDRTRKLE9BQU8sR0FBR3ZDLEtBQUssQ0FBQzdFLFlBQVksQ0FBQ29ILE9BQU8sRUFBRTtJQUNwQ0UsVUFBVSxFQUFFLElBQUk7SUFDaEJkLElBQUksRUFBRSxLQUFLO0lBQ1hlLE9BQU8sRUFBRTtFQUNiLENBQUcsRUFBRSxLQUFLLEVBQUUsU0FBU0MsT0FBT0EsQ0FBQ0MsTUFBTSxFQUFFL0MsTUFBTSxFQUFFO0lBQzdDO0lBQ0ksT0FBTyxDQUFDRyxLQUFLLENBQUNoSixXQUFXLENBQUM2SSxNQUFNLENBQUMrQyxNQUFNLENBQUMsQ0FBQztFQUM3QyxDQUFHLENBQUM7RUFFRixNQUFNSCxVQUFVLEdBQUdGLE9BQU8sQ0FBQ0UsVUFBVTtFQUN2QztFQUNFLE1BQU1JLE9BQU8sR0FBR04sT0FBTyxDQUFDTSxPQUFPLElBQUlDLGNBQWM7RUFDakQsTUFBTW5CLElBQUksR0FBR1ksT0FBTyxDQUFDWixJQUFJO0VBQ3pCLE1BQU1lLE9BQU8sR0FBR0gsT0FBTyxDQUFDRyxPQUFPO0VBQy9CLE1BQU1LLEtBQUssR0FBR1IsT0FBTyxDQUFDUyxJQUFJLElBQUksT0FBT0EsSUFBSSxLQUFLLFdBQVcsSUFBSUEsSUFBSTtFQUNqRSxNQUFNQyxPQUFPLEdBQUdGLEtBQUssSUFBSS9DLEtBQUssQ0FBQ1IsbUJBQW1CLENBQUM4QyxRQUFRLENBQUM7RUFFNUQsSUFBSSxDQUFDdEMsS0FBSyxDQUFDNUksVUFBVSxDQUFDeUwsT0FBTyxDQUFDLEVBQUU7SUFDOUIsTUFBTSxJQUFJTCxTQUFTLENBQUMsNEJBQTRCLENBQUM7RUFDckQ7RUFFRSxTQUFTVSxZQUFZQSxDQUFDakksS0FBSyxFQUFFO0lBQzNCLElBQUlBLEtBQUssS0FBSyxJQUFJLEVBQUUsT0FBTyxFQUFFO0lBRTdCLElBQUkrRSxLQUFLLENBQUM3SCxNQUFNLENBQUM4QyxLQUFLLENBQUMsRUFBRTtNQUN2QixPQUFPQSxLQUFLLENBQUNrSSxXQUFXLEVBQUU7SUFDaEM7SUFFSSxJQUFJLENBQUNGLE9BQU8sSUFBSWpELEtBQUssQ0FBQzNILE1BQU0sQ0FBQzRDLEtBQUssQ0FBQyxFQUFFO01BQ25DLE1BQU0sSUFBSWlGLFVBQVUsQ0FBQyw4Q0FBOEMsQ0FBQztJQUMxRTtJQUVJLElBQUlGLEtBQUssQ0FBQzNJLGFBQWEsQ0FBQzRELEtBQUssQ0FBQyxJQUFJK0UsS0FBSyxDQUFDN0QsWUFBWSxDQUFDbEIsS0FBSyxDQUFDLEVBQUU7TUFDM0QsT0FBT2dJLE9BQU8sSUFBSSxPQUFPRCxJQUFJLEtBQUssVUFBVSxHQUFHLElBQUlBLElBQUksQ0FBQyxDQUFDL0gsS0FBSyxDQUFDLENBQUMsR0FBR21JLE1BQU0sQ0FBQ25DLElBQUksQ0FBQ2hHLEtBQUssQ0FBQztJQUMzRjtJQUVJLE9BQU9BLEtBQUs7RUFDaEI7O0VBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxTQUFTNkgsY0FBY0EsQ0FBQzdILEtBQUssRUFBRXpCLEdBQUcsRUFBRWtJLElBQUksRUFBRTtJQUN4QyxJQUFJeEYsR0FBRyxHQUFHakIsS0FBSztJQUVmLElBQUlBLEtBQUssSUFBSSxDQUFDeUcsSUFBSSxJQUFJLE9BQU96RyxLQUFLLEtBQUssUUFBUSxFQUFFO01BQy9DLElBQUkrRSxLQUFLLENBQUN0RSxRQUFRLENBQUNsQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUU7UUFDckM7UUFDUUEsR0FBRyxHQUFHaUosVUFBVSxHQUFHakosR0FBRyxHQUFHQSxHQUFHLENBQUNoRCxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pEO1FBQ1F5RSxLQUFLLEdBQUdvSSxJQUFJLENBQUNDLFNBQVMsQ0FBQ3JJLEtBQUssQ0FBQztNQUNyQyxDQUFPLE1BQU0sSUFDSitFLEtBQUssQ0FBQ2xKLE9BQU8sQ0FBQ21FLEtBQUssQ0FBQyxJQUFJZ0gsV0FBVyxDQUFDaEgsS0FBSyxDQUFDLElBQzFDLENBQUMrRSxLQUFLLENBQUMxSCxVQUFVLENBQUMyQyxLQUFLLENBQUMsSUFBSStFLEtBQUssQ0FBQ3RFLFFBQVEsQ0FBQ2xDLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTTBDLEdBQUcsR0FBRzhELEtBQUssQ0FBQy9ELE9BQU8sQ0FBQ2hCLEtBQUssQ0FBQyxDQUNyRixFQUFFO1FBQ1g7UUFDUXpCLEdBQUcsR0FBR2dJLGNBQWMsQ0FBQ2hJLEdBQUcsQ0FBQztRQUV6QjBDLEdBQUcsQ0FBQ25ELE9BQU8sQ0FBQyxTQUFTK0ksSUFBSUEsQ0FBQ3lCLEVBQUUsRUFBRUMsS0FBSyxFQUFFO1VBQ25DLEVBQUV4RCxLQUFLLENBQUNoSixXQUFXLENBQUN1TSxFQUFFLENBQUMsSUFBSUEsRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJakIsUUFBUSxDQUFDN0MsTUFBTTtVQUNwRTtVQUNZaUQsT0FBTyxLQUFLLElBQUksR0FBR2pCLFNBQVMsQ0FBQyxDQUFDakksR0FBRyxDQUFDLEVBQUVnSyxLQUFLLEVBQUU3QixJQUFJLENBQUMsR0FBSWUsT0FBTyxLQUFLLElBQUksR0FBR2xKLEdBQUcsR0FBR0EsR0FBRyxHQUFHLElBQUssRUFDeEYwSixZQUFZLENBQUNLLEVBQUUsQ0FBQyxDQUNqQjtRQUNYLENBQVMsQ0FBQztRQUNGLE9BQU8sS0FBSztNQUNwQjtJQUNBO0lBRUksSUFBSWhDLFdBQVcsQ0FBQ3RHLEtBQUssQ0FBQyxFQUFFO01BQ3RCLE9BQU8sSUFBSTtJQUNqQjtJQUVJcUgsUUFBUSxDQUFDN0MsTUFBTSxDQUFDZ0MsU0FBUyxDQUFDQyxJQUFJLEVBQUVsSSxHQUFHLEVBQUVtSSxJQUFJLENBQUMsRUFBRXVCLFlBQVksQ0FBQ2pJLEtBQUssQ0FBQyxDQUFDO0lBRWhFLE9BQU8sS0FBSztFQUNoQjtFQUVFLE1BQU0wRSxLQUFLLEdBQUcsRUFBRTtFQUVoQixNQUFNOEQsY0FBYyxHQUFHek4sTUFBTSxDQUFDa0YsTUFBTSxDQUFDaUgsVUFBVSxFQUFFO0lBQy9DVyxjQUFjO0lBQ2RJLFlBQVk7SUFDWjNCO0VBQ0osQ0FBRyxDQUFDO0VBRUYsU0FBU21DLEtBQUtBLENBQUN6SSxLQUFLLEVBQUV5RyxJQUFJLEVBQUU7SUFDMUIsSUFBSTFCLEtBQUssQ0FBQ2hKLFdBQVcsQ0FBQ2lFLEtBQUssQ0FBQyxFQUFFO0lBRTlCLElBQUkwRSxLQUFLLENBQUMzRCxPQUFPLENBQUNmLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO01BQy9CLE1BQU1tRCxLQUFLLENBQUMsaUNBQWlDLEdBQUdzRCxJQUFJLENBQUNNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyRTtJQUVJckMsS0FBSyxDQUFDNUMsSUFBSSxDQUFDOUIsS0FBSyxDQUFDO0lBRWpCK0UsS0FBSyxDQUFDakgsT0FBTyxDQUFDa0MsS0FBSyxFQUFFLFNBQVM2RyxJQUFJQSxDQUFDeUIsRUFBRSxFQUFFL0osR0FBRyxFQUFFO01BQzFDLE1BQU1qQyxNQUFNLEdBQUcsRUFBRXlJLEtBQUssQ0FBQ2hKLFdBQVcsQ0FBQ3VNLEVBQUUsQ0FBQyxJQUFJQSxFQUFFLEtBQUssSUFBSSxDQUFDLElBQUlWLE9BQU8sQ0FBQ3RNLElBQUksQ0FDcEUrTCxRQUFRLEVBQUVpQixFQUFFLEVBQUV2RCxLQUFLLENBQUNySSxRQUFRLENBQUM2QixHQUFHLENBQUMsR0FBR0EsR0FBRyxDQUFDWCxJQUFJLEVBQUUsR0FBR1csR0FBRyxFQUFFa0ksSUFBSSxFQUFFK0IsY0FBYyxDQUMzRTtNQUVELElBQUlsTSxNQUFNLEtBQUssSUFBSSxFQUFFO1FBQ25CbU0sS0FBSyxDQUFDSCxFQUFFLEVBQUU3QixJQUFJLEdBQUdBLElBQUksQ0FBQ0UsTUFBTSxDQUFDcEksR0FBRyxDQUFDLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDLENBQUM7TUFDbEQ7SUFDQSxDQUFLLENBQUM7SUFFRm1HLEtBQUssQ0FBQ2dFLEdBQUcsRUFBRTtFQUNmO0VBRUUsSUFBSSxDQUFDM0QsS0FBSyxDQUFDbkksUUFBUSxDQUFDbUIsR0FBRyxDQUFDLEVBQUU7SUFDeEIsTUFBTSxJQUFJd0osU0FBUyxDQUFDLHdCQUF3QixDQUFDO0VBQ2pEO0VBRUVrQixLQUFLLENBQUMxSyxHQUFHLENBQUM7RUFFVixPQUFPc0osUUFBUTtBQUNqQjs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNzQixRQUFNQyxDQUFDdk4sR0FBRyxFQUFFO0VBQ25CLE1BQU13TixPQUFPLEdBQUc7SUFDZCxHQUFHLEVBQUUsS0FBSztJQUNWLEdBQUcsRUFBRSxLQUFLO0lBQ1YsR0FBRyxFQUFFLEtBQUs7SUFDVixHQUFHLEVBQUUsS0FBSztJQUNWLEdBQUcsRUFBRSxLQUFLO0lBQ1YsS0FBSyxFQUFFLEdBQUc7SUFDVixLQUFLLEVBQUU7RUFDWCxDQUFHO0VBQ0QsT0FBT0Msa0JBQWtCLENBQUN6TixHQUFHLENBQUMsQ0FBQ3dDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxTQUFTb0UsUUFBUUEsQ0FBQzhHLEtBQUssRUFBRTtJQUNsRixPQUFPRixPQUFPLENBQUNFLEtBQUssQ0FBQztFQUN6QixDQUFHLENBQUM7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0Msb0JBQW9CQSxDQUFDQyxNQUFNLEVBQUUzQixPQUFPLEVBQUU7RUFDN0MsSUFBSSxDQUFDNEIsTUFBTSxHQUFHLEVBQUU7RUFFaEJELE1BQU0sSUFBSTdCLFVBQVUsQ0FBQzZCLE1BQU0sRUFBRSxJQUFJLEVBQUUzQixPQUFPLENBQUM7QUFDN0M7QUFFQSxNQUFNdE0sU0FBUyxHQUFHZ08sb0JBQW9CLENBQUNoTyxTQUFTO0FBRWhEQSxTQUFTLENBQUN3SixNQUFNLEdBQUcsU0FBU0EsTUFBTUEsQ0FBQzNCLElBQUksRUFBRTdDLEtBQUssRUFBRTtFQUM5QyxJQUFJLENBQUNrSixNQUFNLENBQUNwSCxJQUFJLENBQUMsQ0FBQ2UsSUFBSSxFQUFFN0MsS0FBSyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUVEaEYsU0FBUyxDQUFDRixRQUFRLEdBQUcsU0FBU0EsUUFBUUEsQ0FBQ3FPLE9BQU8sRUFBRTtFQUM5QyxNQUFNQyxPQUFPLEdBQUdELE9BQU8sR0FBRyxVQUFTbkosS0FBSyxFQUFFO0lBQ3hDLE9BQU9tSixPQUFPLENBQUM3TixJQUFJLENBQUMsSUFBSSxFQUFFMEUsS0FBSyxFQUFFMkksUUFBTSxDQUFDO0VBQzVDLENBQUcsR0FBR0EsUUFBTTtFQUVWLE9BQU8sSUFBSSxDQUFDTyxNQUFNLENBQUN0QyxHQUFHLENBQUMsU0FBU0MsSUFBSUEsQ0FBQ3BGLElBQUksRUFBRTtJQUN6QyxPQUFPMkgsT0FBTyxDQUFDM0gsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHMkgsT0FBTyxDQUFDM0gsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ3BELENBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQ3NGLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDbEIsQ0FBQzs7QUNsREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM2QixNQUFNQSxDQUFDM00sR0FBRyxFQUFFO0VBQ25CLE9BQU82TSxrQkFBa0IsQ0FBQzdNLEdBQUcsQ0FBQyxDQUM1QjRCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQ3JCQSxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUNwQkEsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FDckJBLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQ3BCQSxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUNyQkEsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsU0FBU3dMLFFBQVFBLENBQUNDLEdBQUcsRUFBRUwsTUFBTSxFQUFFM0IsT0FBTyxFQUFFO0VBQ3ZEO0VBQ0UsSUFBSSxDQUFDMkIsTUFBTSxFQUFFO0lBQ1gsT0FBT0ssR0FBRztFQUNkO0VBRUUsTUFBTUYsT0FBTyxHQUFHOUIsT0FBTyxJQUFJQSxPQUFPLENBQUNzQixNQUFNLElBQUlBLE1BQU07RUFFbkQsTUFBTVcsV0FBVyxHQUFHakMsT0FBTyxJQUFJQSxPQUFPLENBQUNrQyxTQUFTO0VBRWhELElBQUlDLGdCQUFnQjtFQUVwQixJQUFJRixXQUFXLEVBQUU7SUFDZkUsZ0JBQWdCLEdBQUdGLFdBQVcsQ0FBQ04sTUFBTSxFQUFFM0IsT0FBTyxDQUFDO0VBQ25ELENBQUcsTUFBTTtJQUNMbUMsZ0JBQWdCLEdBQUcxRSxLQUFLLENBQUNwSCxpQkFBaUIsQ0FBQ3NMLE1BQU0sQ0FBQyxHQUNoREEsTUFBTSxDQUFDbk8sUUFBUSxFQUFFLEdBQ2pCLElBQUlrTyxvQkFBb0IsQ0FBQ0MsTUFBTSxFQUFFM0IsT0FBTyxDQUFDLENBQUN4TSxRQUFRLENBQUNzTyxPQUFPLENBQUM7RUFDakU7RUFFRSxJQUFJSyxnQkFBZ0IsRUFBRTtJQUNwQixNQUFNQyxhQUFhLEdBQUdKLEdBQUcsQ0FBQ3ZJLE9BQU8sQ0FBQyxHQUFHLENBQUM7SUFFdEMsSUFBSTJJLGFBQWEsS0FBSyxDQUFDLENBQUMsRUFBRTtNQUN4QkosR0FBRyxHQUFHQSxHQUFHLENBQUMvTixLQUFLLENBQUMsQ0FBQyxFQUFFbU8sYUFBYSxDQUFDO0lBQ3ZDO0lBQ0lKLEdBQUcsSUFBSSxDQUFDQSxHQUFHLENBQUN2SSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSTBJLGdCQUFnQjtFQUNuRTtFQUVFLE9BQU9ILEdBQUc7QUFDWjtBQzFEQSxNQUFNSyxrQkFBa0IsQ0FBQztFQUN2QnpOLFdBQVdBLENBQUEsRUFBRztJQUNaLElBQUksQ0FBQzBOLFFBQVEsR0FBRyxFQUFFO0VBQ3RCOztFQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsR0FBR0EsQ0FBQ0MsU0FBUyxFQUFFQyxRQUFRLEVBQUV6QyxPQUFPLEVBQUU7SUFDaEMsSUFBSSxDQUFDc0MsUUFBUSxDQUFDOUgsSUFBSSxDQUFDO01BQ2pCZ0ksU0FBUztNQUNUQyxRQUFRO01BQ1JDLFdBQVcsRUFBRTFDLE9BQU8sR0FBR0EsT0FBTyxDQUFDMEMsV0FBVyxHQUFHLEtBQUs7TUFDbERDLE9BQU8sRUFBRTNDLE9BQU8sR0FBR0EsT0FBTyxDQUFDMkMsT0FBTyxHQUFHO0lBQzNDLENBQUssQ0FBQztJQUNGLE9BQU8sSUFBSSxDQUFDTCxRQUFRLENBQUN6TCxNQUFNLEdBQUcsQ0FBQztFQUNuQzs7RUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNFK0wsS0FBS0EsQ0FBQ0MsRUFBRSxFQUFFO0lBQ1IsSUFBSSxJQUFJLENBQUNQLFFBQVEsQ0FBQ08sRUFBRSxDQUFDLEVBQUU7TUFDckIsSUFBSSxDQUFDUCxRQUFRLENBQUNPLEVBQUUsQ0FBQyxHQUFHLElBQUk7SUFDOUI7RUFDQTs7RUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0VDLEtBQUtBLENBQUEsRUFBRztJQUNOLElBQUksSUFBSSxDQUFDUixRQUFRLEVBQUU7TUFDakIsSUFBSSxDQUFDQSxRQUFRLEdBQUcsRUFBRTtJQUN4QjtFQUNBOztFQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0U5TCxPQUFPQSxDQUFDckQsRUFBRSxFQUFFO0lBQ1ZzSyxLQUFLLENBQUNqSCxPQUFPLENBQUMsSUFBSSxDQUFDOEwsUUFBUSxFQUFFLFNBQVNTLGNBQWNBLENBQUNDLENBQUMsRUFBRTtNQUN0RCxJQUFJQSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ2Q3UCxFQUFFLENBQUM2UCxDQUFDLENBQUM7TUFDYjtJQUNBLENBQUssQ0FBQztFQUNOO0FBQ0E7QUFFQSxJQUFBQyxvQkFBQSxHQUFlWixrQkFBa0I7QUNwRWpDLElBQUFhLG9CQUFBLEdBQWU7RUFDYkMsaUJBQWlCLEVBQUUsSUFBSTtFQUN2QkMsaUJBQWlCLEVBQUUsSUFBSTtFQUN2QkMsbUJBQW1CLEVBQUU7QUFDdkIsQ0FBQztBQ0hELElBQUFDLGlCQUFBLEdBQWUsT0FBT0MsZUFBZSxLQUFLLFdBQVcsR0FBR0EsZUFBZSxHQUFHN0Isb0JBQW9CO0FDRDlGLElBQUE4QixVQUFBLEdBQWUsT0FBT3BOLFFBQVEsS0FBSyxXQUFXLEdBQUdBLFFBQVEsR0FBRyxJQUFJO0FDQWhFLElBQUFxTixNQUFBLEdBQWUsT0FBT2hELElBQUksS0FBSyxXQUFXLEdBQUdBLElBQUksR0FBRzs7QUNFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1pRCxvQkFBb0IsR0FBRyxDQUFDLE1BQU07RUFDbEMsSUFBSUMsT0FBTztFQUNYLElBQUksT0FBT0MsU0FBUyxLQUFLLFdBQVcsS0FDbEMsQ0FBQ0QsT0FBTyxHQUFHQyxTQUFTLENBQUNELE9BQU8sTUFBTSxhQUFhLElBQy9DQSxPQUFPLEtBQUssY0FBYyxJQUMxQkEsT0FBTyxLQUFLLElBQUksQ0FBQyxFQUNqQjtJQUNBLE9BQU8sS0FBSztFQUNoQjtFQUVFLE9BQU8sT0FBT3BNLE1BQU0sS0FBSyxXQUFXLElBQUksT0FBT3NNLFFBQVEsS0FBSyxXQUFXO0FBQ3pFLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQyxNQUFNQyw2QkFBNkIsR0FBRyxDQUFDLE1BQU07RUFDNUMsT0FDRSxPQUFPQyxpQkFBaUIsS0FBSyxXQUFXO0VBQzVDO0VBQ0l6TSxJQUFJLFlBQVl5TSxpQkFBaUIsSUFDakMsT0FBT3pNLElBQUksQ0FBQzBNLGFBQWEsS0FBSyxVQUFVO0FBRTVDLENBQUMsR0FBRztBQUdKLElBQUFDLFFBQUEsR0FBZTtFQUNiQyxTQUFTLEVBQUUsSUFBSTtFQUNmQyxPQUFPLEVBQUU7SUFDWFosZUFBQSxFQUFJRCxpQkFBZTtJQUNuQmxOLFFBQUEsRUFBSW9OLFVBQVE7SUFDWi9DLElBQUEsRUFBSWdEO0VBQ0osQ0FBRztFQUNEQyxvQkFBb0I7RUFDcEJJLDZCQUE2QjtFQUM3Qk0sU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNO0FBQzVELENBQUM7QUN6RGMsU0FBU0MsZ0JBQWdCQSxDQUFDQyxJQUFJLEVBQUV0RSxPQUFPLEVBQUU7RUFDdEQsT0FBT0YsVUFBVSxDQUFDd0UsSUFBSSxFQUFFLElBQUlMLFFBQVEsQ0FBQ0UsT0FBTyxDQUFDWixlQUFlLEVBQUUsRUFBRTlQLE1BQU0sQ0FBQ2tGLE1BQU0sQ0FBQztJQUM1RTJILE9BQU8sRUFBRSxTQUFBQSxDQUFTNUgsS0FBSyxFQUFFekIsR0FBRyxFQUFFa0ksSUFBSSxFQUFFb0YsT0FBTyxFQUFFO01BQzNDLElBQUlOLFFBQVEsQ0FBQ08sTUFBTSxJQUFJL0csS0FBSyxDQUFDL0ksUUFBUSxDQUFDZ0UsS0FBSyxDQUFDLEVBQUU7UUFDNUMsSUFBSSxDQUFDd0UsTUFBTSxDQUFDakcsR0FBRyxFQUFFeUIsS0FBSyxDQUFDbEYsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzFDLE9BQU8sS0FBSztNQUNwQjtNQUVNLE9BQU8rUSxPQUFPLENBQUNoRSxjQUFjLENBQUNqTixLQUFLLENBQUMsSUFBSSxFQUFFQyxTQUFTLENBQUM7SUFDMUQ7RUFDQSxDQUFHLEVBQUV5TSxPQUFPLENBQUMsQ0FBQztBQUNkOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3lFLGFBQWFBLENBQUNsSixJQUFJLEVBQUU7RUFDN0I7RUFDQTtFQUNBO0VBQ0E7RUFDRSxPQUFPa0MsS0FBSyxDQUFDckQsUUFBUSxDQUFDLGVBQWUsRUFBRW1CLElBQUksQ0FBQyxDQUFDK0QsR0FBRyxDQUFDbUMsS0FBSyxJQUFJO0lBQ3hELE9BQU9BLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEdBQUcsRUFBRSxHQUFHQSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUlBLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDeEQsQ0FBRyxDQUFDO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaUQsYUFBYUEsQ0FBQy9LLEdBQUcsRUFBRTtFQUMxQixNQUFNbEQsR0FBRyxHQUFHLEVBQUU7RUFDZCxNQUFNSyxJQUFJLEdBQUdyRCxNQUFNLENBQUNxRCxJQUFJLENBQUM2QyxHQUFHLENBQUM7RUFDN0IsSUFBSWhELENBQUM7RUFDTCxNQUFNSyxHQUFHLEdBQUdGLElBQUksQ0FBQ0QsTUFBTTtFQUN2QixJQUFJSSxHQUFHO0VBQ1AsS0FBS04sQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHSyxHQUFHLEVBQUVMLENBQUMsRUFBRSxFQUFFO0lBQ3hCTSxHQUFHLEdBQUdILElBQUksQ0FBQ0gsQ0FBQyxDQUFDO0lBQ2JGLEdBQUcsQ0FBQ1EsR0FBRyxDQUFDLEdBQUcwQyxHQUFHLENBQUMxQyxHQUFHLENBQUM7RUFDdkI7RUFDRSxPQUFPUixHQUFHO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTa08sY0FBY0EsQ0FBQzVFLFFBQVEsRUFBRTtFQUNoQyxTQUFTNkUsU0FBU0EsQ0FBQ3pGLElBQUksRUFBRXpHLEtBQUssRUFBRTZFLE1BQU0sRUFBRTBELEtBQUssRUFBRTtJQUM3QyxJQUFJMUYsSUFBSSxHQUFHNEQsSUFBSSxDQUFDOEIsS0FBSyxFQUFFLENBQUM7SUFDeEIsTUFBTTRELFlBQVksR0FBR3ZJLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDLENBQUNoQixJQUFJLENBQUM7SUFDM0MsTUFBTXVKLE1BQU0sR0FBRzdELEtBQUssSUFBSTlCLElBQUksQ0FBQ3RJLE1BQU07SUFDbkMwRSxJQUFJLEdBQUcsQ0FBQ0EsSUFBSSxJQUFJa0MsS0FBSyxDQUFDbEosT0FBTyxDQUFDZ0osTUFBTSxDQUFDLEdBQUdBLE1BQU0sQ0FBQzFHLE1BQU0sR0FBRzBFLElBQUk7SUFFNUQsSUFBSXVKLE1BQU0sRUFBRTtNQUNWLElBQUlySCxLQUFLLENBQUNDLFVBQVUsQ0FBQ0gsTUFBTSxFQUFFaEMsSUFBSSxDQUFDLEVBQUU7UUFDbENnQyxNQUFNLENBQUNoQyxJQUFJLENBQUMsR0FBRyxDQUFDZ0MsTUFBTSxDQUFDaEMsSUFBSSxDQUFDLEVBQUU3QyxLQUFLLENBQUM7TUFDNUMsQ0FBTyxNQUFNO1FBQ0w2RSxNQUFNLENBQUNoQyxJQUFJLENBQUMsR0FBRzdDLEtBQUs7TUFDNUI7TUFFTSxPQUFPLENBQUNtTSxZQUFZO0lBQzFCO0lBRUksSUFBSSxDQUFDdEgsTUFBTSxDQUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQ2tDLEtBQUssQ0FBQ25JLFFBQVEsQ0FBQ2lJLE1BQU0sQ0FBQ2hDLElBQUksQ0FBQyxDQUFDLEVBQUU7TUFDbERnQyxNQUFNLENBQUNoQyxJQUFJLENBQUMsR0FBRyxFQUFFO0lBQ3ZCO0lBRUksTUFBTXZHLE1BQU0sR0FBRzRQLFNBQVMsQ0FBQ3pGLElBQUksRUFBRXpHLEtBQUssRUFBRTZFLE1BQU0sQ0FBQ2hDLElBQUksQ0FBQyxFQUFFMEYsS0FBSyxDQUFDO0lBRTFELElBQUlqTSxNQUFNLElBQUl5SSxLQUFLLENBQUNsSixPQUFPLENBQUNnSixNQUFNLENBQUNoQyxJQUFJLENBQUMsQ0FBQyxFQUFFO01BQ3pDZ0MsTUFBTSxDQUFDaEMsSUFBSSxDQUFDLEdBQUdtSixhQUFhLENBQUNuSCxNQUFNLENBQUNoQyxJQUFJLENBQUMsQ0FBQztJQUNoRDtJQUVJLE9BQU8sQ0FBQ3NKLFlBQVk7RUFDeEI7RUFFRSxJQUFJcEgsS0FBSyxDQUFDdkgsVUFBVSxDQUFDNkosUUFBUSxDQUFDLElBQUl0QyxLQUFLLENBQUM1SSxVQUFVLENBQUNrTCxRQUFRLENBQUNnRixPQUFPLENBQUMsRUFBRTtJQUNwRSxNQUFNdE8sR0FBRyxHQUFHLEVBQUU7SUFFZGdILEtBQUssQ0FBQzFELFlBQVksQ0FBQ2dHLFFBQVEsRUFBRSxDQUFDeEUsSUFBSSxFQUFFN0MsS0FBSyxLQUFLO01BQzVDa00sU0FBUyxDQUFDSCxhQUFhLENBQUNsSixJQUFJLENBQUMsRUFBRTdDLEtBQUssRUFBRWpDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDbkQsQ0FBSyxDQUFDO0lBRUYsT0FBT0EsR0FBRztFQUNkO0VBRUUsT0FBTyxJQUFJO0FBQ2I7QUMvRUEsTUFBTXVPLG9CQUFvQixHQUFHO0VBQzNCLGNBQWMsRUFBRXpMO0FBQ2xCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTMEwsZUFBZUEsQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLEVBQUV0RCxPQUFPLEVBQUU7RUFDbEQsSUFBSXBFLEtBQUssQ0FBQ3JJLFFBQVEsQ0FBQzhQLFFBQVEsQ0FBQyxFQUFFO0lBQzVCLElBQUk7TUFDRixDQUFDQyxNQUFNLElBQUlyRSxJQUFJLENBQUNzRSxLQUFLLEVBQUVGLFFBQVEsQ0FBQztNQUNoQyxPQUFPekgsS0FBSyxDQUFDbkgsSUFBSSxDQUFDNE8sUUFBUSxDQUFDO0lBQ2pDLENBQUssQ0FBQyxPQUFPRyxDQUFDLEVBQUU7TUFDVixJQUFJQSxDQUFDLENBQUM5SixJQUFJLEtBQUssYUFBYSxFQUFFO1FBQzVCLE1BQU04SixDQUFDO01BQ2Y7SUFDQTtFQUNBO0VBRUUsT0FBTyxDQUFDeEQsT0FBTyxJQUFJZixJQUFJLENBQUNDLFNBQVMsRUFBRW1FLFFBQVEsQ0FBQztBQUM5QztBQUVBLE1BQU1JLFFBQVEsR0FBRztFQUVmQyxZQUFZLEVBQUVyQyxvQkFBb0I7RUFFbENzQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDO0VBRXhCQyxnQkFBZ0IsRUFBRSxDQUFDLFNBQVNBLGdCQUFnQkEsQ0FBQ25CLElBQUksRUFBRW9CLE9BQU8sRUFBRTtJQUMxRCxNQUFNQyxXQUFXLEdBQUdELE9BQU8sQ0FBQ0UsY0FBYyxFQUFFLElBQUksRUFBRTtJQUNsRCxNQUFNQyxrQkFBa0IsR0FBR0YsV0FBVyxDQUFDbE0sT0FBTyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZFLE1BQU1xTSxlQUFlLEdBQUdySSxLQUFLLENBQUNuSSxRQUFRLENBQUNnUCxJQUFJLENBQUM7SUFFNUMsSUFBSXdCLGVBQWUsSUFBSXJJLEtBQUssQ0FBQ2hELFVBQVUsQ0FBQzZKLElBQUksQ0FBQyxFQUFFO01BQzdDQSxJQUFJLEdBQUcsSUFBSWxPLFFBQVEsQ0FBQ2tPLElBQUksQ0FBQztJQUMvQjtJQUVJLE1BQU1wTyxVQUFVLEdBQUd1SCxLQUFLLENBQUN2SCxVQUFVLENBQUNvTyxJQUFJLENBQUM7SUFFekMsSUFBSXBPLFVBQVUsRUFBRTtNQUNkLElBQUksQ0FBQzJQLGtCQUFrQixFQUFFO1FBQ3ZCLE9BQU92QixJQUFJO01BQ25CO01BQ00sT0FBT3VCLGtCQUFrQixHQUFHL0UsSUFBSSxDQUFDQyxTQUFTLENBQUM0RCxjQUFjLENBQUNMLElBQUksQ0FBQyxDQUFDLEdBQUdBLElBQUk7SUFDN0U7SUFFSSxJQUFJN0csS0FBSyxDQUFDM0ksYUFBYSxDQUFDd1AsSUFBSSxDQUFDLElBQzNCN0csS0FBSyxDQUFDL0ksUUFBUSxDQUFDNFAsSUFBSSxDQUFDLElBQ3BCN0csS0FBSyxDQUFDekgsUUFBUSxDQUFDc08sSUFBSSxDQUFDLElBQ3BCN0csS0FBSyxDQUFDNUgsTUFBTSxDQUFDeU8sSUFBSSxDQUFDLElBQ2xCN0csS0FBSyxDQUFDM0gsTUFBTSxDQUFDd08sSUFBSSxDQUFDLEVBQ2xCO01BQ0EsT0FBT0EsSUFBSTtJQUNqQjtJQUNJLElBQUk3RyxLQUFLLENBQUMxSSxpQkFBaUIsQ0FBQ3VQLElBQUksQ0FBQyxFQUFFO01BQ2pDLE9BQU9BLElBQUksQ0FBQ25QLE1BQU07SUFDeEI7SUFDSSxJQUFJc0ksS0FBSyxDQUFDcEgsaUJBQWlCLENBQUNpTyxJQUFJLENBQUMsRUFBRTtNQUNqQ29CLE9BQU8sQ0FBQ0ssY0FBYyxDQUFDLGlEQUFpRCxFQUFFLEtBQUssQ0FBQztNQUNoRixPQUFPekIsSUFBSSxDQUFDOVEsUUFBUSxFQUFFO0lBQzVCO0lBRUksSUFBSXVDLFVBQVU7SUFFZCxJQUFJK1AsZUFBZSxFQUFFO01BQ25CLElBQUlILFdBQVcsQ0FBQ2xNLE9BQU8sQ0FBQyxtQ0FBbUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ2pFLE9BQU80SyxnQkFBZ0IsQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQzBCLGNBQWMsQ0FBQyxDQUFDeFMsUUFBUSxFQUFFO01BQ3JFO01BRU0sSUFBSSxDQUFDdUMsVUFBVSxHQUFHMEgsS0FBSyxDQUFDMUgsVUFBVSxDQUFDdU8sSUFBSSxDQUFDLEtBQUtxQixXQUFXLENBQUNsTSxPQUFPLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUM1RixNQUFNd00sU0FBUyxHQUFHLElBQUksQ0FBQ0MsR0FBRyxJQUFJLElBQUksQ0FBQ0EsR0FBRyxDQUFDOVAsUUFBUTtRQUUvQyxPQUFPMEosVUFBVSxDQUNmL0osVUFBVSxHQUFHO1VBQUMsU0FBUyxFQUFFdU87UUFBSSxDQUFDLEdBQUdBLElBQUksRUFDckMyQixTQUFTLElBQUksSUFBSUEsU0FBUyxFQUFFLEVBQzVCLElBQUksQ0FBQ0QsY0FBYyxDQUNwQjtNQUNUO0lBQ0E7SUFFSSxJQUFJRixlQUFlLElBQUlELGtCQUFrQixFQUFHO01BQzFDSCxPQUFPLENBQUNLLGNBQWMsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLENBQUM7TUFDakQsT0FBT2QsZUFBZSxDQUFDWCxJQUFJLENBQUM7SUFDbEM7SUFFSSxPQUFPQSxJQUFJO0VBQ2YsQ0FBRyxDQUFDO0VBRUY2QixpQkFBaUIsRUFBRSxDQUFDLFNBQVNBLGlCQUFpQkEsQ0FBQzdCLElBQUksRUFBRTtJQUNuRCxNQUFNaUIsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWSxJQUFJRCxRQUFRLENBQUNDLFlBQVk7SUFDL0QsTUFBTW5DLGlCQUFpQixHQUFHbUMsWUFBWSxJQUFJQSxZQUFZLENBQUNuQyxpQkFBaUI7SUFDeEUsTUFBTWdELGFBQWEsR0FBRyxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO0lBRWxELElBQUkvQixJQUFJLElBQUk3RyxLQUFLLENBQUNySSxRQUFRLENBQUNrUCxJQUFJLENBQUMsS0FBTWxCLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDaUQsWUFBWSxJQUFLRCxhQUFhLENBQUMsRUFBRTtNQUNoRyxNQUFNakQsaUJBQWlCLEdBQUdvQyxZQUFZLElBQUlBLFlBQVksQ0FBQ3BDLGlCQUFpQjtNQUN4RSxNQUFNbUQsaUJBQWlCLEdBQUcsQ0FBQ25ELGlCQUFpQixJQUFJaUQsYUFBYTtNQUU3RCxJQUFJO1FBQ0YsT0FBT3RGLElBQUksQ0FBQ3NFLEtBQUssQ0FBQ2QsSUFBSSxDQUFDO01BQy9CLENBQU8sQ0FBQyxPQUFPZSxDQUFDLEVBQUU7UUFDVixJQUFJaUIsaUJBQWlCLEVBQUU7VUFDckIsSUFBSWpCLENBQUMsQ0FBQzlKLElBQUksS0FBSyxhQUFhLEVBQUU7WUFDNUIsTUFBTW9DLFVBQVUsQ0FBQ2UsSUFBSSxDQUFDMkcsQ0FBQyxFQUFFMUgsVUFBVSxDQUFDNEksZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUN2SSxRQUFRLENBQUM7VUFDNUY7VUFDVSxNQUFNcUgsQ0FBQztRQUNqQjtNQUNBO0lBQ0E7SUFFSSxPQUFPZixJQUFJO0VBQ2YsQ0FBRyxDQUFDO0VBRUo7QUFDQTtBQUNBO0FBQ0E7RUFDRWtDLE9BQU8sRUFBRSxDQUFDO0VBRVZDLGNBQWMsRUFBRSxZQUFZO0VBQzVCQyxjQUFjLEVBQUUsY0FBYztFQUU5QkMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0VBQ3BCQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO0VBRWpCVixHQUFHLEVBQUU7SUFDSDlQLFFBQVEsRUFBRTZOLFFBQVEsQ0FBQ0UsT0FBTyxDQUFDL04sUUFBUTtJQUNuQ3FLLElBQUksRUFBRXdELFFBQVEsQ0FBQ0UsT0FBTyxDQUFDMUQ7RUFDM0IsQ0FBRztFQUVEb0csY0FBYyxFQUFFLFNBQVNBLGNBQWNBLENBQUNySSxNQUFNLEVBQUU7SUFDOUMsT0FBT0EsTUFBTSxJQUFJLEdBQUcsSUFBSUEsTUFBTSxHQUFHLEdBQUc7RUFDeEMsQ0FBRztFQUVEa0gsT0FBTyxFQUFFO0lBQ1BvQixNQUFNLEVBQUU7TUFDTixRQUFRLEVBQUU7SUFDaEI7RUFDQTtBQUNBLENBQUM7QUFFRHJKLEtBQUssQ0FBQ2pILE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBQUUsU0FBU3VRLG1CQUFtQkEsQ0FBQ0MsTUFBTSxFQUFFO0VBQzVFMUIsUUFBUSxDQUFDSSxPQUFPLENBQUNzQixNQUFNLENBQUMsR0FBRyxFQUFFO0FBQy9CLENBQUMsQ0FBQztBQUVGdkosS0FBSyxDQUFDakgsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxTQUFTeVEscUJBQXFCQSxDQUFDRCxNQUFNLEVBQUU7RUFDN0UxQixRQUFRLENBQUNJLE9BQU8sQ0FBQ3NCLE1BQU0sQ0FBQyxHQUFHdkosS0FBSyxDQUFDOUYsS0FBSyxDQUFDcU4sb0JBQW9CLENBQUM7QUFDOUQsQ0FBQyxDQUFDO0FBRUYsSUFBQWtDLFVBQUEsR0FBZTVCLFFBQVE7O0FDakt2QjtBQUNBO0FBQ0EsTUFBTTZCLGlCQUFpQixHQUFHMUosS0FBSyxDQUFDM0IsV0FBVyxDQUFDLENBQzFDLEtBQUssRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFDaEUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCLEVBQ3JFLGVBQWUsRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLHFCQUFxQixFQUNsRSxTQUFTLEVBQUUsYUFBYSxFQUFFLFlBQVksQ0FDdkMsQ0FBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBQXNMLFlBQUEsR0FBZUMsVUFBVSxJQUFJO0VBQzNCLE1BQU1DLE1BQU0sR0FBRyxFQUFFO0VBQ2pCLElBQUlyUSxHQUFHO0VBQ1AsSUFBSXRDLEdBQUc7RUFDUCxJQUFJZ0MsQ0FBQztFQUVMMFEsVUFBVSxJQUFJQSxVQUFVLENBQUNuTCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMxRixPQUFPLENBQUMsU0FBUzJPLE1BQU1BLENBQUNvQyxJQUFJLEVBQUU7SUFDakU1USxDQUFDLEdBQUc0USxJQUFJLENBQUM5TixPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ3JCeEMsR0FBRyxHQUFHc1EsSUFBSSxDQUFDQyxTQUFTLENBQUMsQ0FBQyxFQUFFN1EsQ0FBQyxDQUFDLENBQUNMLElBQUksRUFBRSxDQUFDcEMsV0FBVyxFQUFFO0lBQy9DUyxHQUFHLEdBQUc0UyxJQUFJLENBQUNDLFNBQVMsQ0FBQzdRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQ0wsSUFBSSxFQUFFO0lBRWxDLElBQUksQ0FBQ1csR0FBRyxJQUFLcVEsTUFBTSxDQUFDclEsR0FBRyxDQUFDLElBQUlrUSxpQkFBaUIsQ0FBQ2xRLEdBQUcsQ0FBRSxFQUFFO01BQ25EO0lBQ047SUFFSSxJQUFJQSxHQUFHLEtBQUssWUFBWSxFQUFFO01BQ3hCLElBQUlxUSxNQUFNLENBQUNyUSxHQUFHLENBQUMsRUFBRTtRQUNmcVEsTUFBTSxDQUFDclEsR0FBRyxDQUFDLENBQUN1RCxJQUFJLENBQUM3RixHQUFHLENBQUM7TUFDN0IsQ0FBTyxNQUFNO1FBQ0wyUyxNQUFNLENBQUNyUSxHQUFHLENBQUMsR0FBRyxDQUFDdEMsR0FBRyxDQUFDO01BQzNCO0lBQ0EsQ0FBSyxNQUFNO01BQ0wyUyxNQUFNLENBQUNyUSxHQUFHLENBQUMsR0FBR3FRLE1BQU0sQ0FBQ3JRLEdBQUcsQ0FBQyxHQUFHcVEsTUFBTSxDQUFDclEsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHdEMsR0FBRyxHQUFHQSxHQUFHO0lBQ2hFO0VBQ0EsQ0FBRyxDQUFDO0VBRUYsT0FBTzJTLE1BQU07QUFDZixDQUFDO0FDakRELE1BQU1HLFVBQVUsR0FBR2hTLE1BQU0sQ0FBQyxXQUFXLENBQUM7QUFFdEMsU0FBU2lTLGVBQWVBLENBQUNDLE1BQU0sRUFBRTtFQUMvQixPQUFPQSxNQUFNLElBQUlyTyxNQUFNLENBQUNxTyxNQUFNLENBQUMsQ0FBQ3JSLElBQUksRUFBRSxDQUFDcEMsV0FBVyxFQUFFO0FBQ3REO0FBRUEsU0FBUzBULGNBQWNBLENBQUNsUCxLQUFLLEVBQUU7RUFDN0IsSUFBSUEsS0FBSyxLQUFLLEtBQUssSUFBSUEsS0FBSyxJQUFJLElBQUksRUFBRTtJQUNwQyxPQUFPQSxLQUFLO0VBQ2hCO0VBRUUsT0FBTytFLEtBQUssQ0FBQ2xKLE9BQU8sQ0FBQ21FLEtBQUssQ0FBQyxHQUFHQSxLQUFLLENBQUM0RyxHQUFHLENBQUNzSSxjQUFjLENBQUMsR0FBR3RPLE1BQU0sQ0FBQ1osS0FBSyxDQUFDO0FBQ3pFO0FBRUEsU0FBU21QLFdBQVdBLENBQUM5VCxHQUFHLEVBQUU7RUFDeEIsTUFBTStULE1BQU0sR0FBR3JVLE1BQU0sQ0FBQ1UsTUFBTSxDQUFDLElBQUksQ0FBQztFQUNsQyxNQUFNNFQsUUFBUSxHQUFHLGtDQUFrQztFQUNuRCxJQUFJdEcsS0FBSztFQUVULE9BQVFBLEtBQUssR0FBR3NHLFFBQVEsQ0FBQ3hOLElBQUksQ0FBQ3hHLEdBQUcsQ0FBQyxFQUFHO0lBQ25DK1QsTUFBTSxDQUFDckcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUdBLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDL0I7RUFFRSxPQUFPcUcsTUFBTTtBQUNmO0FBRUEsU0FBU0UsaUJBQWlCQSxDQUFDalUsR0FBRyxFQUFFO0VBQzlCLE9BQU8sZUFBZSxDQUFDOEwsSUFBSSxDQUFDOUwsR0FBRyxDQUFDdUMsSUFBSSxFQUFFLENBQUM7QUFDekM7QUFFQSxTQUFTMlIsZ0JBQWdCQSxDQUFDdlEsT0FBTyxFQUFFZ0IsS0FBSyxFQUFFaVAsTUFBTSxFQUFFNU8sTUFBTSxFQUFFbVAsa0JBQWtCLEVBQUU7RUFDNUUsSUFBSXpLLEtBQUssQ0FBQzVJLFVBQVUsQ0FBQ2tFLE1BQU0sQ0FBQyxFQUFFO0lBQzVCLE9BQU9BLE1BQU0sQ0FBQy9FLElBQUksQ0FBQyxJQUFJLEVBQUUwRSxLQUFLLEVBQUVpUCxNQUFNLENBQUM7RUFDM0M7RUFFRSxJQUFJTyxrQkFBa0IsRUFBRTtJQUN0QnhQLEtBQUssR0FBR2lQLE1BQU07RUFDbEI7RUFFRSxJQUFJLENBQUNsSyxLQUFLLENBQUNySSxRQUFRLENBQUNzRCxLQUFLLENBQUMsRUFBRTtFQUU1QixJQUFJK0UsS0FBSyxDQUFDckksUUFBUSxDQUFDMkQsTUFBTSxDQUFDLEVBQUU7SUFDMUIsT0FBT0wsS0FBSyxDQUFDZSxPQUFPLENBQUNWLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztFQUN2QztFQUVFLElBQUkwRSxLQUFLLENBQUN4QyxRQUFRLENBQUNsQyxNQUFNLENBQUMsRUFBRTtJQUMxQixPQUFPQSxNQUFNLENBQUM4RyxJQUFJLENBQUNuSCxLQUFLLENBQUM7RUFDN0I7QUFDQTtBQUVBLFNBQVN5UCxZQUFZQSxDQUFDUixNQUFNLEVBQUU7RUFDNUIsT0FBT0EsTUFBTSxDQUFDclIsSUFBSSxFQUFFLENBQ2pCcEMsV0FBVyxFQUFFLENBQUNxQyxPQUFPLENBQUMsaUJBQWlCLEVBQUUsQ0FBQzZSLENBQUMsRUFBRUMsSUFBSSxFQUFFdFUsR0FBRyxLQUFLO0lBQzFELE9BQU9zVSxJQUFJLENBQUN0TixXQUFXLEVBQUUsR0FBR2hILEdBQUc7RUFDckMsQ0FBSyxDQUFDO0FBQ047QUFFQSxTQUFTdVUsY0FBY0EsQ0FBQzdSLEdBQUcsRUFBRWtSLE1BQU0sRUFBRTtFQUNuQyxNQUFNWSxZQUFZLEdBQUc5SyxLQUFLLENBQUMvQyxXQUFXLENBQUMsR0FBRyxHQUFHaU4sTUFBTSxDQUFDO0VBRXBELENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQ25SLE9BQU8sQ0FBQ2dTLFVBQVUsSUFBSTtJQUMxQy9VLE1BQU0sQ0FBQ2dGLGNBQWMsQ0FBQ2hDLEdBQUcsRUFBRStSLFVBQVUsR0FBR0QsWUFBWSxFQUFFO01BQ3BEN1AsS0FBSyxFQUFFLFNBQUFBLENBQVMrUCxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFO1FBQ2hDLE9BQU8sSUFBSSxDQUFDSCxVQUFVLENBQUMsQ0FBQ3hVLElBQUksQ0FBQyxJQUFJLEVBQUUyVCxNQUFNLEVBQUVjLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLENBQUM7TUFDcEUsQ0FBTztNQUNEQyxZQUFZLEVBQUU7SUFDcEIsQ0FBSyxDQUFDO0VBQ04sQ0FBRyxDQUFDO0FBQ0o7QUFFQSxNQUFNQyxZQUFZLENBQUM7RUFDakJqVSxXQUFXQSxDQUFDOFEsT0FBTyxFQUFFO0lBQ25CQSxPQUFPLElBQUksSUFBSSxDQUFDOUosR0FBRyxDQUFDOEosT0FBTyxDQUFDO0VBQ2hDO0VBRUU5SixHQUFHQSxDQUFDK0wsTUFBTSxFQUFFbUIsY0FBYyxFQUFFQyxPQUFPLEVBQUU7SUFDbkMsTUFBTXpSLElBQUksR0FBRyxJQUFJO0lBRWpCLFNBQVMwUixTQUFTQSxDQUFDQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFO01BQzVDLE1BQU1DLE9BQU8sR0FBRzFCLGVBQWUsQ0FBQ3dCLE9BQU8sQ0FBQztNQUV4QyxJQUFJLENBQUNFLE9BQU8sRUFBRTtRQUNaLE1BQU0sSUFBSXZOLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQztNQUNqRTtNQUVNLE1BQU01RSxHQUFHLEdBQUd3RyxLQUFLLENBQUN2RyxPQUFPLENBQUNJLElBQUksRUFBRThSLE9BQU8sQ0FBQztNQUV4QyxJQUFHLENBQUNuUyxHQUFHLElBQUlLLElBQUksQ0FBQ0wsR0FBRyxDQUFDLEtBQUtzQyxTQUFTLElBQUk0UCxRQUFRLEtBQUssSUFBSSxJQUFLQSxRQUFRLEtBQUs1UCxTQUFTLElBQUlqQyxJQUFJLENBQUNMLEdBQUcsQ0FBQyxLQUFLLEtBQU0sRUFBRTtRQUMxR0ssSUFBSSxDQUFDTCxHQUFHLElBQUlpUyxPQUFPLENBQUMsR0FBR3RCLGNBQWMsQ0FBQ3FCLE1BQU0sQ0FBQztNQUNyRDtJQUNBO0lBRUksTUFBTUksVUFBVSxHQUFHQSxDQUFDM0QsT0FBTyxFQUFFeUQsUUFBUSxLQUNuQzFMLEtBQUssQ0FBQ2pILE9BQU8sQ0FBQ2tQLE9BQU8sRUFBRSxDQUFDdUQsTUFBTSxFQUFFQyxPQUFPLEtBQUtGLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsQ0FBQyxDQUFDO0lBRW5GLElBQUkxTCxLQUFLLENBQUNqSSxhQUFhLENBQUNtUyxNQUFNLENBQUMsSUFBSUEsTUFBTSxZQUFZLElBQUksQ0FBQy9TLFdBQVcsRUFBRTtNQUNyRXlVLFVBQVUsQ0FBQzFCLE1BQU0sRUFBRW1CLGNBQWM7SUFDdkMsQ0FBSyxNQUFNLElBQUdyTCxLQUFLLENBQUNySSxRQUFRLENBQUN1UyxNQUFNLENBQUMsS0FBS0EsTUFBTSxHQUFHQSxNQUFNLENBQUNyUixJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMwUixpQkFBaUIsQ0FBQ0wsTUFBTSxDQUFDLEVBQUU7TUFDMUYwQixVQUFVLENBQUNqQyxZQUFZLENBQUNPLE1BQU0sQ0FBQyxFQUFFbUIsY0FBYyxDQUFDO0lBQ3RELENBQUssTUFBTTtNQUNMbkIsTUFBTSxJQUFJLElBQUksSUFBSXFCLFNBQVMsQ0FBQ0YsY0FBYyxFQUFFbkIsTUFBTSxFQUFFb0IsT0FBTyxDQUFDO0lBQ2xFO0lBRUksT0FBTyxJQUFJO0VBQ2Y7RUFFRU8sR0FBR0EsQ0FBQzNCLE1BQU0sRUFBRXhDLE1BQU0sRUFBRTtJQUNsQndDLE1BQU0sR0FBR0QsZUFBZSxDQUFDQyxNQUFNLENBQUM7SUFFaEMsSUFBSUEsTUFBTSxFQUFFO01BQ1YsTUFBTTFRLEdBQUcsR0FBR3dHLEtBQUssQ0FBQ3ZHLE9BQU8sQ0FBQyxJQUFJLEVBQUV5USxNQUFNLENBQUM7TUFFdkMsSUFBSTFRLEdBQUcsRUFBRTtRQUNQLE1BQU15QixLQUFLLEdBQUcsSUFBSSxDQUFDekIsR0FBRyxDQUFDO1FBRXZCLElBQUksQ0FBQ2tPLE1BQU0sRUFBRTtVQUNYLE9BQU96TSxLQUFLO1FBQ3RCO1FBRVEsSUFBSXlNLE1BQU0sS0FBSyxJQUFJLEVBQUU7VUFDbkIsT0FBTzBDLFdBQVcsQ0FBQ25QLEtBQUssQ0FBQztRQUNuQztRQUVRLElBQUkrRSxLQUFLLENBQUM1SSxVQUFVLENBQUNzUSxNQUFNLENBQUMsRUFBRTtVQUM1QixPQUFPQSxNQUFNLENBQUNuUixJQUFJLENBQUMsSUFBSSxFQUFFMEUsS0FBSyxFQUFFekIsR0FBRyxDQUFDO1FBQzlDO1FBRVEsSUFBSXdHLEtBQUssQ0FBQ3hDLFFBQVEsQ0FBQ2tLLE1BQU0sQ0FBQyxFQUFFO1VBQzFCLE9BQU9BLE1BQU0sQ0FBQzVLLElBQUksQ0FBQzdCLEtBQUssQ0FBQztRQUNuQztRQUVRLE1BQU0sSUFBSXVILFNBQVMsQ0FBQyx3Q0FBd0MsQ0FBQztNQUNyRTtJQUNBO0VBQ0E7RUFFRXNKLEdBQUdBLENBQUM1QixNQUFNLEVBQUU2QixPQUFPLEVBQUU7SUFDbkI3QixNQUFNLEdBQUdELGVBQWUsQ0FBQ0MsTUFBTSxDQUFDO0lBRWhDLElBQUlBLE1BQU0sRUFBRTtNQUNWLE1BQU0xUSxHQUFHLEdBQUd3RyxLQUFLLENBQUN2RyxPQUFPLENBQUMsSUFBSSxFQUFFeVEsTUFBTSxDQUFDO01BRXZDLE9BQU8sQ0FBQyxFQUFFMVEsR0FBRyxJQUFJLElBQUksQ0FBQ0EsR0FBRyxDQUFDLEtBQUtzQyxTQUFTLEtBQUssQ0FBQ2lRLE9BQU8sSUFBSXZCLGdCQUFnQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNoUixHQUFHLENBQUMsRUFBRUEsR0FBRyxFQUFFdVMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNoSDtJQUVJLE9BQU8sS0FBSztFQUNoQjtFQUVFQyxNQUFNQSxDQUFDOUIsTUFBTSxFQUFFNkIsT0FBTyxFQUFFO0lBQ3RCLE1BQU1sUyxJQUFJLEdBQUcsSUFBSTtJQUNqQixJQUFJb1MsT0FBTyxHQUFHLEtBQUs7SUFFbkIsU0FBU0MsWUFBWUEsQ0FBQ1QsT0FBTyxFQUFFO01BQzdCQSxPQUFPLEdBQUd4QixlQUFlLENBQUN3QixPQUFPLENBQUM7TUFFbEMsSUFBSUEsT0FBTyxFQUFFO1FBQ1gsTUFBTWpTLEdBQUcsR0FBR3dHLEtBQUssQ0FBQ3ZHLE9BQU8sQ0FBQ0ksSUFBSSxFQUFFNFIsT0FBTyxDQUFDO1FBRXhDLElBQUlqUyxHQUFHLEtBQUssQ0FBQ3VTLE9BQU8sSUFBSXZCLGdCQUFnQixDQUFDM1EsSUFBSSxFQUFFQSxJQUFJLENBQUNMLEdBQUcsQ0FBQyxFQUFFQSxHQUFHLEVBQUV1UyxPQUFPLENBQUMsQ0FBQyxFQUFFO1VBQ3hFLE9BQU9sUyxJQUFJLENBQUNMLEdBQUcsQ0FBQztVQUVoQnlTLE9BQU8sR0FBRyxJQUFJO1FBQ3hCO01BQ0E7SUFDQTtJQUVJLElBQUlqTSxLQUFLLENBQUNsSixPQUFPLENBQUNvVCxNQUFNLENBQUMsRUFBRTtNQUN6QkEsTUFBTSxDQUFDblIsT0FBTyxDQUFDbVQsWUFBWSxDQUFDO0lBQ2xDLENBQUssTUFBTTtNQUNMQSxZQUFZLENBQUNoQyxNQUFNLENBQUM7SUFDMUI7SUFFSSxPQUFPK0IsT0FBTztFQUNsQjtFQUVFNUcsS0FBS0EsQ0FBQzBHLE9BQU8sRUFBRTtJQUNiLE1BQU0xUyxJQUFJLEdBQUdyRCxNQUFNLENBQUNxRCxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzlCLElBQUlILENBQUMsR0FBR0csSUFBSSxDQUFDRCxNQUFNO0lBQ25CLElBQUk2UyxPQUFPLEdBQUcsS0FBSztJQUVuQixPQUFPL1MsQ0FBQyxFQUFFLEVBQUU7TUFDVixNQUFNTSxHQUFHLEdBQUdILElBQUksQ0FBQ0gsQ0FBQyxDQUFDO01BQ25CLElBQUcsQ0FBQzZTLE9BQU8sSUFBSXZCLGdCQUFnQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNoUixHQUFHLENBQUMsRUFBRUEsR0FBRyxFQUFFdVMsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQ3BFLE9BQU8sSUFBSSxDQUFDdlMsR0FBRyxDQUFDO1FBQ2hCeVMsT0FBTyxHQUFHLElBQUk7TUFDdEI7SUFDQTtJQUVJLE9BQU9BLE9BQU87RUFDbEI7RUFFRUUsU0FBU0EsQ0FBQ0MsTUFBTSxFQUFFO0lBQ2hCLE1BQU12UyxJQUFJLEdBQUcsSUFBSTtJQUNqQixNQUFNb08sT0FBTyxHQUFHLEVBQUU7SUFFbEJqSSxLQUFLLENBQUNqSCxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUNrQyxLQUFLLEVBQUVpUCxNQUFNLEtBQUs7TUFDckMsTUFBTTFRLEdBQUcsR0FBR3dHLEtBQUssQ0FBQ3ZHLE9BQU8sQ0FBQ3dPLE9BQU8sRUFBRWlDLE1BQU0sQ0FBQztNQUUxQyxJQUFJMVEsR0FBRyxFQUFFO1FBQ1BLLElBQUksQ0FBQ0wsR0FBRyxDQUFDLEdBQUcyUSxjQUFjLENBQUNsUCxLQUFLLENBQUM7UUFDakMsT0FBT3BCLElBQUksQ0FBQ3FRLE1BQU0sQ0FBQztRQUNuQjtNQUNSO01BRU0sTUFBTW1DLFVBQVUsR0FBR0QsTUFBTSxHQUFHMUIsWUFBWSxDQUFDUixNQUFNLENBQUMsR0FBR3JPLE1BQU0sQ0FBQ3FPLE1BQU0sQ0FBQyxDQUFDclIsSUFBSSxFQUFFO01BRXhFLElBQUl3VCxVQUFVLEtBQUtuQyxNQUFNLEVBQUU7UUFDekIsT0FBT3JRLElBQUksQ0FBQ3FRLE1BQU0sQ0FBQztNQUMzQjtNQUVNclEsSUFBSSxDQUFDd1MsVUFBVSxDQUFDLEdBQUdsQyxjQUFjLENBQUNsUCxLQUFLLENBQUM7TUFFeENnTixPQUFPLENBQUNvRSxVQUFVLENBQUMsR0FBRyxJQUFJO0lBQ2hDLENBQUssQ0FBQztJQUVGLE9BQU8sSUFBSTtFQUNmO0VBRUV6SyxNQUFNQSxDQUFDLEdBQUcwSyxPQUFPLEVBQUU7SUFDakIsT0FBTyxJQUFJLENBQUNuVixXQUFXLENBQUN5SyxNQUFNLENBQUMsSUFBSSxFQUFFLEdBQUcwSyxPQUFPLENBQUM7RUFDcEQ7RUFFRTdMLE1BQU1BLENBQUM4TCxTQUFTLEVBQUU7SUFDaEIsTUFBTXZULEdBQUcsR0FBR2hELE1BQU0sQ0FBQ1UsTUFBTSxDQUFDLElBQUksQ0FBQztJQUUvQnNKLEtBQUssQ0FBQ2pILE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQ2tDLEtBQUssRUFBRWlQLE1BQU0sS0FBSztNQUNyQ2pQLEtBQUssSUFBSSxJQUFJLElBQUlBLEtBQUssS0FBSyxLQUFLLEtBQUtqQyxHQUFHLENBQUNrUixNQUFNLENBQUMsR0FBR3FDLFNBQVMsSUFBSXZNLEtBQUssQ0FBQ2xKLE9BQU8sQ0FBQ21FLEtBQUssQ0FBQyxHQUFHQSxLQUFLLENBQUMrRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcvRyxLQUFLLENBQUM7SUFDdEgsQ0FBSyxDQUFDO0lBRUYsT0FBT2pDLEdBQUc7RUFDZDtFQUVFLENBQUNoQixNQUFNLENBQUNFLFFBQVEsSUFBSTtJQUNsQixPQUFPbEMsTUFBTSxDQUFDc1IsT0FBTyxDQUFDLElBQUksQ0FBQzdHLE1BQU0sRUFBRSxDQUFDLENBQUN6SSxNQUFNLENBQUNFLFFBQVEsQ0FBQyxFQUFFO0VBQzNEO0VBRUVuQyxRQUFRQSxDQUFBLEVBQUc7SUFDVCxPQUFPQyxNQUFNLENBQUNzUixPQUFPLENBQUMsSUFBSSxDQUFDN0csTUFBTSxFQUFFLENBQUMsQ0FBQ29CLEdBQUcsQ0FBQyxDQUFDLENBQUNxSSxNQUFNLEVBQUVqUCxLQUFLLENBQUMsS0FBS2lQLE1BQU0sR0FBRyxJQUFJLEdBQUdqUCxLQUFLLENBQUMsQ0FBQytHLElBQUksQ0FBQyxJQUFJLENBQUM7RUFDbkc7RUFFRSxLQUFLaEssTUFBTSxDQUFDQyxXQUFXLElBQUk7SUFDekIsT0FBTyxjQUFjO0VBQ3pCO0VBRUUsT0FBT2dKLElBQUlBLENBQUM1SyxLQUFLLEVBQUU7SUFDakIsT0FBT0EsS0FBSyxZQUFZLElBQUksR0FBR0EsS0FBSyxHQUFHLElBQUksSUFBSSxDQUFDQSxLQUFLLENBQUM7RUFDMUQ7RUFFRSxPQUFPdUwsTUFBTUEsQ0FBQzRLLEtBQUssRUFBRSxHQUFHRixPQUFPLEVBQUU7SUFDL0IsTUFBTUcsUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUM7SUFFaENGLE9BQU8sQ0FBQ3ZULE9BQU8sQ0FBRStHLE1BQU0sSUFBSzJNLFFBQVEsQ0FBQ3RPLEdBQUcsQ0FBQzJCLE1BQU0sQ0FBQyxDQUFDO0lBRWpELE9BQU8yTSxRQUFRO0VBQ25CO0VBRUUsT0FBT0MsUUFBUUEsQ0FBQ3hDLE1BQU0sRUFBRTtJQUN0QixNQUFNeUMsU0FBUyxHQUFHLElBQUksQ0FBQzNDLFVBQVUsQ0FBQyxHQUFJLElBQUksQ0FBQ0EsVUFBVSxDQUFDLEdBQUc7TUFDdkQ0QyxTQUFTLEVBQUU7SUFDakIsQ0FBTTtJQUVGLE1BQU1BLFNBQVMsR0FBR0QsU0FBUyxDQUFDQyxTQUFTO0lBQ3JDLE1BQU0zVyxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO0lBRWhDLFNBQVM0VyxjQUFjQSxDQUFDcEIsT0FBTyxFQUFFO01BQy9CLE1BQU1FLE9BQU8sR0FBRzFCLGVBQWUsQ0FBQ3dCLE9BQU8sQ0FBQztNQUV4QyxJQUFJLENBQUNtQixTQUFTLENBQUNqQixPQUFPLENBQUMsRUFBRTtRQUN2QmQsY0FBYyxDQUFDNVUsU0FBUyxFQUFFd1YsT0FBTyxDQUFDO1FBQ2xDbUIsU0FBUyxDQUFDakIsT0FBTyxDQUFDLEdBQUcsSUFBSTtNQUNqQztJQUNBO0lBRUkzTCxLQUFLLENBQUNsSixPQUFPLENBQUNvVCxNQUFNLENBQUMsR0FBR0EsTUFBTSxDQUFDblIsT0FBTyxDQUFDOFQsY0FBYyxDQUFDLEdBQUdBLGNBQWMsQ0FBQzNDLE1BQU0sQ0FBQztJQUUvRSxPQUFPLElBQUk7RUFDZjtBQUNBO0FBRUFrQixZQUFZLENBQUNzQixRQUFRLENBQUMsQ0FBQyxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLFlBQVksRUFBRSxlQUFlLENBQUMsQ0FBQztBQUVySDFNLEtBQUssQ0FBQ2hDLGFBQWEsQ0FBQ29OLFlBQVksQ0FBQ25WLFNBQVMsQ0FBQztBQUMzQytKLEtBQUssQ0FBQ2hDLGFBQWEsQ0FBQ29OLFlBQVksQ0FBQztBQUVqQyxJQUFBMEIsY0FBQSxHQUFlMUIsWUFBWTs7QUMzUjNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTMkIsYUFBYUEsQ0FBQ0MsR0FBRyxFQUFFek0sUUFBUSxFQUFFO0VBQ25ELE1BQU1GLE1BQU0sR0FBRyxJQUFJLElBQUlvSixVQUFRO0VBQy9CLE1BQU14UCxPQUFPLEdBQUdzRyxRQUFRLElBQUlGLE1BQU07RUFDbEMsTUFBTTRILE9BQU8sR0FBRzZFLGNBQVksQ0FBQzdMLElBQUksQ0FBQ2hILE9BQU8sQ0FBQ2dPLE9BQU8sQ0FBQztFQUNsRCxJQUFJcEIsSUFBSSxHQUFHNU0sT0FBTyxDQUFDNE0sSUFBSTtFQUV2QjdHLEtBQUssQ0FBQ2pILE9BQU8sQ0FBQ2lVLEdBQUcsRUFBRSxTQUFTQyxTQUFTQSxDQUFDdlgsRUFBRSxFQUFFO0lBQ3hDbVIsSUFBSSxHQUFHblIsRUFBRSxDQUFDYSxJQUFJLENBQUM4SixNQUFNLEVBQUV3RyxJQUFJLEVBQUVvQixPQUFPLENBQUNrRSxTQUFTLEVBQUUsRUFBRTVMLFFBQVEsR0FBR0EsUUFBUSxDQUFDUSxNQUFNLEdBQUdqRixTQUFTLENBQUM7RUFDN0YsQ0FBRyxDQUFDO0VBRUZtTSxPQUFPLENBQUNrRSxTQUFTLEVBQUU7RUFFbkIsT0FBT3RGLElBQUk7QUFDYjtBQ3pCZSxTQUFTcUcsUUFBUUEsQ0FBQ2pTLEtBQUssRUFBRTtFQUN0QyxPQUFPLENBQUMsRUFBRUEsS0FBSyxJQUFJQSxLQUFLLENBQUNrUyxVQUFVLENBQUM7QUFDdEM7O0FDQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0MsYUFBYUEsQ0FBQ2pOLE9BQU8sRUFBRUUsTUFBTSxFQUFFQyxPQUFPLEVBQUU7RUFDakQ7RUFDRUosVUFBVSxDQUFDM0osSUFBSSxDQUFDLElBQUksRUFBRTRKLE9BQU8sSUFBSSxJQUFJLEdBQUcsVUFBVSxHQUFHQSxPQUFPLEVBQUVELFVBQVUsQ0FBQ21OLFlBQVksRUFBRWhOLE1BQU0sRUFBRUMsT0FBTyxDQUFDO0VBQ3ZHLElBQUksQ0FBQ3hDLElBQUksR0FBRyxlQUFlO0FBQzdCO0FBRUFrQyxLQUFLLENBQUNwRixRQUFRLENBQUN3UyxhQUFhLEVBQUVsTixVQUFVLEVBQUU7RUFDeENpTixVQUFVLEVBQUU7QUFDZCxDQUFDLENBQUM7O0FDbEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLFNBQVNHLE1BQU1BLENBQUNDLE9BQU8sRUFBRUMsTUFBTSxFQUFFak4sUUFBUSxFQUFFO0VBQ3hELE1BQU02SSxjQUFjLEdBQUc3SSxRQUFRLENBQUNGLE1BQU0sQ0FBQytJLGNBQWM7RUFDckQsSUFBSSxDQUFDN0ksUUFBUSxDQUFDUSxNQUFNLElBQUksQ0FBQ3FJLGNBQWMsSUFBSUEsY0FBYyxDQUFDN0ksUUFBUSxDQUFDUSxNQUFNLENBQUMsRUFBRTtJQUMxRXdNLE9BQU8sQ0FBQ2hOLFFBQVEsQ0FBQztFQUNyQixDQUFHLE1BQU07SUFDTGlOLE1BQU0sQ0FBQyxJQUFJdE4sVUFBVSxDQUNuQixrQ0FBa0MsR0FBR0ssUUFBUSxDQUFDUSxNQUFNLEVBQ3BELENBQUNiLFVBQVUsQ0FBQ3VOLGVBQWUsRUFBRXZOLFVBQVUsQ0FBQzRJLGdCQUFnQixDQUFDLENBQUN4SixJQUFJLENBQUNvTyxLQUFLLENBQUNuTixRQUFRLENBQUNRLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDaEdSLFFBQVEsQ0FBQ0YsTUFBTSxFQUNmRSxRQUFRLENBQUNELE9BQU8sRUFDaEJDLFFBQVEsQ0FDVCxDQUFDO0VBQ047QUFDQTtBQ3JCQSxJQUFBb04sT0FBQSxHQUFlbkgsUUFBUSxDQUFDUCxvQkFBb0I7QUFFNUM7QUFDRyxTQUFTMkgsa0JBQWtCQSxDQUFBLEVBQUc7RUFDN0IsT0FBTztJQUNMQyxLQUFLLEVBQUUsU0FBU0EsS0FBS0EsQ0FBQy9QLElBQUksRUFBRTdDLEtBQUssRUFBRTZTLE9BQU8sRUFBRXBNLElBQUksRUFBRXFNLE1BQU0sRUFBRUMsTUFBTSxFQUFFO01BQ2hFLE1BQU1DLE1BQU0sR0FBRyxFQUFFO01BQ2pCQSxNQUFNLENBQUNsUixJQUFJLENBQUNlLElBQUksR0FBRyxHQUFHLEdBQUdpRyxrQkFBa0IsQ0FBQzlJLEtBQUssQ0FBQyxDQUFDO01BRW5ELElBQUkrRSxLQUFLLENBQUNwSSxRQUFRLENBQUNrVyxPQUFPLENBQUMsRUFBRTtRQUMzQkcsTUFBTSxDQUFDbFIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJbVIsSUFBSSxDQUFDSixPQUFPLENBQUMsQ0FBQ0ssV0FBVyxFQUFFLENBQUM7TUFDbkU7TUFFUSxJQUFJbk8sS0FBSyxDQUFDckksUUFBUSxDQUFDK0osSUFBSSxDQUFDLEVBQUU7UUFDeEJ1TSxNQUFNLENBQUNsUixJQUFJLENBQUMsT0FBTyxHQUFHMkUsSUFBSSxDQUFDO01BQ3JDO01BRVEsSUFBSTFCLEtBQUssQ0FBQ3JJLFFBQVEsQ0FBQ29XLE1BQU0sQ0FBQyxFQUFFO1FBQzFCRSxNQUFNLENBQUNsUixJQUFJLENBQUMsU0FBUyxHQUFHZ1IsTUFBTSxDQUFDO01BQ3pDO01BRVEsSUFBSUMsTUFBTSxLQUFLLElBQUksRUFBRTtRQUNuQkMsTUFBTSxDQUFDbFIsSUFBSSxDQUFDLFFBQVEsQ0FBQztNQUMvQjtNQUVRcUosUUFBUSxDQUFDNkgsTUFBTSxHQUFHQSxNQUFNLENBQUNqTSxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzNDLENBQU87SUFFRG9NLElBQUksRUFBRSxTQUFTQSxJQUFJQSxDQUFDdFEsSUFBSSxFQUFFO01BQ3hCLE1BQU1rRyxLQUFLLEdBQUdvQyxRQUFRLENBQUM2SCxNQUFNLENBQUNqSyxLQUFLLENBQUMsSUFBSXFLLE1BQU0sQ0FBQyxZQUFZLEdBQUd2USxJQUFJLEdBQUcsV0FBVyxDQUFDLENBQUM7TUFDbEYsT0FBUWtHLEtBQUssR0FBR3NLLGtCQUFrQixDQUFDdEssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSTtJQUMzRCxDQUFPO0lBRUR1SyxNQUFNLEVBQUUsU0FBU0EsTUFBTUEsQ0FBQ3pRLElBQUksRUFBRTtNQUM1QixJQUFJLENBQUMrUCxLQUFLLENBQUMvUCxJQUFJLEVBQUUsRUFBRSxFQUFFb1EsSUFBSSxDQUFDTSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUM7SUFDbkQ7RUFDQSxDQUFLO0FBQ0wsQ0FBRyxFQUFHO0FBRU47QUFDRyxTQUFTQyxxQkFBcUJBLENBQUEsRUFBRztFQUNoQyxPQUFPO0lBQ0xaLEtBQUssRUFBRSxTQUFTQSxLQUFLQSxDQUFBLEVBQUcsRUFBRTtJQUMxQk8sSUFBSSxFQUFFLFNBQVNBLElBQUlBLENBQUEsRUFBRztNQUFFLE9BQU8sSUFBSTtJQUFDLENBQUU7SUFDdENHLE1BQU0sRUFBRSxTQUFTQSxNQUFNQSxDQUFBLEVBQUc7RUFDaEMsQ0FBSztBQUNMLENBQUcsRUFBRzs7QUNqRE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTRyxhQUFhQSxDQUFDbkssR0FBRyxFQUFFO0VBQzNDO0VBQ0E7RUFDQTtFQUNFLE9BQU8sNkJBQTZCLENBQUNuQyxJQUFJLENBQUNtQyxHQUFHLENBQUM7QUFDaEQ7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLFNBQVNvSyxXQUFXQSxDQUFDQyxPQUFPLEVBQUVDLFdBQVcsRUFBRTtFQUN4RCxPQUFPQSxXQUFXLEdBQ2RELE9BQU8sQ0FBQzlWLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFHK1YsV0FBVyxDQUFDL1YsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FDbkU4VixPQUFPO0FBQ2I7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTRSxhQUFhQSxDQUFDRixPQUFPLEVBQUVHLFlBQVksRUFBRTtFQUMzRCxJQUFJSCxPQUFPLElBQUksQ0FBQ0YsYUFBYSxDQUFDSyxZQUFZLENBQUMsRUFBRTtJQUMzQyxPQUFPSixXQUFXLENBQUNDLE9BQU8sRUFBRUcsWUFBWSxDQUFDO0VBQzdDO0VBQ0UsT0FBT0EsWUFBWTtBQUNyQjtBQ2ZBLElBQUFDLGVBQUEsR0FBZXhJLFFBQVEsQ0FBQ1Asb0JBQW9CO0FBRTVDO0FBQ0E7QUFDRyxTQUFTMkgsa0JBQWtCQSxDQUFBLEVBQUc7RUFDN0IsTUFBTXFCLElBQUksR0FBRyxpQkFBaUIsQ0FBQzdNLElBQUksQ0FBQytELFNBQVMsQ0FBQytJLFNBQVMsQ0FBQztFQUN4RCxNQUFNQyxjQUFjLEdBQUcvSSxRQUFRLENBQUNnSixhQUFhLENBQUMsR0FBRyxDQUFDO0VBQ2xELElBQUlDLFNBQVM7O0VBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLFNBQVNDLFVBQVVBLENBQUMvSyxHQUFHLEVBQUU7SUFDdkIsSUFBSWdMLElBQUksR0FBR2hMLEdBQUc7SUFFZCxJQUFJMEssSUFBSSxFQUFFO01BQ2hCO01BQ1FFLGNBQWMsQ0FBQ0ssWUFBWSxDQUFDLE1BQU0sRUFBRUQsSUFBSSxDQUFDO01BQ3pDQSxJQUFJLEdBQUdKLGNBQWMsQ0FBQ0ksSUFBSTtJQUNsQztJQUVNSixjQUFjLENBQUNLLFlBQVksQ0FBQyxNQUFNLEVBQUVELElBQUksQ0FBQzs7SUFFL0M7SUFDTSxPQUFPO01BQ0xBLElBQUksRUFBRUosY0FBYyxDQUFDSSxJQUFJO01BQ3pCRSxRQUFRLEVBQUVOLGNBQWMsQ0FBQ00sUUFBUSxHQUFHTixjQUFjLENBQUNNLFFBQVEsQ0FBQzNXLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRTtNQUNsRjRXLElBQUksRUFBRVAsY0FBYyxDQUFDTyxJQUFJO01BQ3pCQyxNQUFNLEVBQUVSLGNBQWMsQ0FBQ1EsTUFBTSxHQUFHUixjQUFjLENBQUNRLE1BQU0sQ0FBQzdXLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRTtNQUM3RThXLElBQUksRUFBRVQsY0FBYyxDQUFDUyxJQUFJLEdBQUdULGNBQWMsQ0FBQ1MsSUFBSSxDQUFDOVcsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFO01BQ3RFK1csUUFBUSxFQUFFVixjQUFjLENBQUNVLFFBQVE7TUFDakNDLElBQUksRUFBRVgsY0FBYyxDQUFDVyxJQUFJO01BQ3pCQyxRQUFRLEVBQUdaLGNBQWMsQ0FBQ1ksUUFBUSxDQUFDQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUNsRGIsY0FBYyxDQUFDWSxRQUFRLEdBQ3ZCLEdBQUcsR0FBR1osY0FBYyxDQUFDWTtJQUMvQixDQUFPO0VBQ1A7RUFFSVYsU0FBUyxHQUFHQyxVQUFVLENBQUN4VixNQUFNLENBQUNtVyxRQUFRLENBQUNWLElBQUksQ0FBQzs7RUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksT0FBTyxTQUFTUCxlQUFlQSxDQUFDa0IsVUFBVSxFQUFFO0lBQzFDLE1BQU1yRyxNQUFNLEdBQUk3SixLQUFLLENBQUNySSxRQUFRLENBQUN1WSxVQUFVLENBQUMsR0FBSVosVUFBVSxDQUFDWSxVQUFVLENBQUMsR0FBR0EsVUFBVTtJQUNqRixPQUFRckcsTUFBTSxDQUFDNEYsUUFBUSxLQUFLSixTQUFTLENBQUNJLFFBQVEsSUFDMUM1RixNQUFNLENBQUM2RixJQUFJLEtBQUtMLFNBQVMsQ0FBQ0ssSUFBSTtFQUN4QyxDQUFLO0FBQ0wsQ0FBRyxFQUFHO0FBRU47QUFDRyxTQUFTakIscUJBQXFCQSxDQUFBLEVBQUc7RUFDaEMsT0FBTyxTQUFTTyxlQUFlQSxDQUFBLEVBQUc7SUFDaEMsT0FBTyxJQUFJO0VBQ2pCLENBQUs7QUFDTCxDQUFHLEVBQUc7QUNoRVMsU0FBU21CLGFBQWFBLENBQUM1TCxHQUFHLEVBQUU7RUFDekMsTUFBTVAsS0FBSyxHQUFHLDJCQUEyQixDQUFDbEgsSUFBSSxDQUFDeUgsR0FBRyxDQUFDO0VBQ25ELE9BQU9QLEtBQUssSUFBSUEsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUU7QUFDaEM7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU29NLFdBQVdBLENBQUNDLFlBQVksRUFBRUMsR0FBRyxFQUFFO0VBQ3RDRCxZQUFZLEdBQUdBLFlBQVksSUFBSSxFQUFFO0VBQ2pDLE1BQU1FLEtBQUssR0FBRyxJQUFJeFosS0FBSyxDQUFDc1osWUFBWSxDQUFDO0VBQ3JDLE1BQU1HLFVBQVUsR0FBRyxJQUFJelosS0FBSyxDQUFDc1osWUFBWSxDQUFDO0VBQzFDLElBQUlJLElBQUksR0FBRyxDQUFDO0VBQ1osSUFBSUMsSUFBSSxHQUFHLENBQUM7RUFDWixJQUFJQyxhQUFhO0VBRWpCTCxHQUFHLEdBQUdBLEdBQUcsS0FBS3hVLFNBQVMsR0FBR3dVLEdBQUcsR0FBRyxJQUFJO0VBRXBDLE9BQU8sU0FBU3ZULElBQUlBLENBQUM2VCxXQUFXLEVBQUU7SUFDaEMsTUFBTXBDLEdBQUcsR0FBR04sSUFBSSxDQUFDTSxHQUFHLEVBQUU7SUFFdEIsTUFBTXFDLFNBQVMsR0FBR0wsVUFBVSxDQUFDRSxJQUFJLENBQUM7SUFFbEMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7TUFDbEJBLGFBQWEsR0FBR25DLEdBQUc7SUFDekI7SUFFSStCLEtBQUssQ0FBQ0UsSUFBSSxDQUFDLEdBQUdHLFdBQVc7SUFDekJKLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDLEdBQUdqQyxHQUFHO0lBRXRCLElBQUl0VixDQUFDLEdBQUd3WCxJQUFJO0lBQ1osSUFBSUksVUFBVSxHQUFHLENBQUM7SUFFbEIsT0FBTzVYLENBQUMsS0FBS3VYLElBQUksRUFBRTtNQUNqQkssVUFBVSxJQUFJUCxLQUFLLENBQUNyWCxDQUFDLEVBQUUsQ0FBQztNQUN4QkEsQ0FBQyxHQUFHQSxDQUFDLEdBQUdtWCxZQUFZO0lBQzFCO0lBRUlJLElBQUksR0FBRyxDQUFDQSxJQUFJLEdBQUcsQ0FBQyxJQUFJSixZQUFZO0lBRWhDLElBQUlJLElBQUksS0FBS0MsSUFBSSxFQUFFO01BQ2pCQSxJQUFJLEdBQUcsQ0FBQ0EsSUFBSSxHQUFHLENBQUMsSUFBSUwsWUFBWTtJQUN0QztJQUVJLElBQUk3QixHQUFHLEdBQUdtQyxhQUFhLEdBQUdMLEdBQUcsRUFBRTtNQUM3QjtJQUNOO0lBRUksTUFBTVMsTUFBTSxHQUFHRixTQUFTLElBQUlyQyxHQUFHLEdBQUdxQyxTQUFTO0lBRTNDLE9BQU9FLE1BQU0sR0FBR3pSLElBQUksQ0FBQzBSLEtBQUssQ0FBQ0YsVUFBVSxHQUFHLElBQUksR0FBR0MsTUFBTSxDQUFDLEdBQUdqVixTQUFTO0VBQ3RFLENBQUc7QUFDSDtBQ3BDQSxTQUFTbVYsb0JBQW9CQSxDQUFDQyxRQUFRLEVBQUVDLGdCQUFnQixFQUFFO0VBQ3hELElBQUlDLGFBQWEsR0FBRyxDQUFDO0VBQ3JCLE1BQU1DLFlBQVksR0FBR2pCLFdBQVcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDO0VBRXpDLE9BQU94SSxDQUFDLElBQUk7SUFDVixNQUFNMEosTUFBTSxHQUFHMUosQ0FBQyxDQUFDMEosTUFBTTtJQUN2QixNQUFNQyxLQUFLLEdBQUczSixDQUFDLENBQUM0SixnQkFBZ0IsR0FBRzVKLENBQUMsQ0FBQzJKLEtBQUssR0FBR3pWLFNBQVM7SUFDdEQsTUFBTTJWLGFBQWEsR0FBR0gsTUFBTSxHQUFHRixhQUFhO0lBQzVDLE1BQU1NLElBQUksR0FBR0wsWUFBWSxDQUFDSSxhQUFhLENBQUM7SUFDeEMsTUFBTUUsT0FBTyxHQUFHTCxNQUFNLElBQUlDLEtBQUs7SUFFL0JILGFBQWEsR0FBR0UsTUFBTTtJQUV0QixNQUFNekssSUFBSSxHQUFHO01BQ1h5SyxNQUFNO01BQ05DLEtBQUs7TUFDTEssUUFBUSxFQUFFTCxLQUFLLEdBQUlELE1BQU0sR0FBR0MsS0FBSyxHQUFJelYsU0FBUztNQUM5Q3lVLEtBQUssRUFBRWtCLGFBQWE7TUFDcEJDLElBQUksRUFBRUEsSUFBSSxHQUFHQSxJQUFJLEdBQUc1VixTQUFTO01BQzdCK1YsU0FBUyxFQUFFSCxJQUFJLElBQUlILEtBQUssSUFBSUksT0FBTyxHQUFHLENBQUNKLEtBQUssR0FBR0QsTUFBTSxJQUFJSSxJQUFJLEdBQUc1VixTQUFTO01BQ3pFZ1csS0FBSyxFQUFFbEs7SUFDYixDQUFLO0lBRURmLElBQUksQ0FBQ3NLLGdCQUFnQixHQUFHLFVBQVUsR0FBRyxRQUFRLENBQUMsR0FBRyxJQUFJO0lBRXJERCxRQUFRLENBQUNySyxJQUFJLENBQUM7RUFDbEIsQ0FBRztBQUNIO0FBRUEsTUFBTWtMLHFCQUFxQixHQUFHLE9BQU9DLGNBQWMsS0FBSyxXQUFXO0FBRW5FLElBQUFDLFVBQUEsR0FBZUYscUJBQXFCLElBQUksVUFBVTFSLE1BQU0sRUFBRTtFQUN4RCxPQUFPLElBQUk2UixPQUFPLENBQUMsU0FBU0Msa0JBQWtCQSxDQUFDNUUsT0FBTyxFQUFFQyxNQUFNLEVBQUU7SUFDOUQsSUFBSTRFLFdBQVcsR0FBRy9SLE1BQU0sQ0FBQ3dHLElBQUk7SUFDN0IsTUFBTXdMLGNBQWMsR0FBR3ZGLGNBQVksQ0FBQzdMLElBQUksQ0FBQ1osTUFBTSxDQUFDNEgsT0FBTyxDQUFDLENBQUNrRSxTQUFTLEVBQUU7SUFDcEUsTUFBTXZELFlBQVksR0FBR3ZJLE1BQU0sQ0FBQ3VJLFlBQVk7SUFDeEMsSUFBSTBKLFVBQVU7SUFDZCxTQUFTN1YsSUFBSUEsQ0FBQSxFQUFHO01BQ2QsSUFBSTRELE1BQU0sQ0FBQ2tTLFdBQVcsRUFBRTtRQUN0QmxTLE1BQU0sQ0FBQ2tTLFdBQVcsQ0FBQ0MsV0FBVyxDQUFDRixVQUFVLENBQUM7TUFDbEQ7TUFFTSxJQUFJalMsTUFBTSxDQUFDb1MsTUFBTSxFQUFFO1FBQ2pCcFMsTUFBTSxDQUFDb1MsTUFBTSxDQUFDQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUVKLFVBQVUsQ0FBQztNQUM5RDtJQUNBO0lBRUksSUFBSXRTLEtBQUssQ0FBQ3ZILFVBQVUsQ0FBQzJaLFdBQVcsQ0FBQyxLQUFLNUwsUUFBUSxDQUFDUCxvQkFBb0IsSUFBSU8sUUFBUSxDQUFDSCw2QkFBNkIsQ0FBQyxFQUFFO01BQzlHZ00sY0FBYyxDQUFDL0osY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNDOztJQUVJLElBQUloSSxPQUFPLEdBQUcsSUFBSTBSLGNBQWMsRUFBRTs7SUFFdEM7SUFDSSxJQUFJM1IsTUFBTSxDQUFDc1MsSUFBSSxFQUFFO01BQ2YsTUFBTUMsUUFBUSxHQUFHdlMsTUFBTSxDQUFDc1MsSUFBSSxDQUFDQyxRQUFRLElBQUksRUFBRTtNQUMzQyxNQUFNQyxRQUFRLEdBQUd4UyxNQUFNLENBQUNzUyxJQUFJLENBQUNFLFFBQVEsR0FBR0MsUUFBUSxDQUFDL08sa0JBQWtCLENBQUMxRCxNQUFNLENBQUNzUyxJQUFJLENBQUNFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsRUFBRTtNQUMvRlIsY0FBYyxDQUFDbFUsR0FBRyxDQUFDLGVBQWUsRUFBRSxRQUFRLEdBQUc0VSxJQUFJLENBQUNILFFBQVEsR0FBRyxHQUFHLEdBQUdDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JGO0lBRUksTUFBTUcsUUFBUSxHQUFHbEUsYUFBYSxDQUFDek8sTUFBTSxDQUFDdU8sT0FBTyxFQUFFdk8sTUFBTSxDQUFDa0UsR0FBRyxDQUFDO0lBRTFEakUsT0FBTyxDQUFDMlMsSUFBSSxDQUFDNVMsTUFBTSxDQUFDa0osTUFBTSxDQUFDak0sV0FBVyxFQUFFLEVBQUVnSCxRQUFRLENBQUMwTyxRQUFRLEVBQUUzUyxNQUFNLENBQUM2RCxNQUFNLEVBQUU3RCxNQUFNLENBQUM2UyxnQkFBZ0IsQ0FBQyxFQUFFLElBQUksQ0FBQzs7SUFFL0c7SUFDSTVTLE9BQU8sQ0FBQ3lJLE9BQU8sR0FBRzFJLE1BQU0sQ0FBQzBJLE9BQU87SUFFaEMsU0FBU29LLFNBQVNBLENBQUEsRUFBRztNQUNuQixJQUFJLENBQUM3UyxPQUFPLEVBQUU7UUFDWjtNQUNSO01BQ0E7TUFDTSxNQUFNOFMsZUFBZSxHQUFHdEcsY0FBWSxDQUFDN0wsSUFBSSxDQUN2Qyx1QkFBdUIsSUFBSVgsT0FBTyxJQUFJQSxPQUFPLENBQUMrUyxxQkFBcUIsRUFBRSxDQUN0RTtNQUNELE1BQU1DLFlBQVksR0FBRyxDQUFDMUssWUFBWSxJQUFJQSxZQUFZLEtBQUssTUFBTSxJQUFJQSxZQUFZLEtBQUssTUFBTSxHQUN0RnRJLE9BQU8sQ0FBQ2lULFlBQVksR0FBR2pULE9BQU8sQ0FBQ0MsUUFBUTtNQUN6QyxNQUFNQSxRQUFRLEdBQUc7UUFDZnNHLElBQUksRUFBRXlNLFlBQVk7UUFDbEJ2UyxNQUFNLEVBQUVULE9BQU8sQ0FBQ1MsTUFBTTtRQUN0QnlTLFVBQVUsRUFBRWxULE9BQU8sQ0FBQ2tULFVBQVU7UUFDOUJ2TCxPQUFPLEVBQUVtTCxlQUFlO1FBQ3hCL1MsTUFBTTtRQUNOQztNQUNSLENBQU87TUFFRGdOLE1BQU0sQ0FBQyxTQUFTbUcsUUFBUUEsQ0FBQ3hZLEtBQUssRUFBRTtRQUM5QnNTLE9BQU8sQ0FBQ3RTLEtBQUssQ0FBQztRQUNkd0IsSUFBSSxFQUFFO01BQ2QsQ0FBTyxFQUFFLFNBQVNpWCxPQUFPQSxDQUFDQyxHQUFHLEVBQUU7UUFDdkJuRyxNQUFNLENBQUNtRyxHQUFHLENBQUM7UUFDWGxYLElBQUksRUFBRTtNQUNkLENBQU8sRUFBRThELFFBQVEsQ0FBQzs7TUFFbEI7TUFDTUQsT0FBTyxHQUFHLElBQUk7SUFDcEI7SUFFSSxJQUFJLFdBQVcsSUFBSUEsT0FBTyxFQUFFO01BQ2hDO01BQ01BLE9BQU8sQ0FBQzZTLFNBQVMsR0FBR0EsU0FBUztJQUNuQyxDQUFLLE1BQU07TUFDWDtNQUNNN1MsT0FBTyxDQUFDc1Qsa0JBQWtCLEdBQUcsU0FBU0MsVUFBVUEsQ0FBQSxFQUFHO1FBQ2pELElBQUksQ0FBQ3ZULE9BQU8sSUFBSUEsT0FBTyxDQUFDd1QsVUFBVSxLQUFLLENBQUMsRUFBRTtVQUN4QztRQUNWOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ1EsSUFBSXhULE9BQU8sQ0FBQ1MsTUFBTSxLQUFLLENBQUMsSUFBSSxFQUFFVCxPQUFPLENBQUN5VCxXQUFXLElBQUl6VCxPQUFPLENBQUN5VCxXQUFXLENBQUMvWCxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7VUFDaEc7UUFDVjtRQUNBO1FBQ0E7UUFDUWdZLFVBQVUsQ0FBQ2IsU0FBUyxDQUFDO01BQzdCLENBQU87SUFDUDs7SUFFQTtJQUNJN1MsT0FBTyxDQUFDMlQsT0FBTyxHQUFHLFNBQVNDLFdBQVdBLENBQUEsRUFBRztNQUN2QyxJQUFJLENBQUM1VCxPQUFPLEVBQUU7UUFDWjtNQUNSO01BRU1rTixNQUFNLENBQUMsSUFBSXROLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRUEsVUFBVSxDQUFDaVUsWUFBWSxFQUFFOVQsTUFBTSxFQUFFQyxPQUFPLENBQUMsQ0FBQzs7TUFFekY7TUFDTUEsT0FBTyxHQUFHLElBQUk7SUFDcEIsQ0FBSzs7SUFFTDtJQUNJQSxPQUFPLENBQUM4VCxPQUFPLEdBQUcsU0FBU0MsV0FBV0EsQ0FBQSxFQUFHO01BQzdDO01BQ0E7TUFDTTdHLE1BQU0sQ0FBQyxJQUFJdE4sVUFBVSxDQUFDLGVBQWUsRUFBRUEsVUFBVSxDQUFDb1UsV0FBVyxFQUFFalUsTUFBTSxFQUFFQyxPQUFPLENBQUMsQ0FBQzs7TUFFdEY7TUFDTUEsT0FBTyxHQUFHLElBQUk7SUFDcEIsQ0FBSzs7SUFFTDtJQUNJQSxPQUFPLENBQUNpVSxTQUFTLEdBQUcsU0FBU0MsYUFBYUEsQ0FBQSxFQUFHO01BQzNDLElBQUlDLG1CQUFtQixHQUFHcFUsTUFBTSxDQUFDMEksT0FBTyxHQUFHLGFBQWEsR0FBRzFJLE1BQU0sQ0FBQzBJLE9BQU8sR0FBRyxhQUFhLEdBQUcsa0JBQWtCO01BQzlHLE1BQU1qQixZQUFZLEdBQUd6SCxNQUFNLENBQUN5SCxZQUFZLElBQUlyQyxvQkFBb0I7TUFDaEUsSUFBSXBGLE1BQU0sQ0FBQ29VLG1CQUFtQixFQUFFO1FBQzlCQSxtQkFBbUIsR0FBR3BVLE1BQU0sQ0FBQ29VLG1CQUFtQjtNQUN4RDtNQUNNakgsTUFBTSxDQUFDLElBQUl0TixVQUFVLENBQ25CdVUsbUJBQW1CLEVBQ25CM00sWUFBWSxDQUFDbEMsbUJBQW1CLEdBQUcxRixVQUFVLENBQUN3VSxTQUFTLEdBQUd4VSxVQUFVLENBQUNpVSxZQUFZLEVBQ2pGOVQsTUFBTSxFQUNOQyxPQUFPLENBQUMsQ0FBQzs7TUFFakI7TUFDTUEsT0FBTyxHQUFHLElBQUk7SUFDcEIsQ0FBSzs7SUFFTDtJQUNBO0lBQ0E7SUFDSSxJQUFJa0csUUFBUSxDQUFDUCxvQkFBb0IsRUFBRTtNQUN2QztNQUNNLE1BQU0wTyxTQUFTLEdBQUcsQ0FBQ3RVLE1BQU0sQ0FBQ3VVLGVBQWUsSUFBSTVGLGVBQWUsQ0FBQ2dFLFFBQVEsQ0FBQyxLQUNqRTNTLE1BQU0sQ0FBQzJJLGNBQWMsSUFBSTJFLE9BQU8sQ0FBQ1MsSUFBSSxDQUFDL04sTUFBTSxDQUFDMkksY0FBYyxDQUFDO01BRWpFLElBQUkyTCxTQUFTLEVBQUU7UUFDYnRDLGNBQWMsQ0FBQ2xVLEdBQUcsQ0FBQ2tDLE1BQU0sQ0FBQzRJLGNBQWMsRUFBRTBMLFNBQVMsQ0FBQztNQUM1RDtJQUNBOztJQUVBO0lBQ0l2QyxXQUFXLEtBQUt0VyxTQUFTLElBQUl1VyxjQUFjLENBQUMvSixjQUFjLENBQUMsSUFBSSxDQUFDOztJQUVwRTtJQUNJLElBQUksa0JBQWtCLElBQUloSSxPQUFPLEVBQUU7TUFDakNOLEtBQUssQ0FBQ2pILE9BQU8sQ0FBQ3NaLGNBQWMsQ0FBQzVSLE1BQU0sRUFBRSxFQUFFLFNBQVNvVSxnQkFBZ0JBLENBQUMzZCxHQUFHLEVBQUVzQyxHQUFHLEVBQUU7UUFDekU4RyxPQUFPLENBQUN1VSxnQkFBZ0IsQ0FBQ3JiLEdBQUcsRUFBRXRDLEdBQUcsQ0FBQztNQUMxQyxDQUFPLENBQUM7SUFDUjs7SUFFQTtJQUNJLElBQUksQ0FBQzhJLEtBQUssQ0FBQ2hKLFdBQVcsQ0FBQ3FKLE1BQU0sQ0FBQ3VVLGVBQWUsQ0FBQyxFQUFFO01BQzlDdFUsT0FBTyxDQUFDc1UsZUFBZSxHQUFHLENBQUMsQ0FBQ3ZVLE1BQU0sQ0FBQ3VVLGVBQWU7SUFDeEQ7O0lBRUE7SUFDSSxJQUFJaE0sWUFBWSxJQUFJQSxZQUFZLEtBQUssTUFBTSxFQUFFO01BQzNDdEksT0FBTyxDQUFDc0ksWUFBWSxHQUFHdkksTUFBTSxDQUFDdUksWUFBWTtJQUNoRDs7SUFFQTtJQUNJLElBQUksT0FBT3ZJLE1BQU0sQ0FBQ3lVLGtCQUFrQixLQUFLLFVBQVUsRUFBRTtNQUNuRHhVLE9BQU8sQ0FBQ3lVLGdCQUFnQixDQUFDLFVBQVUsRUFBRTlELG9CQUFvQixDQUFDNVEsTUFBTSxDQUFDeVUsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakc7O0lBRUE7SUFDSSxJQUFJLE9BQU96VSxNQUFNLENBQUMyVSxnQkFBZ0IsS0FBSyxVQUFVLElBQUkxVSxPQUFPLENBQUMyVSxNQUFNLEVBQUU7TUFDbkUzVSxPQUFPLENBQUMyVSxNQUFNLENBQUNGLGdCQUFnQixDQUFDLFVBQVUsRUFBRTlELG9CQUFvQixDQUFDNVEsTUFBTSxDQUFDMlUsZ0JBQWdCLENBQUMsQ0FBQztJQUNoRztJQUVJLElBQUkzVSxNQUFNLENBQUNrUyxXQUFXLElBQUlsUyxNQUFNLENBQUNvUyxNQUFNLEVBQUU7TUFDN0M7TUFDQTtNQUNNSCxVQUFVLEdBQUc0QyxNQUFNLElBQUk7UUFDckIsSUFBSSxDQUFDNVUsT0FBTyxFQUFFO1VBQ1o7UUFDVjtRQUNRa04sTUFBTSxDQUFDLENBQUMwSCxNQUFNLElBQUlBLE1BQU0sQ0FBQ3RlLElBQUksR0FBRyxJQUFJd1csYUFBYSxDQUFDLElBQUksRUFBRS9NLE1BQU0sRUFBRUMsT0FBTyxDQUFDLEdBQUc0VSxNQUFNLENBQUM7UUFDbEY1VSxPQUFPLENBQUM2VSxLQUFLLEVBQUU7UUFDZjdVLE9BQU8sR0FBRyxJQUFJO01BQ3RCLENBQU87TUFFREQsTUFBTSxDQUFDa1MsV0FBVyxJQUFJbFMsTUFBTSxDQUFDa1MsV0FBVyxDQUFDNkMsU0FBUyxDQUFDOUMsVUFBVSxDQUFDO01BQzlELElBQUlqUyxNQUFNLENBQUNvUyxNQUFNLEVBQUU7UUFDakJwUyxNQUFNLENBQUNvUyxNQUFNLENBQUM0QyxPQUFPLEdBQUcvQyxVQUFVLEVBQUUsR0FBR2pTLE1BQU0sQ0FBQ29TLE1BQU0sQ0FBQ3NDLGdCQUFnQixDQUFDLE9BQU8sRUFBRXpDLFVBQVUsQ0FBQztNQUNsRztJQUNBO0lBRUksTUFBTTdDLFFBQVEsR0FBR1UsYUFBYSxDQUFDNkMsUUFBUSxDQUFDO0lBRXhDLElBQUl2RCxRQUFRLElBQUlqSixRQUFRLENBQUNHLFNBQVMsQ0FBQzNLLE9BQU8sQ0FBQ3lULFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO01BQzNEakMsTUFBTSxDQUFDLElBQUl0TixVQUFVLENBQUMsdUJBQXVCLEdBQUd1UCxRQUFRLEdBQUcsR0FBRyxFQUFFdlAsVUFBVSxDQUFDdU4sZUFBZSxFQUFFcE4sTUFBTSxDQUFDLENBQUM7TUFDcEc7SUFDTjs7SUFHQTtJQUNJQyxPQUFPLENBQUNnVixJQUFJLENBQUNsRCxXQUFXLElBQUksSUFBSSxDQUFDO0VBQ3JDLENBQUcsQ0FBQztBQUNKO0FDblBBLE1BQU1tRCxhQUFhLEdBQUc7RUFDcEJDLElBQUksRUFBRWxVLFdBQVc7RUFDakJtVSxHQUFHLEVBQUV4RDtBQUNQO0FBRUFqUyxLQUFLLENBQUNqSCxPQUFPLENBQUN3YyxhQUFhLEVBQUUsQ0FBQzdmLEVBQUUsRUFBRXVGLEtBQUssS0FBSztFQUMxQyxJQUFHdkYsRUFBRSxFQUFFO0lBQ0wsSUFBSTtNQUNGTSxNQUFNLENBQUNnRixjQUFjLENBQUN0RixFQUFFLEVBQUUsTUFBTSxFQUFFO1FBQUN1RjtNQUFLLENBQUMsQ0FBQztJQUNoRCxDQUFLLENBQUMsT0FBTzJNLENBQUMsRUFBRTtNQUNoQjtJQUFBO0lBRUk1UixNQUFNLENBQUNnRixjQUFjLENBQUN0RixFQUFFLEVBQUUsYUFBYSxFQUFFO01BQUN1RjtJQUFLLENBQUMsQ0FBQztFQUNyRDtBQUNBLENBQUMsQ0FBQztBQUVGLElBQUF5YSxRQUFBLEdBQWU7RUFDYkMsVUFBVSxFQUFHRCxRQUFRLElBQUs7SUFDeEJBLFFBQVEsR0FBRzFWLEtBQUssQ0FBQ2xKLE9BQU8sQ0FBQzRlLFFBQVEsQ0FBQyxHQUFHQSxRQUFRLEdBQUcsQ0FBQ0EsUUFBUSxDQUFDO0lBRTFELE1BQU07TUFBQ3RjO0lBQU0sQ0FBQyxHQUFHc2MsUUFBUTtJQUN6QixJQUFJRSxhQUFhO0lBQ2pCLElBQUk3TixPQUFPO0lBRVgsS0FBSyxJQUFJN08sQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHRSxNQUFNLEVBQUVGLENBQUMsRUFBRSxFQUFFO01BQy9CMGMsYUFBYSxHQUFHRixRQUFRLENBQUN4YyxDQUFDLENBQUM7TUFDM0IsSUFBSTZPLE9BQU8sR0FBRy9ILEtBQUssQ0FBQ3JJLFFBQVEsQ0FBQ2llLGFBQWEsQ0FBQyxHQUFHTCxhQUFhLENBQUNLLGFBQWEsQ0FBQ25mLFdBQVcsRUFBRSxDQUFDLEdBQUdtZixhQUFhLEVBQUc7UUFDekc7TUFDUjtJQUNBO0lBRUksSUFBSSxDQUFDN04sT0FBTyxFQUFFO01BQ1osSUFBSUEsT0FBTyxLQUFLLEtBQUssRUFBRTtRQUNyQixNQUFNLElBQUk3SCxVQUFVLENBQ2pCLFdBQVUwVixhQUFjLHNDQUFxQyxFQUM5RCxpQkFBaUIsQ0FDbEI7TUFDVDtNQUVNLE1BQU0sSUFBSXhYLEtBQUssQ0FDYjRCLEtBQUssQ0FBQ0MsVUFBVSxDQUFDc1YsYUFBYSxFQUFFSyxhQUFhLENBQUMsR0FDM0MsWUFBV0EsYUFBYyxpQ0FBZ0MsR0FDekQsb0JBQW1CQSxhQUFjLEdBQUUsQ0FDdkM7SUFDUDtJQUVJLElBQUksQ0FBQzVWLEtBQUssQ0FBQzVJLFVBQVUsQ0FBQzJRLE9BQU8sQ0FBQyxFQUFFO01BQzlCLE1BQU0sSUFBSXZGLFNBQVMsQ0FBQywyQkFBMkIsQ0FBQztJQUN0RDtJQUVJLE9BQU91RixPQUFPO0VBQ2xCLENBQUc7RUFDRDJOLFFBQVEsRUFBRUg7QUFDWjs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTTSw0QkFBNEJBLENBQUN4VixNQUFNLEVBQUU7RUFDNUMsSUFBSUEsTUFBTSxDQUFDa1MsV0FBVyxFQUFFO0lBQ3RCbFMsTUFBTSxDQUFDa1MsV0FBVyxDQUFDdUQsZ0JBQWdCLEVBQUU7RUFDekM7RUFFRSxJQUFJelYsTUFBTSxDQUFDb1MsTUFBTSxJQUFJcFMsTUFBTSxDQUFDb1MsTUFBTSxDQUFDNEMsT0FBTyxFQUFFO0lBQzFDLE1BQU0sSUFBSWpJLGFBQWEsQ0FBQyxJQUFJLEVBQUUvTSxNQUFNLENBQUM7RUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLFNBQVMwVixlQUFlQSxDQUFDMVYsTUFBTSxFQUFFO0VBQzlDd1YsNEJBQTRCLENBQUN4VixNQUFNLENBQUM7RUFFcENBLE1BQU0sQ0FBQzRILE9BQU8sR0FBRzZFLGNBQVksQ0FBQzdMLElBQUksQ0FBQ1osTUFBTSxDQUFDNEgsT0FBTyxDQUFDOztFQUVwRDtFQUNFNUgsTUFBTSxDQUFDd0csSUFBSSxHQUFHa0csYUFBYSxDQUFDeFcsSUFBSSxDQUM5QjhKLE1BQU0sRUFDTkEsTUFBTSxDQUFDMkgsZ0JBQWdCLENBQ3hCO0VBRUQsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUNoTSxPQUFPLENBQUNxRSxNQUFNLENBQUNrSixNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUMxRGxKLE1BQU0sQ0FBQzRILE9BQU8sQ0FBQ0ssY0FBYyxDQUFDLG1DQUFtQyxFQUFFLEtBQUssQ0FBQztFQUM3RTtFQUVFLE1BQU1QLE9BQU8sR0FBRzJOLFFBQVEsQ0FBQ0MsVUFBVSxDQUFDdFYsTUFBTSxDQUFDMEgsT0FBTyxJQUFJMEIsVUFBUSxDQUFDMUIsT0FBTyxDQUFDO0VBRXZFLE9BQU9BLE9BQU8sQ0FBQzFILE1BQU0sQ0FBQyxDQUFDMlYsSUFBSSxDQUFDLFNBQVNDLG1CQUFtQkEsQ0FBQzFWLFFBQVEsRUFBRTtJQUNqRXNWLDRCQUE0QixDQUFDeFYsTUFBTSxDQUFDOztJQUV4QztJQUNJRSxRQUFRLENBQUNzRyxJQUFJLEdBQUdrRyxhQUFhLENBQUN4VyxJQUFJLENBQ2hDOEosTUFBTSxFQUNOQSxNQUFNLENBQUNxSSxpQkFBaUIsRUFDeEJuSSxRQUFRLENBQ1Q7SUFFREEsUUFBUSxDQUFDMEgsT0FBTyxHQUFHNkUsY0FBWSxDQUFDN0wsSUFBSSxDQUFDVixRQUFRLENBQUMwSCxPQUFPLENBQUM7SUFFdEQsT0FBTzFILFFBQVE7RUFDbkIsQ0FBRyxFQUFFLFNBQVMyVixrQkFBa0JBLENBQUNDLE1BQU0sRUFBRTtJQUNyQyxJQUFJLENBQUNqSixRQUFRLENBQUNpSixNQUFNLENBQUMsRUFBRTtNQUNyQk4sNEJBQTRCLENBQUN4VixNQUFNLENBQUM7O01BRTFDO01BQ00sSUFBSThWLE1BQU0sSUFBSUEsTUFBTSxDQUFDNVYsUUFBUSxFQUFFO1FBQzdCNFYsTUFBTSxDQUFDNVYsUUFBUSxDQUFDc0csSUFBSSxHQUFHa0csYUFBYSxDQUFDeFcsSUFBSSxDQUN2QzhKLE1BQU0sRUFDTkEsTUFBTSxDQUFDcUksaUJBQWlCLEVBQ3hCeU4sTUFBTSxDQUFDNVYsUUFBUSxDQUNoQjtRQUNENFYsTUFBTSxDQUFDNVYsUUFBUSxDQUFDMEgsT0FBTyxHQUFHNkUsY0FBWSxDQUFDN0wsSUFBSSxDQUFDa1YsTUFBTSxDQUFDNVYsUUFBUSxDQUFDMEgsT0FBTyxDQUFDO01BQzVFO0lBQ0E7SUFFSSxPQUFPaUssT0FBTyxDQUFDMUUsTUFBTSxDQUFDMkksTUFBTSxDQUFDO0VBQ2pDLENBQUcsQ0FBQztBQUNKO0FDM0VBLE1BQU1DLGVBQWUsR0FBSS9mLEtBQUssSUFBS0EsS0FBSyxZQUFZeVcsY0FBWSxHQUFHelcsS0FBSyxDQUFDb0ssTUFBTSxFQUFFLEdBQUdwSyxLQUFLOztBQUV6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTZ2dCLFdBQVdBLENBQUNDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO0VBQ3REO0VBQ0VBLE9BQU8sR0FBR0EsT0FBTyxJQUFJLEVBQUU7RUFDdkIsTUFBTWxXLE1BQU0sR0FBRyxFQUFFO0VBRWpCLFNBQVNtVyxjQUFjQSxDQUFDMVcsTUFBTSxFQUFFRCxNQUFNLEVBQUUxRixRQUFRLEVBQUU7SUFDaEQsSUFBSTZGLEtBQUssQ0FBQ2pJLGFBQWEsQ0FBQytILE1BQU0sQ0FBQyxJQUFJRSxLQUFLLENBQUNqSSxhQUFhLENBQUM4SCxNQUFNLENBQUMsRUFBRTtNQUM5RCxPQUFPRyxLQUFLLENBQUM5RixLQUFLLENBQUMzRCxJQUFJLENBQUM7UUFBQzREO01BQVEsQ0FBQyxFQUFFMkYsTUFBTSxFQUFFRCxNQUFNLENBQUM7SUFDekQsQ0FBSyxNQUFNLElBQUlHLEtBQUssQ0FBQ2pJLGFBQWEsQ0FBQzhILE1BQU0sQ0FBQyxFQUFFO01BQ3RDLE9BQU9HLEtBQUssQ0FBQzlGLEtBQUssQ0FBQyxFQUFFLEVBQUUyRixNQUFNLENBQUM7SUFDcEMsQ0FBSyxNQUFNLElBQUlHLEtBQUssQ0FBQ2xKLE9BQU8sQ0FBQytJLE1BQU0sQ0FBQyxFQUFFO01BQ2hDLE9BQU9BLE1BQU0sQ0FBQ3JKLEtBQUssRUFBRTtJQUMzQjtJQUNJLE9BQU9xSixNQUFNO0VBQ2pCOztFQUVBO0VBQ0UsU0FBUzRXLG1CQUFtQkEsQ0FBQ2xjLENBQUMsRUFBRUMsQ0FBQyxFQUFFTCxRQUFRLEVBQUU7SUFDM0MsSUFBSSxDQUFDNkYsS0FBSyxDQUFDaEosV0FBVyxDQUFDd0QsQ0FBQyxDQUFDLEVBQUU7TUFDekIsT0FBT2djLGNBQWMsQ0FBQ2pjLENBQUMsRUFBRUMsQ0FBQyxFQUFFTCxRQUFRLENBQUM7SUFDM0MsQ0FBSyxNQUFNLElBQUksQ0FBQzZGLEtBQUssQ0FBQ2hKLFdBQVcsQ0FBQ3VELENBQUMsQ0FBQyxFQUFFO01BQ2hDLE9BQU9pYyxjQUFjLENBQUMxYSxTQUFTLEVBQUV2QixDQUFDLEVBQUVKLFFBQVEsQ0FBQztJQUNuRDtFQUNBOztFQUVBO0VBQ0UsU0FBU3VjLGdCQUFnQkEsQ0FBQ25jLENBQUMsRUFBRUMsQ0FBQyxFQUFFO0lBQzlCLElBQUksQ0FBQ3dGLEtBQUssQ0FBQ2hKLFdBQVcsQ0FBQ3dELENBQUMsQ0FBQyxFQUFFO01BQ3pCLE9BQU9nYyxjQUFjLENBQUMxYSxTQUFTLEVBQUV0QixDQUFDLENBQUM7SUFDekM7RUFDQTs7RUFFQTtFQUNFLFNBQVNtYyxnQkFBZ0JBLENBQUNwYyxDQUFDLEVBQUVDLENBQUMsRUFBRTtJQUM5QixJQUFJLENBQUN3RixLQUFLLENBQUNoSixXQUFXLENBQUN3RCxDQUFDLENBQUMsRUFBRTtNQUN6QixPQUFPZ2MsY0FBYyxDQUFDMWEsU0FBUyxFQUFFdEIsQ0FBQyxDQUFDO0lBQ3pDLENBQUssTUFBTSxJQUFJLENBQUN3RixLQUFLLENBQUNoSixXQUFXLENBQUN1RCxDQUFDLENBQUMsRUFBRTtNQUNoQyxPQUFPaWMsY0FBYyxDQUFDMWEsU0FBUyxFQUFFdkIsQ0FBQyxDQUFDO0lBQ3pDO0VBQ0E7O0VBRUE7RUFDRSxTQUFTcWMsZUFBZUEsQ0FBQ3JjLENBQUMsRUFBRUMsQ0FBQyxFQUFFZ0IsSUFBSSxFQUFFO0lBQ25DLElBQUlBLElBQUksSUFBSSthLE9BQU8sRUFBRTtNQUNuQixPQUFPQyxjQUFjLENBQUNqYyxDQUFDLEVBQUVDLENBQUMsQ0FBQztJQUNqQyxDQUFLLE1BQU0sSUFBSWdCLElBQUksSUFBSThhLE9BQU8sRUFBRTtNQUMxQixPQUFPRSxjQUFjLENBQUMxYSxTQUFTLEVBQUV2QixDQUFDLENBQUM7SUFDekM7RUFDQTtFQUVFLE1BQU1zYyxRQUFRLEdBQUc7SUFDZnRTLEdBQUcsRUFBRW1TLGdCQUFnQjtJQUNyQm5OLE1BQU0sRUFBRW1OLGdCQUFnQjtJQUN4QjdQLElBQUksRUFBRTZQLGdCQUFnQjtJQUN0QjlILE9BQU8sRUFBRStILGdCQUFnQjtJQUN6QjNPLGdCQUFnQixFQUFFMk8sZ0JBQWdCO0lBQ2xDak8saUJBQWlCLEVBQUVpTyxnQkFBZ0I7SUFDbkN6RCxnQkFBZ0IsRUFBRXlELGdCQUFnQjtJQUNsQzVOLE9BQU8sRUFBRTROLGdCQUFnQjtJQUN6QkcsY0FBYyxFQUFFSCxnQkFBZ0I7SUFDaEMvQixlQUFlLEVBQUUrQixnQkFBZ0I7SUFDakM1TyxPQUFPLEVBQUU0TyxnQkFBZ0I7SUFDekIvTixZQUFZLEVBQUUrTixnQkFBZ0I7SUFDOUIzTixjQUFjLEVBQUUyTixnQkFBZ0I7SUFDaEMxTixjQUFjLEVBQUUwTixnQkFBZ0I7SUFDaEMzQixnQkFBZ0IsRUFBRTJCLGdCQUFnQjtJQUNsQzdCLGtCQUFrQixFQUFFNkIsZ0JBQWdCO0lBQ3BDSSxVQUFVLEVBQUVKLGdCQUFnQjtJQUM1QnpOLGdCQUFnQixFQUFFeU4sZ0JBQWdCO0lBQ2xDeE4sYUFBYSxFQUFFd04sZ0JBQWdCO0lBQy9CSyxjQUFjLEVBQUVMLGdCQUFnQjtJQUNoQ00sU0FBUyxFQUFFTixnQkFBZ0I7SUFDM0JPLFNBQVMsRUFBRVAsZ0JBQWdCO0lBQzNCUSxVQUFVLEVBQUVSLGdCQUFnQjtJQUM1QnBFLFdBQVcsRUFBRW9FLGdCQUFnQjtJQUM3QlMsVUFBVSxFQUFFVCxnQkFBZ0I7SUFDNUJVLGdCQUFnQixFQUFFVixnQkFBZ0I7SUFDbEN2TixjQUFjLEVBQUV3TixlQUFlO0lBQy9CM08sT0FBTyxFQUFFQSxDQUFDMU4sQ0FBQyxFQUFFQyxDQUFDLEtBQUtpYyxtQkFBbUIsQ0FBQ0wsZUFBZSxDQUFDN2IsQ0FBQyxDQUFDLEVBQUU2YixlQUFlLENBQUM1YixDQUFDLENBQUMsRUFBRSxJQUFJO0VBQ3ZGLENBQUc7RUFFRHdGLEtBQUssQ0FBQ2pILE9BQU8sQ0FBQy9DLE1BQU0sQ0FBQ3FELElBQUksQ0FBQ2lkLE9BQU8sQ0FBQyxDQUFDMVUsTUFBTSxDQUFDNUwsTUFBTSxDQUFDcUQsSUFBSSxDQUFDa2QsT0FBTyxDQUFDLENBQUMsRUFBRSxTQUFTZSxrQkFBa0JBLENBQUM5YixJQUFJLEVBQUU7SUFDakcsTUFBTXRCLEtBQUssR0FBRzJjLFFBQVEsQ0FBQ3JiLElBQUksQ0FBQyxJQUFJaWIsbUJBQW1CO0lBQ25ELE1BQU1jLFdBQVcsR0FBR3JkLEtBQUssQ0FBQ29jLE9BQU8sQ0FBQzlhLElBQUksQ0FBQyxFQUFFK2EsT0FBTyxDQUFDL2EsSUFBSSxDQUFDLEVBQUVBLElBQUksQ0FBQztJQUM1RHdFLEtBQUssQ0FBQ2hKLFdBQVcsQ0FBQ3VnQixXQUFXLENBQUMsSUFBSXJkLEtBQUssS0FBSzBjLGVBQWUsS0FBTXZXLE1BQU0sQ0FBQzdFLElBQUksQ0FBQyxHQUFHK2IsV0FBVyxDQUFDO0VBQ2pHLENBQUcsQ0FBQztFQUVGLE9BQU9sWCxNQUFNO0FBQ2Y7QUN4R08sTUFBTW1YLE9BQU8sR0FBRyxPQUFPO0FDSzlCLE1BQU1DLFlBQVUsR0FBRyxFQUFFOztBQUVyQjtBQUNBLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzFlLE9BQU8sQ0FBQyxDQUFDbkMsSUFBSSxFQUFFc0MsQ0FBQyxLQUFLO0VBQ25GdWUsWUFBVSxDQUFDN2dCLElBQUksQ0FBQyxHQUFHLFNBQVM4Z0IsU0FBU0EsQ0FBQ3JoQixLQUFLLEVBQUU7SUFDM0MsT0FBTyxPQUFPQSxLQUFLLEtBQUtPLElBQUksSUFBSSxHQUFHLElBQUlzQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsR0FBR3RDLElBQUk7RUFDckUsQ0FBRztBQUNILENBQUMsQ0FBQztBQUVGLE1BQU0rZ0Isa0JBQWtCLEdBQUcsRUFBRTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FGLFlBQVUsQ0FBQzNQLFlBQVksR0FBRyxTQUFTQSxZQUFZQSxDQUFDNFAsU0FBUyxFQUFFRSxPQUFPLEVBQUV6WCxPQUFPLEVBQUU7RUFDM0UsU0FBUzBYLGFBQWFBLENBQUNDLEdBQUcsRUFBRUMsSUFBSSxFQUFFO0lBQ2hDLE9BQU8sVUFBVSxHQUFHUCxPQUFPLEdBQUcsMEJBQTBCLEdBQUdNLEdBQUcsR0FBRyxJQUFJLEdBQUdDLElBQUksSUFBSTVYLE9BQU8sR0FBRyxJQUFJLEdBQUdBLE9BQU8sR0FBRyxFQUFFLENBQUM7RUFDbEg7O0VBRUE7RUFDRSxPQUFPLENBQUNsRixLQUFLLEVBQUU2YyxHQUFHLEVBQUVFLElBQUksS0FBSztJQUMzQixJQUFJTixTQUFTLEtBQUssS0FBSyxFQUFFO01BQ3ZCLE1BQU0sSUFBSXhYLFVBQVUsQ0FDbEIyWCxhQUFhLENBQUNDLEdBQUcsRUFBRSxtQkFBbUIsSUFBSUYsT0FBTyxHQUFHLE1BQU0sR0FBR0EsT0FBTyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQzNFMVgsVUFBVSxDQUFDK1gsY0FBYyxDQUMxQjtJQUNQO0lBRUksSUFBSUwsT0FBTyxJQUFJLENBQUNELGtCQUFrQixDQUFDRyxHQUFHLENBQUMsRUFBRTtNQUN2Q0gsa0JBQWtCLENBQUNHLEdBQUcsQ0FBQyxHQUFHLElBQUk7TUFDcEM7TUFDTUksT0FBTyxDQUFDQyxJQUFJLENBQ1ZOLGFBQWEsQ0FDWEMsR0FBRyxFQUNILDhCQUE4QixHQUFHRixPQUFPLEdBQUcseUNBQXlDLENBQ3JGLENBQ0Y7SUFDUDtJQUVJLE9BQU9GLFNBQVMsR0FBR0EsU0FBUyxDQUFDemMsS0FBSyxFQUFFNmMsR0FBRyxFQUFFRSxJQUFJLENBQUMsR0FBRyxJQUFJO0VBQ3pELENBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTSSxhQUFhQSxDQUFDN1YsT0FBTyxFQUFFOFYsTUFBTSxFQUFFQyxZQUFZLEVBQUU7RUFDcEQsSUFBSSxPQUFPL1YsT0FBTyxLQUFLLFFBQVEsRUFBRTtJQUMvQixNQUFNLElBQUlyQyxVQUFVLENBQUMsMkJBQTJCLEVBQUVBLFVBQVUsQ0FBQ3FZLG9CQUFvQixDQUFDO0VBQ3RGO0VBQ0UsTUFBTWxmLElBQUksR0FBR3JELE1BQU0sQ0FBQ3FELElBQUksQ0FBQ2tKLE9BQU8sQ0FBQztFQUNqQyxJQUFJckosQ0FBQyxHQUFHRyxJQUFJLENBQUNELE1BQU07RUFDbkIsT0FBT0YsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO0lBQ2QsTUFBTTRlLEdBQUcsR0FBR3plLElBQUksQ0FBQ0gsQ0FBQyxDQUFDO0lBQ25CLE1BQU13ZSxTQUFTLEdBQUdXLE1BQU0sQ0FBQ1AsR0FBRyxDQUFDO0lBQzdCLElBQUlKLFNBQVMsRUFBRTtNQUNiLE1BQU16YyxLQUFLLEdBQUdzSCxPQUFPLENBQUN1VixHQUFHLENBQUM7TUFDMUIsTUFBTXZnQixNQUFNLEdBQUcwRCxLQUFLLEtBQUthLFNBQVMsSUFBSTRiLFNBQVMsQ0FBQ3pjLEtBQUssRUFBRTZjLEdBQUcsRUFBRXZWLE9BQU8sQ0FBQztNQUNwRSxJQUFJaEwsTUFBTSxLQUFLLElBQUksRUFBRTtRQUNuQixNQUFNLElBQUkySSxVQUFVLENBQUMsU0FBUyxHQUFHNFgsR0FBRyxHQUFHLFdBQVcsR0FBR3ZnQixNQUFNLEVBQUUySSxVQUFVLENBQUNxWSxvQkFBb0IsQ0FBQztNQUNyRztNQUNNO0lBQ047SUFDSSxJQUFJRCxZQUFZLEtBQUssSUFBSSxFQUFFO01BQ3pCLE1BQU0sSUFBSXBZLFVBQVUsQ0FBQyxpQkFBaUIsR0FBRzRYLEdBQUcsRUFBRTVYLFVBQVUsQ0FBQ3NZLGNBQWMsQ0FBQztJQUM5RTtFQUNBO0FBQ0E7QUFFQSxJQUFBZCxTQUFBLEdBQWU7RUFDYlUsYUFBYTtFQUNmSyxVQUFBLEVBQUVoQjtBQUNGLENBQUM7QUMvRUQsTUFBTWdCLFVBQVUsR0FBR2YsU0FBUyxDQUFDZSxVQUFVOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLEtBQUssQ0FBQztFQUNWdmhCLFdBQVdBLENBQUN3aEIsY0FBYyxFQUFFO0lBQzFCLElBQUksQ0FBQzlRLFFBQVEsR0FBRzhRLGNBQWM7SUFDOUIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7TUFDbEJ0WSxPQUFPLEVBQUUsSUFBSWtGLG9CQUFrQixFQUFFO01BQ2pDakYsUUFBUSxFQUFFLElBQUlpRixvQkFBa0I7SUFDdEMsQ0FBSztFQUNMOztFQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRWxGLE9BQU9BLENBQUN1WSxXQUFXLEVBQUV4WSxNQUFNLEVBQUU7SUFDL0I7SUFDQTtJQUNJLElBQUksT0FBT3dZLFdBQVcsS0FBSyxRQUFRLEVBQUU7TUFDbkN4WSxNQUFNLEdBQUdBLE1BQU0sSUFBSSxFQUFFO01BQ3JCQSxNQUFNLENBQUNrRSxHQUFHLEdBQUdzVSxXQUFXO0lBQzlCLENBQUssTUFBTTtNQUNMeFksTUFBTSxHQUFHd1ksV0FBVyxJQUFJLEVBQUU7SUFDaEM7SUFFSXhZLE1BQU0sR0FBR2dXLFdBQVcsQ0FBQyxJQUFJLENBQUN4TyxRQUFRLEVBQUV4SCxNQUFNLENBQUM7SUFFM0MsTUFBTTtNQUFDeUgsWUFBWTtNQUFFb0wsZ0JBQWdCO01BQUVqTDtJQUFPLENBQUMsR0FBRzVILE1BQU07SUFFeEQsSUFBSXlILFlBQVksS0FBS2hNLFNBQVMsRUFBRTtNQUM5QjRiLFNBQVMsQ0FBQ1UsYUFBYSxDQUFDdFEsWUFBWSxFQUFFO1FBQ3BDcEMsaUJBQWlCLEVBQUUrUyxVQUFVLENBQUMzUSxZQUFZLENBQUMyUSxVQUFVLENBQUNLLE9BQU8sQ0FBQztRQUM5RG5ULGlCQUFpQixFQUFFOFMsVUFBVSxDQUFDM1EsWUFBWSxDQUFDMlEsVUFBVSxDQUFDSyxPQUFPLENBQUM7UUFDOURsVCxtQkFBbUIsRUFBRTZTLFVBQVUsQ0FBQzNRLFlBQVksQ0FBQzJRLFVBQVUsQ0FBQ0ssT0FBTztNQUN2RSxDQUFPLEVBQUUsS0FBSyxDQUFDO0lBQ2Y7SUFFSSxJQUFJNUYsZ0JBQWdCLEtBQUtwWCxTQUFTLEVBQUU7TUFDbEM0YixTQUFTLENBQUNVLGFBQWEsQ0FBQ2xGLGdCQUFnQixFQUFFO1FBQ3hDclAsTUFBTSxFQUFFNFUsVUFBVSxDQUFDTSxRQUFRO1FBQzNCdFUsU0FBUyxFQUFFZ1UsVUFBVSxDQUFDTTtNQUM5QixDQUFPLEVBQUUsSUFBSSxDQUFDO0lBQ2Q7O0lBRUE7SUFDSTFZLE1BQU0sQ0FBQ2tKLE1BQU0sR0FBRyxDQUFDbEosTUFBTSxDQUFDa0osTUFBTSxJQUFJLElBQUksQ0FBQzFCLFFBQVEsQ0FBQzBCLE1BQU0sSUFBSSxLQUFLLEVBQUU5UyxXQUFXLEVBQUU7SUFFOUUsSUFBSXVpQixjQUFjOztJQUV0QjtJQUNJQSxjQUFjLEdBQUcvUSxPQUFPLElBQUlqSSxLQUFLLENBQUM5RixLQUFLLENBQ3JDK04sT0FBTyxDQUFDb0IsTUFBTSxFQUNkcEIsT0FBTyxDQUFDNUgsTUFBTSxDQUFDa0osTUFBTSxDQUFDLENBQ3ZCO0lBRUR5UCxjQUFjLElBQUloWixLQUFLLENBQUNqSCxPQUFPLENBQzdCLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLEVBQzFEd1EsTUFBTSxJQUFLO01BQ1YsT0FBT3RCLE9BQU8sQ0FBQ3NCLE1BQU0sQ0FBQztJQUM5QixDQUFPLENBQ0Y7SUFFRGxKLE1BQU0sQ0FBQzRILE9BQU8sR0FBRzZFLGNBQVksQ0FBQ2xMLE1BQU0sQ0FBQ29YLGNBQWMsRUFBRS9RLE9BQU8sQ0FBQzs7SUFFakU7SUFDSSxNQUFNZ1IsdUJBQXVCLEdBQUcsRUFBRTtJQUNsQyxJQUFJQyw4QkFBOEIsR0FBRyxJQUFJO0lBQ3pDLElBQUksQ0FBQ04sWUFBWSxDQUFDdFksT0FBTyxDQUFDdkgsT0FBTyxDQUFDLFNBQVNvZ0IsMEJBQTBCQSxDQUFDQyxXQUFXLEVBQUU7TUFDakYsSUFBSSxPQUFPQSxXQUFXLENBQUNsVSxPQUFPLEtBQUssVUFBVSxJQUFJa1UsV0FBVyxDQUFDbFUsT0FBTyxDQUFDN0UsTUFBTSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQ3RGO01BQ1I7TUFFTTZZLDhCQUE4QixHQUFHQSw4QkFBOEIsSUFBSUUsV0FBVyxDQUFDblUsV0FBVztNQUUxRmdVLHVCQUF1QixDQUFDSSxPQUFPLENBQUNELFdBQVcsQ0FBQ3JVLFNBQVMsRUFBRXFVLFdBQVcsQ0FBQ3BVLFFBQVEsQ0FBQztJQUNsRixDQUFLLENBQUM7SUFFRixNQUFNc1Usd0JBQXdCLEdBQUcsRUFBRTtJQUNuQyxJQUFJLENBQUNWLFlBQVksQ0FBQ3JZLFFBQVEsQ0FBQ3hILE9BQU8sQ0FBQyxTQUFTd2dCLHdCQUF3QkEsQ0FBQ0gsV0FBVyxFQUFFO01BQ2hGRSx3QkFBd0IsQ0FBQ3ZjLElBQUksQ0FBQ3FjLFdBQVcsQ0FBQ3JVLFNBQVMsRUFBRXFVLFdBQVcsQ0FBQ3BVLFFBQVEsQ0FBQztJQUNoRixDQUFLLENBQUM7SUFFRixJQUFJd1UsT0FBTztJQUNYLElBQUl0Z0IsQ0FBQyxHQUFHLENBQUM7SUFDVCxJQUFJSyxHQUFHO0lBRVAsSUFBSSxDQUFDMmYsOEJBQThCLEVBQUU7TUFDbkMsTUFBTU8sS0FBSyxHQUFHLENBQUMxRCxlQUFlLENBQUN0Z0IsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFcUcsU0FBUyxDQUFDO01BQ3JEMmQsS0FBSyxDQUFDSixPQUFPLENBQUN4akIsS0FBSyxDQUFDNGpCLEtBQUssRUFBRVIsdUJBQXVCLENBQUM7TUFDbkRRLEtBQUssQ0FBQzFjLElBQUksQ0FBQ2xILEtBQUssQ0FBQzRqQixLQUFLLEVBQUVILHdCQUF3QixDQUFDO01BQ2pEL2YsR0FBRyxHQUFHa2dCLEtBQUssQ0FBQ3JnQixNQUFNO01BRWxCb2dCLE9BQU8sR0FBR3RILE9BQU8sQ0FBQzNFLE9BQU8sQ0FBQ2xOLE1BQU0sQ0FBQztNQUVqQyxPQUFPbkgsQ0FBQyxHQUFHSyxHQUFHLEVBQUU7UUFDZGlnQixPQUFPLEdBQUdBLE9BQU8sQ0FBQ3hELElBQUksQ0FBQ3lELEtBQUssQ0FBQ3ZnQixDQUFDLEVBQUUsQ0FBQyxFQUFFdWdCLEtBQUssQ0FBQ3ZnQixDQUFDLEVBQUUsQ0FBQyxDQUFDO01BQ3REO01BRU0sT0FBT3NnQixPQUFPO0lBQ3BCO0lBRUlqZ0IsR0FBRyxHQUFHMGYsdUJBQXVCLENBQUM3ZixNQUFNO0lBRXBDLElBQUlzZ0IsU0FBUyxHQUFHclosTUFBTTtJQUV0Qm5ILENBQUMsR0FBRyxDQUFDO0lBRUwsT0FBT0EsQ0FBQyxHQUFHSyxHQUFHLEVBQUU7TUFDZCxNQUFNb2dCLFdBQVcsR0FBR1YsdUJBQXVCLENBQUMvZixDQUFDLEVBQUUsQ0FBQztNQUNoRCxNQUFNMGdCLFVBQVUsR0FBR1gsdUJBQXVCLENBQUMvZixDQUFDLEVBQUUsQ0FBQztNQUMvQyxJQUFJO1FBQ0Z3Z0IsU0FBUyxHQUFHQyxXQUFXLENBQUNELFNBQVMsQ0FBQztNQUMxQyxDQUFPLENBQUMsT0FBT3hZLEtBQUssRUFBRTtRQUNkMFksVUFBVSxDQUFDcmpCLElBQUksQ0FBQyxJQUFJLEVBQUUySyxLQUFLLENBQUM7UUFDNUI7TUFDUjtJQUNBO0lBRUksSUFBSTtNQUNGc1ksT0FBTyxHQUFHekQsZUFBZSxDQUFDeGYsSUFBSSxDQUFDLElBQUksRUFBRW1qQixTQUFTLENBQUM7SUFDckQsQ0FBSyxDQUFDLE9BQU94WSxLQUFLLEVBQUU7TUFDZCxPQUFPZ1IsT0FBTyxDQUFDMUUsTUFBTSxDQUFDdE0sS0FBSyxDQUFDO0lBQ2xDO0lBRUloSSxDQUFDLEdBQUcsQ0FBQztJQUNMSyxHQUFHLEdBQUcrZix3QkFBd0IsQ0FBQ2xnQixNQUFNO0lBRXJDLE9BQU9GLENBQUMsR0FBR0ssR0FBRyxFQUFFO01BQ2RpZ0IsT0FBTyxHQUFHQSxPQUFPLENBQUN4RCxJQUFJLENBQUNzRCx3QkFBd0IsQ0FBQ3BnQixDQUFDLEVBQUUsQ0FBQyxFQUFFb2dCLHdCQUF3QixDQUFDcGdCLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDMUY7SUFFSSxPQUFPc2dCLE9BQU87RUFDbEI7RUFFRUssTUFBTUEsQ0FBQ3haLE1BQU0sRUFBRTtJQUNiQSxNQUFNLEdBQUdnVyxXQUFXLENBQUMsSUFBSSxDQUFDeE8sUUFBUSxFQUFFeEgsTUFBTSxDQUFDO0lBQzNDLE1BQU0yUyxRQUFRLEdBQUdsRSxhQUFhLENBQUN6TyxNQUFNLENBQUN1TyxPQUFPLEVBQUV2TyxNQUFNLENBQUNrRSxHQUFHLENBQUM7SUFDMUQsT0FBT0QsUUFBUSxDQUFDME8sUUFBUSxFQUFFM1MsTUFBTSxDQUFDNkQsTUFBTSxFQUFFN0QsTUFBTSxDQUFDNlMsZ0JBQWdCLENBQUM7RUFDckU7QUFDQTs7QUFFQTtBQUNBbFQsS0FBSyxDQUFDakgsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLEVBQUUsU0FBU3VRLG1CQUFtQkEsQ0FBQ0MsTUFBTSxFQUFFO0VBQ3pGO0VBQ0VtUCxLQUFLLENBQUN6aUIsU0FBUyxDQUFDc1QsTUFBTSxDQUFDLEdBQUcsVUFBU2hGLEdBQUcsRUFBRWxFLE1BQU0sRUFBRTtJQUM5QyxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDK1YsV0FBVyxDQUFDaFcsTUFBTSxJQUFJLEVBQUUsRUFBRTtNQUM1Q2tKLE1BQU07TUFDTmhGLEdBQUc7TUFDSHNDLElBQUksRUFBRSxDQUFDeEcsTUFBTSxJQUFJLEVBQUUsRUFBRXdHO0lBQzNCLENBQUssQ0FBQyxDQUFDO0VBQ1AsQ0FBRztBQUNILENBQUMsQ0FBQztBQUVGN0csS0FBSyxDQUFDakgsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxTQUFTeVEscUJBQXFCQSxDQUFDRCxNQUFNLEVBQUU7RUFDL0U7O0VBRUUsU0FBU3VRLGtCQUFrQkEsQ0FBQ0MsTUFBTSxFQUFFO0lBQ2xDLE9BQU8sU0FBU0MsVUFBVUEsQ0FBQ3pWLEdBQUcsRUFBRXNDLElBQUksRUFBRXhHLE1BQU0sRUFBRTtNQUM1QyxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDK1YsV0FBVyxDQUFDaFcsTUFBTSxJQUFJLEVBQUUsRUFBRTtRQUM1Q2tKLE1BQU07UUFDTnRCLE9BQU8sRUFBRThSLE1BQU0sR0FBRztVQUNoQixjQUFjLEVBQUU7UUFDMUIsQ0FBUyxHQUFHLEVBQUU7UUFDTnhWLEdBQUc7UUFDSHNDO01BQ1IsQ0FBTyxDQUFDLENBQUM7SUFDVCxDQUFLO0VBQ0w7RUFFRTZSLEtBQUssQ0FBQ3ppQixTQUFTLENBQUNzVCxNQUFNLENBQUMsR0FBR3VRLGtCQUFrQixFQUFFO0VBRTlDcEIsS0FBSyxDQUFDemlCLFNBQVMsQ0FBQ3NULE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBR3VRLGtCQUFrQixDQUFDLElBQUksQ0FBQztBQUM3RCxDQUFDLENBQUM7QUFFRixJQUFBRyxPQUFBLEdBQWV2QixLQUFLOztBQ2hNcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNd0IsV0FBVyxDQUFDO0VBQ2hCL2lCLFdBQVdBLENBQUNnakIsUUFBUSxFQUFFO0lBQ3BCLElBQUksT0FBT0EsUUFBUSxLQUFLLFVBQVUsRUFBRTtNQUNsQyxNQUFNLElBQUkzWCxTQUFTLENBQUMsOEJBQThCLENBQUM7SUFDekQ7SUFFSSxJQUFJNFgsY0FBYztJQUVsQixJQUFJLENBQUNaLE9BQU8sR0FBRyxJQUFJdEgsT0FBTyxDQUFDLFNBQVNtSSxlQUFlQSxDQUFDOU0sT0FBTyxFQUFFO01BQzNENk0sY0FBYyxHQUFHN00sT0FBTztJQUM5QixDQUFLLENBQUM7SUFFRixNQUFNeEwsS0FBSyxHQUFHLElBQUk7O0lBRXRCO0lBQ0ksSUFBSSxDQUFDeVgsT0FBTyxDQUFDeEQsSUFBSSxDQUFDZCxNQUFNLElBQUk7TUFDMUIsSUFBSSxDQUFDblQsS0FBSyxDQUFDdVksVUFBVSxFQUFFO01BRXZCLElBQUlwaEIsQ0FBQyxHQUFHNkksS0FBSyxDQUFDdVksVUFBVSxDQUFDbGhCLE1BQU07TUFFL0IsT0FBT0YsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO1FBQ2Q2SSxLQUFLLENBQUN1WSxVQUFVLENBQUNwaEIsQ0FBQyxDQUFDLENBQUNnYyxNQUFNLENBQUM7TUFDbkM7TUFDTW5ULEtBQUssQ0FBQ3VZLFVBQVUsR0FBRyxJQUFJO0lBQzdCLENBQUssQ0FBQzs7SUFFTjtJQUNJLElBQUksQ0FBQ2QsT0FBTyxDQUFDeEQsSUFBSSxHQUFHdUUsV0FBVyxJQUFJO01BQ2pDLElBQUk5RyxRQUFRO01BQ2xCO01BQ00sTUFBTStGLE9BQU8sR0FBRyxJQUFJdEgsT0FBTyxDQUFDM0UsT0FBTyxJQUFJO1FBQ3JDeEwsS0FBSyxDQUFDcVQsU0FBUyxDQUFDN0gsT0FBTyxDQUFDO1FBQ3hCa0csUUFBUSxHQUFHbEcsT0FBTztNQUMxQixDQUFPLENBQUMsQ0FBQ3lJLElBQUksQ0FBQ3VFLFdBQVcsQ0FBQztNQUVwQmYsT0FBTyxDQUFDdEUsTUFBTSxHQUFHLFNBQVMxSCxNQUFNQSxDQUFBLEVBQUc7UUFDakN6TCxLQUFLLENBQUN5USxXQUFXLENBQUNpQixRQUFRLENBQUM7TUFDbkMsQ0FBTztNQUVELE9BQU8rRixPQUFPO0lBQ3BCLENBQUs7SUFFRFcsUUFBUSxDQUFDLFNBQVNqRixNQUFNQSxDQUFDL1UsT0FBTyxFQUFFRSxNQUFNLEVBQUVDLE9BQU8sRUFBRTtNQUNqRCxJQUFJeUIsS0FBSyxDQUFDb1UsTUFBTSxFQUFFO1FBQ3hCO1FBQ1E7TUFDUjtNQUVNcFUsS0FBSyxDQUFDb1UsTUFBTSxHQUFHLElBQUkvSSxhQUFhLENBQUNqTixPQUFPLEVBQUVFLE1BQU0sRUFBRUMsT0FBTyxDQUFDO01BQzFEOFosY0FBYyxDQUFDclksS0FBSyxDQUFDb1UsTUFBTSxDQUFDO0lBQ2xDLENBQUssQ0FBQztFQUNOOztFQUVBO0FBQ0E7QUFDQTtFQUNFTCxnQkFBZ0JBLENBQUEsRUFBRztJQUNqQixJQUFJLElBQUksQ0FBQ0ssTUFBTSxFQUFFO01BQ2YsTUFBTSxJQUFJLENBQUNBLE1BQU07SUFDdkI7RUFDQTs7RUFFQTtBQUNBO0FBQ0E7O0VBRUVmLFNBQVNBLENBQUNsRSxRQUFRLEVBQUU7SUFDbEIsSUFBSSxJQUFJLENBQUNpRixNQUFNLEVBQUU7TUFDZmpGLFFBQVEsQ0FBQyxJQUFJLENBQUNpRixNQUFNLENBQUM7TUFDckI7SUFDTjtJQUVJLElBQUksSUFBSSxDQUFDbUUsVUFBVSxFQUFFO01BQ25CLElBQUksQ0FBQ0EsVUFBVSxDQUFDdmQsSUFBSSxDQUFDbVUsUUFBUSxDQUFDO0lBQ3BDLENBQUssTUFBTTtNQUNMLElBQUksQ0FBQ29KLFVBQVUsR0FBRyxDQUFDcEosUUFBUSxDQUFDO0lBQ2xDO0VBQ0E7O0VBRUE7QUFDQTtBQUNBOztFQUVFc0IsV0FBV0EsQ0FBQ3RCLFFBQVEsRUFBRTtJQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDb0osVUFBVSxFQUFFO01BQ3BCO0lBQ047SUFDSSxNQUFNOVcsS0FBSyxHQUFHLElBQUksQ0FBQzhXLFVBQVUsQ0FBQ3RlLE9BQU8sQ0FBQ2tWLFFBQVEsQ0FBQztJQUMvQyxJQUFJMU4sS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFO01BQ2hCLElBQUksQ0FBQzhXLFVBQVUsQ0FBQ0UsTUFBTSxDQUFDaFgsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUN0QztFQUNBOztFQUVBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsT0FBTzNELE1BQU1BLENBQUEsRUFBRztJQUNkLElBQUlxVixNQUFNO0lBQ1YsTUFBTW5ULEtBQUssR0FBRyxJQUFJbVksV0FBVyxDQUFDLFNBQVNDLFFBQVFBLENBQUNNLENBQUMsRUFBRTtNQUNqRHZGLE1BQU0sR0FBR3VGLENBQUM7SUFDaEIsQ0FBSyxDQUFDO0lBQ0YsT0FBTztNQUNMMVksS0FBSztNQUNMbVQ7SUFDTixDQUFLO0VBQ0w7QUFDQTtBQUVBLElBQUF3RixhQUFBLEdBQWVSLFdBQVc7O0FDdEgxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTUyxNQUFNQSxDQUFDQyxRQUFRLEVBQUU7RUFDdkMsT0FBTyxTQUFTaGxCLElBQUlBLENBQUNzRyxHQUFHLEVBQUU7SUFDeEIsT0FBTzBlLFFBQVEsQ0FBQy9rQixLQUFLLENBQUMsSUFBSSxFQUFFcUcsR0FBRyxDQUFDO0VBQ3BDLENBQUc7QUFDSDs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTMmUsWUFBWUEsQ0FBQ0MsT0FBTyxFQUFFO0VBQzVDLE9BQU85YSxLQUFLLENBQUNuSSxRQUFRLENBQUNpakIsT0FBTyxDQUFDLElBQUtBLE9BQU8sQ0FBQ0QsWUFBWSxLQUFLLElBQUs7QUFDbkU7QUNiQSxNQUFNRSxjQUFjLEdBQUc7RUFDckJDLFFBQVEsRUFBRSxHQUFHO0VBQ2JDLGtCQUFrQixFQUFFLEdBQUc7RUFDdkJDLFVBQVUsRUFBRSxHQUFHO0VBQ2ZDLFVBQVUsRUFBRSxHQUFHO0VBQ2ZDLEVBQUUsRUFBRSxHQUFHO0VBQ1BDLE9BQU8sRUFBRSxHQUFHO0VBQ1pDLFFBQVEsRUFBRSxHQUFHO0VBQ2JDLDJCQUEyQixFQUFFLEdBQUc7RUFDaENDLFNBQVMsRUFBRSxHQUFHO0VBQ2RDLFlBQVksRUFBRSxHQUFHO0VBQ2pCQyxjQUFjLEVBQUUsR0FBRztFQUNuQkMsV0FBVyxFQUFFLEdBQUc7RUFDaEJDLGVBQWUsRUFBRSxHQUFHO0VBQ3BCQyxNQUFNLEVBQUUsR0FBRztFQUNYQyxlQUFlLEVBQUUsR0FBRztFQUNwQkMsZ0JBQWdCLEVBQUUsR0FBRztFQUNyQkMsS0FBSyxFQUFFLEdBQUc7RUFDVkMsUUFBUSxFQUFFLEdBQUc7RUFDYkMsV0FBVyxFQUFFLEdBQUc7RUFDaEJDLFFBQVEsRUFBRSxHQUFHO0VBQ2JDLE1BQU0sRUFBRSxHQUFHO0VBQ1hDLGlCQUFpQixFQUFFLEdBQUc7RUFDdEJDLGlCQUFpQixFQUFFLEdBQUc7RUFDdEJDLFVBQVUsRUFBRSxHQUFHO0VBQ2ZDLFlBQVksRUFBRSxHQUFHO0VBQ2pCQyxlQUFlLEVBQUUsR0FBRztFQUNwQkMsU0FBUyxFQUFFLEdBQUc7RUFDZEMsUUFBUSxFQUFFLEdBQUc7RUFDYkMsZ0JBQWdCLEVBQUUsR0FBRztFQUNyQkMsYUFBYSxFQUFFLEdBQUc7RUFDbEJDLDJCQUEyQixFQUFFLEdBQUc7RUFDaENDLGNBQWMsRUFBRSxHQUFHO0VBQ25CQyxRQUFRLEVBQUUsR0FBRztFQUNiQyxJQUFJLEVBQUUsR0FBRztFQUNUQyxjQUFjLEVBQUUsR0FBRztFQUNuQkMsa0JBQWtCLEVBQUUsR0FBRztFQUN2QkMsZUFBZSxFQUFFLEdBQUc7RUFDcEJDLFVBQVUsRUFBRSxHQUFHO0VBQ2ZDLG9CQUFvQixFQUFFLEdBQUc7RUFDekJDLG1CQUFtQixFQUFFLEdBQUc7RUFDeEJDLGlCQUFpQixFQUFFLEdBQUc7RUFDdEJDLFNBQVMsRUFBRSxHQUFHO0VBQ2RDLGtCQUFrQixFQUFFLEdBQUc7RUFDdkJDLG1CQUFtQixFQUFFLEdBQUc7RUFDeEJDLE1BQU0sRUFBRSxHQUFHO0VBQ1hDLGdCQUFnQixFQUFFLEdBQUc7RUFDckJDLFFBQVEsRUFBRSxHQUFHO0VBQ2JDLGVBQWUsRUFBRSxHQUFHO0VBQ3BCQyxvQkFBb0IsRUFBRSxHQUFHO0VBQ3pCQyxlQUFlLEVBQUUsR0FBRztFQUNwQkMsMkJBQTJCLEVBQUUsR0FBRztFQUNoQ0MsMEJBQTBCLEVBQUUsR0FBRztFQUMvQkMsbUJBQW1CLEVBQUUsR0FBRztFQUN4QkMsY0FBYyxFQUFFLEdBQUc7RUFDbkJDLFVBQVUsRUFBRSxHQUFHO0VBQ2ZDLGtCQUFrQixFQUFFLEdBQUc7RUFDdkJDLGNBQWMsRUFBRSxHQUFHO0VBQ25CQyx1QkFBdUIsRUFBRSxHQUFHO0VBQzVCQyxxQkFBcUIsRUFBRSxHQUFHO0VBQzFCQyxtQkFBbUIsRUFBRSxHQUFHO0VBQ3hCQyxZQUFZLEVBQUUsR0FBRztFQUNqQkMsV0FBVyxFQUFFLEdBQUc7RUFDaEJDLDZCQUE2QixFQUFFO0FBQ2pDLENBQUM7QUFFRDlvQixNQUFNLENBQUNzUixPQUFPLENBQUN5VCxjQUFjLENBQUMsQ0FBQ2hpQixPQUFPLENBQUMsQ0FBQyxDQUFDUyxHQUFHLEVBQUV5QixLQUFLLENBQUMsS0FBSztFQUN2RDhmLGNBQWMsQ0FBQzlmLEtBQUssQ0FBQyxHQUFHekIsR0FBRztBQUM3QixDQUFDLENBQUM7QUFFRixJQUFBdWxCLGdCQUFBLEdBQWVoRSxjQUFjOztBQ25EN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaUUsY0FBY0EsQ0FBQ0MsYUFBYSxFQUFFO0VBQ3JDLE1BQU1obEIsT0FBTyxHQUFHLElBQUlnZ0IsT0FBSyxDQUFDZ0YsYUFBYSxDQUFDO0VBQ3hDLE1BQU1DLFFBQVEsR0FBR3pwQixJQUFJLENBQUN3a0IsT0FBSyxDQUFDaGtCLFNBQVMsQ0FBQ3FLLE9BQU8sRUFBRXJHLE9BQU8sQ0FBQzs7RUFFekQ7RUFDRStGLEtBQUssQ0FBQzFGLE1BQU0sQ0FBQzRrQixRQUFRLEVBQUVqRixPQUFLLENBQUNoa0IsU0FBUyxFQUFFZ0UsT0FBTyxFQUFFO0lBQUNoQixVQUFVLEVBQUU7RUFBSSxDQUFDLENBQUM7O0VBRXRFO0VBQ0UrRyxLQUFLLENBQUMxRixNQUFNLENBQUM0a0IsUUFBUSxFQUFFamxCLE9BQU8sRUFBRSxJQUFJLEVBQUU7SUFBQ2hCLFVBQVUsRUFBRTtFQUFJLENBQUMsQ0FBQzs7RUFFM0Q7RUFDRWltQixRQUFRLENBQUN4b0IsTUFBTSxHQUFHLFNBQVNBLE1BQU1BLENBQUNpaUIsY0FBYyxFQUFFO0lBQ2hELE9BQU9xRyxjQUFjLENBQUMzSSxXQUFXLENBQUM0SSxhQUFhLEVBQUV0RyxjQUFjLENBQUMsQ0FBQztFQUNyRSxDQUFHO0VBRUQsT0FBT3VHLFFBQVE7QUFDakI7O0FBRUE7QUFDSyxNQUFDQyxLQUFLLEdBQUdILGNBQWMsQ0FBQ3ZWLFVBQVE7O0FBRXJDO0FBQ0EwVixLQUFLLENBQUN6RyxLQUFLLEdBQUd1QixPQUFLOztBQUVuQjtBQUNBa0YsS0FBSyxDQUFDL1IsYUFBYSxHQUFHQSxhQUFhO0FBQ25DK1IsS0FBSyxDQUFDakYsV0FBVyxHQUFHUSxhQUFXO0FBQy9CeUUsS0FBSyxDQUFDalMsUUFBUSxHQUFHQSxRQUFRO0FBQ3pCaVMsS0FBSyxDQUFDM0gsT0FBTyxHQUFHQSxPQUFPO0FBQ3ZCMkgsS0FBSyxDQUFDOWMsVUFBVSxHQUFHQSxVQUFVOztBQUU3QjtBQUNBOGMsS0FBSyxDQUFDamYsVUFBVSxHQUFHQSxVQUFVOztBQUU3QjtBQUNBaWYsS0FBSyxDQUFDQyxNQUFNLEdBQUdELEtBQUssQ0FBQy9SLGFBQWE7O0FBRWxDO0FBQ0ErUixLQUFLLENBQUNFLEdBQUcsR0FBRyxTQUFTQSxHQUFHQSxDQUFDQyxRQUFRLEVBQUU7RUFDakMsT0FBT3BOLE9BQU8sQ0FBQ21OLEdBQUcsQ0FBQ0MsUUFBUSxDQUFDO0FBQzlCLENBQUM7QUFFREgsS0FBSyxDQUFDeEUsTUFBTSxHQUFHQSxNQUFNOztBQUVyQjtBQUNBd0UsS0FBSyxDQUFDdEUsWUFBWSxHQUFHQSxZQUFZOztBQUVqQztBQUNBc0UsS0FBSyxDQUFDOUksV0FBVyxHQUFHQSxXQUFXO0FBRS9COEksS0FBSyxDQUFDL1QsWUFBWSxHQUFHMEIsY0FBWTtBQUVqQ3FTLEtBQUssQ0FBQ0ksVUFBVSxHQUFHbHBCLEtBQUssSUFBSTZRLGNBQWMsQ0FBQ2xILEtBQUssQ0FBQ2hELFVBQVUsQ0FBQzNHLEtBQUssQ0FBQyxHQUFHLElBQUlzQyxRQUFRLENBQUN0QyxLQUFLLENBQUMsR0FBR0EsS0FBSyxDQUFDO0FBRWpHOG9CLEtBQUssQ0FBQ3BFLGNBQWMsR0FBR2dFLGdCQUFjO0FBRXJDSSxLQUFLLENBQUNLLE9BQU8sR0FBR0wsS0FBSyJ9