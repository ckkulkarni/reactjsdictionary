20bdd6d4efb8d9ac4ee60e68ef296411
/* istanbul ignore next */
"use strict";

module.exports = minimatch;
minimatch.Minimatch = Minimatch;
var path = function () {
  try {
    return require('path');
  } catch (e) {}
}() || {
  sep: '/'
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = require('brace-expansion');
var plTypes = {
  '!': {
    open: '(?:(?!(?:',
    close: '))[^/]*?)'
  },
  '?': {
    open: '(?:',
    close: ')?'
  },
  '+': {
    open: '(?:',
    close: ')+'
  },
  '*': {
    open: '(?:',
    close: ')*'
  },
  '@': {
    open: '(?:',
    close: ')'
  }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var slashSplit = /\/+/;
minimatch.filter = filter;
function filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch(p, pattern, options);
  };
}
function ext(a, b) {
  b = b || {};
  var t = {};
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  return t;
}
minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch;
  }
  var orig = minimatch;
  var m = function minimatch(p, pattern, options) {
    return orig(p, pattern, ext(def, options));
  };
  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };
  m.Minimatch.defaults = function defaults(options) {
    return orig.defaults(ext(def, options)).Minimatch;
  };
  m.filter = function filter(pattern, options) {
    return orig.filter(pattern, ext(def, options));
  };
  m.defaults = function defaults(options) {
    return orig.defaults(ext(def, options));
  };
  m.makeRe = function makeRe(pattern, options) {
    return orig.makeRe(pattern, ext(def, options));
  };
  m.braceExpand = function braceExpand(pattern, options) {
    return orig.braceExpand(pattern, ext(def, options));
  };
  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options));
  };
  return m;
};
Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern, options) {
  assertValidPattern(pattern);
  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
}
function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options);
  }
  assertValidPattern(pattern);
  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/');
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.partial = !!options.partial;

  // make the set of regexps etc.
  this.make();
}
Minimatch.prototype.debug = function () {};
Minimatch.prototype.make = make;
function make() {
  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();
  if (options.debug) this.debug = function debug() {
    console.error.apply(console, arguments);
  };
  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit);
  });
  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });
  this.debug(this.pattern, set);
  this.set = set;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate) return;
  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
  assertValidPattern(pattern);

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern];
  }
  return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern');
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long');
  }
};

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
  assertValidPattern(pattern);
  var options = this.options;

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar) return GLOBSTAR;else pattern = '*';
  }
  if (pattern === '') return '';
  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;
  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star;
          hasMagic = true;
          break;
        case '?':
          re += qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }
  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }
    switch (c) {
      /* istanbul ignore next */
      case '/':
        {
          // completely not allowed, even escaped.
          // Should already be path-split by now.
          return false;
        }
      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;
      case '(':
        if (inClass) {
          re += '(';
          continue;
        }
        if (!stateChar) {
          re += '\\(';
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;
      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
        continue;
      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }
        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();
        if (inClass) {
          re += '\\' + c;
          continue;
        }
        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;
      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i);
        try {
          RegExp('[' + cs + ']');
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
          hasMagic = hasMagic || sp[1];
          inClass = false;
          continue;
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;
      default:
        // swallow any state char that wasn't consumed
        clearStateChar();
        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }
        re += c;
    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });
    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '[':
    case '.':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];
    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);
    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;
    var dollar = '';
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }
  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern);
  }
  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) /* istanbul ignore next - should be impossible */{
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }
  regExp._glob = pattern;
  regExp._src = re;
  return regExp;
}
minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;
  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';
  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';
  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) /* istanbul ignore next - should be impossible */{
    this.regexp = false;
  }
  return this.regexp;
}
minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
Minimatch.prototype.match = function match(f, partial) {
  if (typeof partial === 'undefined') partial = this.partial;
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';
  if (f === '/' && partial) return true;
  var options = this.options;

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }
  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
};

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;
  this.debug('matchOne', {
    'this': this,
    file: file,
    pattern: pattern
  });
  this.debug('matchOne', file.length, pattern.length);
  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];
    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false;
    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];
        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      hit = f === p;
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }
    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else /* istanbul ignore else */if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return fi === fl - 1 && file[fi] === '';
    }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?');
};

// replace stuff like \* with *
function globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}
function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibWluaW1hdGNoIiwiTWluaW1hdGNoIiwicGF0aCIsInJlcXVpcmUiLCJlIiwic2VwIiwiR0xPQlNUQVIiLCJleHBhbmQiLCJwbFR5cGVzIiwib3BlbiIsImNsb3NlIiwicW1hcmsiLCJzdGFyIiwidHdvU3RhckRvdCIsInR3b1N0YXJOb0RvdCIsInJlU3BlY2lhbHMiLCJjaGFyU2V0IiwicyIsInNwbGl0IiwicmVkdWNlIiwic2V0IiwiYyIsInNsYXNoU3BsaXQiLCJmaWx0ZXIiLCJwYXR0ZXJuIiwib3B0aW9ucyIsInAiLCJpIiwibGlzdCIsImV4dCIsImEiLCJiIiwidCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiayIsImRlZmF1bHRzIiwiZGVmIiwibGVuZ3RoIiwib3JpZyIsIm0iLCJtYWtlUmUiLCJicmFjZUV4cGFuZCIsIm1hdGNoIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwibm9jb21tZW50IiwiY2hhckF0IiwidHJpbSIsImFsbG93V2luZG93c0VzY2FwZSIsImpvaW4iLCJyZWdleHAiLCJuZWdhdGUiLCJjb21tZW50IiwiZW1wdHkiLCJwYXJ0aWFsIiwibWFrZSIsInByb3RvdHlwZSIsImRlYnVnIiwicGFyc2VOZWdhdGUiLCJnbG9iU2V0IiwiY29uc29sZSIsImVycm9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJnbG9iUGFydHMiLCJtYXAiLCJzaSIsInBhcnNlIiwiaW5kZXhPZiIsIm5lZ2F0ZU9mZnNldCIsIm5vbmVnYXRlIiwibCIsInN1YnN0ciIsIm5vYnJhY2UiLCJ0ZXN0IiwiTUFYX1BBVFRFUk5fTEVOR1RIIiwiVHlwZUVycm9yIiwiU1VCUEFSU0UiLCJpc1N1YiIsIm5vZ2xvYnN0YXIiLCJyZSIsImhhc01hZ2ljIiwibm9jYXNlIiwiZXNjYXBpbmciLCJwYXR0ZXJuTGlzdFN0YWNrIiwibmVnYXRpdmVMaXN0cyIsInN0YXRlQ2hhciIsImluQ2xhc3MiLCJyZUNsYXNzU3RhcnQiLCJjbGFzc1N0YXJ0IiwicGF0dGVyblN0YXJ0IiwiZG90Iiwic2VsZiIsImNsZWFyU3RhdGVDaGFyIiwibGVuIiwibm9leHQiLCJwdXNoIiwidHlwZSIsInN0YXJ0IiwicmVTdGFydCIsInBsIiwicG9wIiwicmVFbmQiLCJjcyIsInN1YnN0cmluZyIsIlJlZ0V4cCIsImVyIiwic3AiLCJ0YWlsIiwic2xpY2UiLCJyZXBsYWNlIiwiXyIsIiQxIiwiJDIiLCJhZGRQYXR0ZXJuU3RhcnQiLCJuIiwibmwiLCJubEJlZm9yZSIsIm5sRmlyc3QiLCJubExhc3QiLCJubEFmdGVyIiwib3BlblBhcmVuc0JlZm9yZSIsImNsZWFuQWZ0ZXIiLCJkb2xsYXIiLCJuZXdSZSIsImdsb2JVbmVzY2FwZSIsImZsYWdzIiwicmVnRXhwIiwiX2dsb2IiLCJfc3JjIiwidHdvU3RhciIsInJlZ0V4cEVzY2FwZSIsImV4IiwibW0iLCJmIiwibm9udWxsIiwiZmlsZW5hbWUiLCJmaWxlIiwibWF0Y2hCYXNlIiwiaGl0IiwibWF0Y2hPbmUiLCJmbGlwTmVnYXRlIiwiZmkiLCJwaSIsImZsIiwiZnIiLCJwciIsInN3YWxsb3dlZSIsIkVycm9yIl0sInNvdXJjZXMiOlsibWluaW1hdGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gbWluaW1hdGNoXG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoXG5cbnZhciBwYXRoID0gKGZ1bmN0aW9uICgpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ3BhdGgnKSB9IGNhdGNoIChlKSB7fX0oKSkgfHwge1xuICBzZXA6ICcvJ1xufVxubWluaW1hdGNoLnNlcCA9IHBhdGguc2VwXG5cbnZhciBHTE9CU1RBUiA9IG1pbmltYXRjaC5HTE9CU1RBUiA9IE1pbmltYXRjaC5HTE9CU1RBUiA9IHt9XG52YXIgZXhwYW5kID0gcmVxdWlyZSgnYnJhY2UtZXhwYW5zaW9uJylcblxudmFyIHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbnZhciBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xudmFyIHN0YXIgPSBxbWFyayArICcqPydcblxuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbnZhciByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKVxuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5mdW5jdGlvbiBjaGFyU2V0IChzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgYykge1xuICAgIHNldFtjXSA9IHRydWVcbiAgICByZXR1cm4gc2V0XG4gIH0sIHt9KVxufVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG52YXIgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBiID0gYiB8fCB7fVxuICB2YXIgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYVtrXVxuICB9KVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoXG4gIH1cblxuICB2YXIgb3JpZyA9IG1pbmltYXRjaFxuXG4gIHZhciBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLk1pbmltYXRjaCA9IGZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgb3JpZy5NaW5pbWF0Y2gocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cbiAgbS5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2hcbiAgfVxuXG4gIG0uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLm1ha2VSZSA9IGZ1bmN0aW9uIG1ha2VSZSAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICByZXR1cm4gbVxufVxuXG5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocClcbn1cblxuZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKCFvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSAmJiBwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLnNldCA9IFtdXG4gIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgdGhpcy5yZWdleHAgPSBudWxsXG4gIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgdGhpcy5jb21tZW50ID0gZmFsc2VcbiAgdGhpcy5lbXB0eSA9IGZhbHNlXG4gIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsXG5cbiAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICB0aGlzLm1ha2UoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge31cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlID0gbWFrZVxuZnVuY3Rpb24gbWFrZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHRoaXMuY29tbWVudCA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXBhdHRlcm4pIHtcbiAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICB2YXIgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHsgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpIH1cblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgLy8gbWF0Y2hpbmcgcGF0dGVybnMuXG4gIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNwbGl0KHNsYXNoU3BsaXQpXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBnbG9iIC0tPiByZWdleHBzXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKHMsIHNpLCBzZXQpIHtcbiAgICByZXR1cm4gcy5tYXAodGhpcy5wYXJzZSwgdGhpcylcbiAgfSwgdGhpcylcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihmYWxzZSkgPT09IC0xXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICB0aGlzLnNldCA9IHNldFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlTmVnYXRlID0gcGFyc2VOZWdhdGVcbmZ1bmN0aW9uIHBhcnNlTmVnYXRlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgaWYgKG9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGhcbiAgICA7IGkgPCBsICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISdcbiAgICA7IGkrKykge1xuICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICBuZWdhdGVPZmZzZXQrK1xuICB9XG5cbiAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIobmVnYXRlT2Zmc2V0KVxuICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxufVxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmRcblxuZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICB9XG5cbiAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJ1xuICAgID8gdGhpcy5wYXR0ZXJuIDogcGF0dGVyblxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxudmFyIE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NFxudmFyIGFzc2VydFZhbGlkUGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlID0gcGFyc2VcbnZhciBTVUJQQVJTRSA9IHt9XG5mdW5jdGlvbiBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhcilcbiAgICAgIHJldHVybiBHTE9CU1RBUlxuICAgIGVsc2VcbiAgICAgIHBhdHRlcm4gPSAnKidcbiAgfVxuICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gIHZhciByZSA9ICcnXG4gIHZhciBoYXNNYWdpYyA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgdmFyIGVzY2FwaW5nID0gZmFsc2VcbiAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICB2YXIgcGF0dGVybkxpc3RTdGFjayA9IFtdXG4gIHZhciBuZWdhdGl2ZUxpc3RzID0gW11cbiAgdmFyIHN0YXRlQ2hhclxuICB2YXIgaW5DbGFzcyA9IGZhbHNlXG4gIHZhciByZUNsYXNzU3RhcnQgPSAtMVxuICB2YXIgY2xhc3NTdGFydCA9IC0xXG4gIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gIC8vIGV2ZW4gd2hlbiBvcHRpb25zLmRvdCBpcyBzZXQuXG4gIHZhciBwYXR0ZXJuU3RhcnQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nID8gJycgLy8gYW55dGhpbmdcbiAgLy8gbm90IChzdGFydCBvciAvIGZvbGxvd2VkIGJ5IC4gb3IgLi4gZm9sbG93ZWQgYnkgLyBvciBlbmQpXG4gIDogb3B0aW9ucy5kb3QgPyAnKD8hKD86XnxcXFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFxcXC8pKSdcbiAgOiAnKD8hXFxcXC4pJ1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBjbGVhclN0YXRlQ2hhciAoKSB7XG4gICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgLy8gd2UgaGFkIHNvbWUgc3RhdGUtdHJhY2tpbmcgY2hhcmFjdGVyXG4gICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICBzd2l0Y2ggKHN0YXRlQ2hhcikge1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJlICs9IHFtYXJrXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgc3RhdGVDaGFyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzZWxmLmRlYnVnKCdjbGVhclN0YXRlQ2hhciAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aCwgY1xuICAgIDsgKGkgPCBsZW4pICYmIChjID0gcGF0dGVybi5jaGFyQXQoaSkpXG4gICAgOyBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAvLyBza2lwIG92ZXIgYW55IHRoYXQgYXJlIGVzY2FwZWQuXG4gICAgaWYgKGVzY2FwaW5nICYmIHJlU3BlY2lhbHNbY10pIHtcbiAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAvLyBTaG91bGQgYWxyZWFkeSBiZSBwYXRoLXNwbGl0IGJ5IG5vdy5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgIC8vIGFsbCBvZiB0aG9zZSBhcmUgbGl0ZXJhbHMgaW5zaWRlIGEgY2xhc3MsIGV4Y2VwdCB0aGF0XG4gICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCcgIGluIGNsYXNzJylcbiAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgc29tZXRoaW5nIGxpa2UgKiogb3IgKz8gaW4gdGhlcmUuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgc2VsZi5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgLy8ganVzdCBjbGVhciB0aGUgc3RhdGVjaGFyICpub3cqLCByYXRoZXIgdGhhbiBldmVuIGRpdmluZyBpbnRvXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBzdGF0ZUNoYXIsXG4gICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICBvcGVuOiBwbFR5cGVzW3N0YXRlQ2hhcl0ub3BlbixcbiAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICByZSArPSBzdGF0ZUNoYXIgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/OidcbiAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCknXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIHZhciBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKClcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgaWYgKHBsLnR5cGUgPT09ICchJykge1xuICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChwbClcbiAgICAgICAgfVxuICAgICAgICBwbC5yZUVuZCA9IHJlLmxlbmd0aFxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCB8fCBlc2NhcGluZykge1xuICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgcmUgKz0gJ3wnXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgcmVDbGFzc1N0YXJ0ID0gcmUubGVuZ3RoXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgLy8gIGEgYnJhY2tldCBleHByZXNzaW9uIGlmIGl0IG9jY3Vyc1xuICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgICAgICAvLyBcIlt6LWFdXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFt6LWFcXF1cIlxuICAgICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAvLyB0byBkbyBzYWZlbHkuICBGb3Igbm93LCB0aGlzIGlzIHNhZmUgYW5kIHdvcmtzLlxuICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWdFeHAoJ1snICsgY3MgKyAnXScpXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgY2xhc3MhXG4gICAgICAgICAgdmFyIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZFxuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChyZVNwZWNpYWxzW2NdXG4gICAgICAgICAgJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJlICs9IGNcblxuICAgIH0gLy8gc3dpdGNoXG4gIH0gLy8gZm9yXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAvLyBcIlthYmNcIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW2FiY1wiXG4gIGlmIChpbkNsYXNzKSB7XG4gICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAvLyB0aGlzIGlzIGEgaHVnZSBwaXRhLiAgV2Ugbm93IGhhdmUgdG8gcmUtd2Fsa1xuICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgY3MgPSBwYXR0ZXJuLnN1YnN0cihjbGFzc1N0YXJ0ICsgMSlcbiAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF1cbiAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgIHZhciB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAvLyBtYXliZSBzb21lIGV2ZW4gbnVtYmVyIG9mIFxcLCB0aGVuIG1heWJlIDEgXFwsIGZvbGxvd2VkIGJ5IGEgfFxuICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgIGlmICghJDIpIHtcbiAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICQyID0gJ1xcXFwnXG4gICAgICB9XG5cbiAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgLy9cbiAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICB9KVxuXG4gICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgIHZhciB0ID0gcGwudHlwZSA9PT0gJyonID8gc3RhclxuICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICBoYXNNYWdpYyA9IHRydWVcbiAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gIH1cblxuICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICBjbGVhclN0YXRlQ2hhcigpXG4gIGlmIChlc2NhcGluZykge1xuICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICByZSArPSAnXFxcXFxcXFwnXG4gIH1cblxuICAvLyBvbmx5IG5lZWQgdG8gYXBwbHkgdGhlIG5vZG90IHN0YXJ0IGlmIHRoZSByZSBzdGFydHMgd2l0aFxuICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gIHZhciBhZGRQYXR0ZXJuU3RhcnQgPSBmYWxzZVxuICBzd2l0Y2ggKHJlLmNoYXJBdCgwKSkge1xuICAgIGNhc2UgJ1snOiBjYXNlICcuJzogY2FzZSAnKCc6IGFkZFBhdHRlcm5TdGFydCA9IHRydWVcbiAgfVxuXG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAvLyBsaWtlICdhLnh5ei55eicgZG9lc24ndCBtYXRjaC4gIFNvLCB0aGUgZmlyc3QgbmVnYXRpdmVcbiAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAvLyB0aGUgcGF0dGVybi5cbiAgZm9yICh2YXIgbiA9IG5lZ2F0aXZlTGlzdHMubGVuZ3RoIC0gMTsgbiA+IC0xOyBuLS0pIHtcbiAgICB2YXIgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICB2YXIgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgIHZhciBubEZpcnN0ID0gcmUuc2xpY2UobmwucmVTdGFydCwgbmwucmVFbmQgLSA4KVxuICAgIHZhciBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKVxuICAgIHZhciBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG5cbiAgICBubExhc3QgKz0gbmxBZnRlclxuXG4gICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgIHZhciBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSAxXG4gICAgdmFyIGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgY2xlYW5BZnRlciA9IGNsZWFuQWZ0ZXIucmVwbGFjZSgvXFwpWysqP10/LywgJycpXG4gICAgfVxuICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICB2YXIgZG9sbGFyID0gJydcbiAgICBpZiAobmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFKSB7XG4gICAgICBkb2xsYXIgPSAnJCdcbiAgICB9XG4gICAgdmFyIG5ld1JlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIHJlID0gbmV3UmVcbiAgfVxuXG4gIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgIHJlID0gJyg/PS4pJyArIHJlXG4gIH1cblxuICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgcmUgPSBwYXR0ZXJuU3RhcnQgKyByZVxuICB9XG5cbiAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgaWYgKGlzU3ViID09PSBTVUJQQVJTRSkge1xuICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICB9XG5cbiAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAvLyB1bmVzY2FwZSBhbnl0aGluZyBpbiBpdCwgdGhvdWdoLCBzbyB0aGF0IGl0J2xsIGJlXG4gIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgaWYgKCFoYXNNYWdpYykge1xuICAgIHJldHVybiBnbG9iVW5lc2NhcGUocGF0dGVybilcbiAgfVxuXG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcbiAgdHJ5IHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZSArICckJywgZmxhZ3MpXG4gIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIG1tLm1hdGNoKGYpXG4gIH0pXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKGYsIHBhcnRpYWwpIHtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykgcGFydGlhbCA9IHRoaXMucGFydGlhbFxuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICBpZiAoZnIgPT09IGZsKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgIHZhciBoaXRcbiAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoaXQgPSBmID09PSBwXG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgcmV0dXJuIChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylc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